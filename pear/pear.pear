# Pear
#
# goal:
# - immutable
# - simple compiler that can be written in Forth / asm
#   - no optimizing compiler required
#   - no types, uniform object syntax
#
# how:
# - uniform object syntax with lots of pointer indirections

# everything is data, including functions
# data types:
# - numbers
# - words
# - structs
# - lambdas

# parentheses apply:
# & creates a struct
# \ creates a lambda
# : defines a variable
# word gets a struct field
# struct gets a struct field
# lambda executes with args






(let
  = @equal
  crash @crash
  not (\ a (if a :false :true))
  and (\ a b (if a b a))
  or (\ a b (if a a b))
  + @add
  * @multiply
  compare @compare
  # < (\ a b (= (compare a b) :less))
  # > (\ a b (= (compare a b) :greater))
  # <= (\ a b (let c (compare a b) = (compare a b) :equal))
  # >= (\ a b (= (compare a b) :equal))
  # list_0 (& length 0)
  # list_1 (\ a (& length 1 item a))
  # concat (\ a b (& length (+ (a :length) (b :length)) left a right b))
  # list_2 (\ a b (concat (list_1 a) (list_1 b)))
  # list_3 (\ a b c (concat (list_2 a b) (list_1 c)))
  # list_4 (\ a b c d (concat (list_2 a b) (list_2 c d)))
  # get (\ list index
  #   (if (= (list :length) 0)
  #     (crash :out_of_bounds)
  #     (if (> ))))


  # (concat (list_1 1) (list_1 2))
  # foo (if :true 3 5)
  # bar (\ a (& x a y a))
  # (& a foo b (bar 8) c :true)
  
  (* 2 3))











(let
  list
  (let
    make_1 (\ a (& type :leaf length 1 item a))
    make_2 (\ a b (& type :inner length 2 left (make_1 a) right (make_1 b)))
    make_3 (\ a b c (& type :inner length 3 left (make_2 a b) right (make_1 c)))
    get_rec (\ get_rec list index
      (if (>= index (list :length))
        (crash :index_too_big)
        (if (= (list :type) :inner)
          (list :item)
          (let
            left (list :left)
            right (list :right)
            (if (< index (left :length))
              (get_rec get_rec left index)
              (get_rec get_rec right (- index (left :size))))))))
    get (\ list index (get_rec get_rec list index))
    (&
      make_1 make_1
      make_2 make_2
      make_3 make_3))
  ((list :make_2) 1 2))

(let + (builtins :add)
  (+ 2 3))

(: a (& foo 1 bar 2)
  ((builtins :+) (a :bar) (a :foo)))

#(struct :foo)

# TODO: fibonacci



#(let core (import "core.cj")
#  (let + (. core :+)
#    (let bar foo
#      (let double (lambda a (+ a a))
#        (& :foo foo
#           :bar bar
#           :double double)))))
#
#(if :true 3 4)
#
#
#:nil
#[1 :nil]
#[1 [2 :nil]]
#
#[:let [:core [[:import ["core.cj" :nil]] ...]]]
#
#
#(&
#  :type :let
#  :name :core
#  :value (& :type :call :callee (& :type :import) :args )
#)
#
#
#
#
#fun(mem, a) {
#  malloc(mem)
#}
#
#
#core = import("core.cj")
#
#malloc(mem)
#core.foo
#
#
#