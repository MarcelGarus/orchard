(# Pear
  - data
   - immutable, acyclic
   - uniform object syntax
   - dynamically typed
   - garbage collected via refcouting
   - data types:
     - numbers: 64-bit integers
     - words: interned?
     - structs: shared pointer to layout
     - lambdas: store... code
     - builtins: @word_equal @add @subtract @multiply @divide @shift_left
       @shift_right @compare @crash @import
  - code
    - number literals
    - word literals
    - structs (with type and fields)
    - names (in lambdas)
    - lambdas (with param names and code)
    - builtins
    - apply
     - parentheses apply:
     - & creates a struct
     - \ creates a lambda
     - name gets a struct field
     - struct gets a struct field
     - lambda executes with args
    - if
)
(# Plan: compile the program into a tree of words with car/cdr fields)

(let
  (# Word stuff)
  = @word_equal

  (# Bool stuff
    A bool is either :true or :false.)
  not (\ a (if a :false :true))
  and (\ a b (if a b a))
  or  (\ a b (if a a b))
  xor (\ a b (if a (not b) b))

  (# Int stuff)
  +  @add
  -  @subtract
  *  @multiply
  /  @divide
  << @shift_left
  >> @shift_right
  compare @compare
  == (\ a b (= (compare a b) :equal))
  <  (\ a b (= (compare a b) :less))
  >  (\ a b (= (compare a b) :greater))
  != (\ a b (not (= compare a b) :equal))
  <= (\ a b (not (= (compare a b) :greater)))
  >= (\ a b (not (= (compare a b) :less)))

  (# Errors)
  crash @crash
  todo (\ (crash "Todo"))

  (# List stuff
    Lists have the form (& items ... length <int>). The items are a binary tree
    of minimal height and nodes filled up from the left. The length tells us
    exactly the layout of this tree. For example, a list of 5 items results in
    the following tree:
    (& length 5
       items
         (& left (& left (& left 0 right 1) right (& left 2 right 3))
            right (& left (& left 4 right nil) right nil)))
    )
  get_rec (\ get_rec items length index
    (if (== length 0)
      items
      (let
        num_left (>> length 1)
        num_right (- length num_left)
        (if (< index num_left)
          (get_rec (items :left) num_left index)
          (get_rec (items :right) num_right (- index num_left))))))
  get (\ list index
    (if (>= index length)
      (crash "out of bounds")
      (get_rec get_rec
        (list :items) (round_up_to_power_of (list :length) 2) index)))
  push_rec (\ push_rec items length item
    ())
  push (\ list item
    (push_rec
      push_rec (list :items) (round_up_to_power_of (list :length) 2)) item)
  list_0 (& length 0 items :nil)
  list_1 (\ a (push list_0 a) (& length 1 item a))
  list_2 (\ a b (push (list_1 a) b))
  list_3 (\ a b c (push (list_2 a b) c))
  list_4 (\ a b c d (push (list_3 a b c) d))

  (* 2 3))
