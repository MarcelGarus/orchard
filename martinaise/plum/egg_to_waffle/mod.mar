import ../plum.mar

fun to_waffle(egg: Egg): Waffle {
  var funs = map[String, WaffleFun]()
  for fun_ in egg.funs do {
    | eprintln("To waffle: {fun_.key}")
    funs.&.put(fun_.key, fun_.value.to_waffle())
  }
  Waffle { entry_point = egg.entry_point, funs }
}

fun to_waffle(fun_: EggFun): WaffleFun {
  var builder = waffle_body_builder().&
  var mapping = map[EggId, WaffleExpr]()

  var param_types = {
    var types = list[EggType]()
    for param in fun_.body.params do types.&.push(param.type())
    types.to_slice()
  }
  var param_layout = param_types.memory_layout_args()
  var param = create(waffle_param(param_layout.size, param_layout.alignment))
  for p in fun_.body.params.iter().enumerate() do {
    var layout = param_types.get(p.index).memory_layout()
    mapping.&.put(
      p.item,
      waffle_part(
        waffle_local(param), param_layout.offsets.get(p.index), layout
      ),
    )
  }

  var body = builder.finish(fun_.body.to_waffle(builder, mapping.&))

  WaffleFun { param, body }
}

| Assumes the parameters are already available.
fun to_waffle(
  body: EggBody, builder: &WaffleBodyBuilder, mapping: &Map[EggId, WaffleExpr]
): WaffleExpr {
  for id in body.children do {
    var expr = id.to_waffle(builder, mapping)
    if expr.definitely_diverges() then return expr
    mapping.&.put(id, builder.local(expr))
  }
  mapping.get(body.returns)
}

fun to_waffle(
  id: EggId, builder: &WaffleBodyBuilder, mapping: &Map[EggId, WaffleExpr]
): WaffleExpr {
  switch id.resolve()
  case param unreachable()
  case byte(byte) waffle_byte(byte)
  case lower_byte(int) waffle_lower_byte(mapping.get(int))
  case byte_to_int(byte) waffle_byte_to_int(mapping.get(byte))
  case int(int) waffle_int(int)
  case add(args)
    waffle_add(waffle_int_operands(mapping.get(args.a), mapping.get(args.b)))
  case subtract(args)
    waffle_subtract(
      waffle_int_operands(mapping.get(args.a), mapping.get(args.b))
    )
  case multiply(args)
    waffle_multiply(
      waffle_int_operands(mapping.get(args.a), mapping.get(args.b))
    )
  case unchecked_divide(args)
    waffle_divide(waffle_int_operands(mapping.get(args.a), mapping.get(args.b)))
  case unchecked_modulo(args)
    waffle_modulo(waffle_int_operands(mapping.get(args.a), mapping.get(args.b)))
  case shift_left(args)
    waffle_shift_left(
      waffle_int_operands(mapping.get(args.a), mapping.get(args.b))
    )
  case shift_right(args)
    waffle_shift_right(
      waffle_int_operands(mapping.get(args.a), mapping.get(args.b))
    )
  case and_(args)
    waffle_and(waffle_int_operands(mapping.get(args.a), mapping.get(args.b)))
  case or_(args)
    waffle_or(waffle_int_operands(mapping.get(args.a), mapping.get(args.b)))
  case xor(args)
    waffle_xor(waffle_int_operands(mapping.get(args.a), mapping.get(args.b)))
  | Note: The return byte of the compare_ints waffle expression matches the
  | tag for the Ordering enum (| equal greater less).
  case compare_zero(arg) waffle_compare_zero(mapping.get(arg))
  case struct_(fields) {
    if fields.is_not_empty() then
      panic(
        "Only Nothing is allowed when converting to Waffle; other structs 
        'should be layouted."
      )
    waffle_aggregate(empty_slice[WaffleExpr]())
  }
  case switch_on_byte(switch_) {
    var condition = mapping.get(switch_.condition)
    var cases = list[WaffleBody]()
    for case_ in switch_.cases do {
      var builder = waffle_body_builder().&
      cases.&.push(builder.finish(case_.to_waffle(builder, mapping)))
    }
    waffle_switch(condition, cases.to_slice())
  }
  case call_fun(call) {
    var arg_types = list[EggType]()
    for arg in call.args do arg_types.&.push(arg.type())
    var arg_layout = arg_types.to_slice().memory_layout_args()
    var parts = list[WaffleExpr]()
    for part in arg_layout.parts do
      parts.&.push(
        switch part
        case arg(index) mapping.get(call.args.get(index))
        case padding(amount) waffle_padding(amount)
      )
    waffle_call(
      call.fun_, waffle_aggregate(parts.to_slice()), id.type().memory_layout()
    )
  }
  case fun_ptr(signature) waffle_fun_ptr(signature)
  case call_indirect(call) {
    var arg_types = list[EggType]()
    for arg in call.args do arg_types.&.push(arg.type())
    var arg_layout = arg_types.to_slice().memory_layout_args()
    var parts = list[WaffleExpr]()
    for part in arg_layout.parts do
      parts.&.push(
        switch part
        case arg(index) mapping.get(call.args.get(index))
        case padding(amount) waffle_padding(amount)
      )
    waffle_call_indirect(
      mapping.get(call.fun_ptr),
      waffle_aggregate(parts.to_slice()),
      id.type().memory_layout(),
    )
  }
  case raw_crash(crash) 
    waffle_crash(
      waffle_aggregate(
        list(mapping.get(crash.ptr), mapping.get(crash.len)).to_slice()
      )
    )
  case unreachable waffle_unreachable
  case halt waffle_halt
  case loop_(loop_) {
    var var_types = list[EggType]()
    for var_ in loop_.body.params do var_types.&.push(var_.type())
    var var_layout = var_types.to_slice().memory_layout_args()

    var param = create(waffle_param(var_layout.size, var_layout.alignment))

    var parts = list[WaffleExpr]()
    for part in var_layout.parts do
      parts.&.push(
        switch part
        case arg(index) mapping.get(loop_.initial.get(index))
        case padding(amount) waffle_padding(amount)
      )
    var initial = waffle_aggregate(parts.to_slice())

    var body = {
      for var_ in loop_.body.params.iter().enumerate() do
        mapping.&.put(
          var_.item,
          waffle_part(
            waffle_local(param),
            var_layout.offsets.get(var_.index),
            var_.item.type().memory_layout(),
          ),
        )
      var builder = waffle_body_builder().&
      builder.finish(loop_.body.to_waffle(builder, mapping))
    }

    waffle_loop(param, initial, body)
  }
  case continue_(continue_) {
    var arg_types = list[EggType]()
    for arg in continue_.next do arg_types.&.push(arg.type())
    var next_layout = arg_types.to_slice().memory_layout_args()
    var parts = list[WaffleExpr]()
    for part in next_layout.parts do
      parts.&.push(
        switch part
        case arg(index) mapping.get(continue_.next.get(index))
        case padding(amount) waffle_padding(amount)
      )
    waffle_continue(
      waffle_aggregate(parts.to_slice()), id.type().memory_layout()
    )
  }
  case padding(amount) waffle_padding(amount)
  case aggregate(aggregate) {
    var parts = list[WaffleExpr]()
    for part in aggregate do parts.&.push(mapping.get(part))
    waffle_aggregate(parts.to_slice())
  }
  case part(part)
    waffle_part(
      mapping.get(part.of),
      part.offset,
      part.layout,
    )
  case malloc(size) waffle_malloc(mapping.get(size))
  case null_ptr waffle_int(0)
  case free(free)
    waffle_free(
      waffle_aggregate(
        list(mapping.get(free.ptr), mapping.get(free.size)).to_slice()
      )
    )
  case load_word(load) waffle_load_word(mapping.get(load.ptr))
  case load_byte(load) waffle_load_byte(mapping.get(load.ptr))
  case store_word(store)
    waffle_store_word(
      waffle_aggregate(
        list(mapping.get(store.ptr), mapping.get(store.value)).to_slice()
      )
    )
  case store_byte(store)
    waffle_store_byte(
      waffle_aggregate(
        list(mapping.get(store.ptr), mapping.get(store.value)).to_slice()
      )
    )
  case store_bytes(store)
    waffle_store_bytes(mapping.get(store.ptr), store.bytes)
  default panic({
    var b = string_builder().&
    b."unexpected expression when converting to Waffle:\n"
    b.write(id, namespace().&, no_indentation)
    b.to_string()
  })
}
