| The Plum Compiler  
|
| Welcome to the entry file to the compiler for Plum, a simple, functional, cozy
| programming language.
|
| TODO: comment is out of date; update
|
| Like most compilers, the Plum compiler represents the program as a series of
| compiler stages. Unlike some other compilers, the abstraction gaps between
| these stages are quite small. If you want to do further research, this design
| is sometimes called "microstages". It makes the transformations between
| stages more obvious and simple, but it does require a lot more stages for the
| entire pipeline.
|
| These are the stages of the Plum compiler:
|
| - Code:   Just a string.
| - Bacon:  The lines of the file turned into a tree according to the
|           indentation.
| - Toast:  A parsed representation of the language constructs, suitable for
|           formatting.
| - Egg:    The expressions organized as a graph. Names and functions are
|           resolved.
| - Waffle: Data structures have been memory layouted.
| - Ground: Everything has been compiled into a series of stack-based
|           instructions.
|
| Most of these compiler stages have a corresponding Martinaise file in this
| directory. These also contain a more detailed explanation.

import ../../../martinaise/stdlib.mar
import bytes.mar
import module.mar
import error.mar
import formatting.mar
import dag.mar

import bacon/mod.mar
import toast/mod.mar
import egg/mod.mar
import waffle/mod.mar
import sushi/mod.mar
import ground/mod.mar

import string_to_bacon/mod.mar
import bacon_to_toast/mod.mar
import toast_to_egg/mod.mar
import egg_to_egg/mod.mar
import egg_to_waffle/mod.mar
import waffle_to_waffle/mod.mar
import waffle_to_sushi/mod.mar
import sushi_to_ground/mod.mar

fun main(): Never {
  eprintln("Welcome to the Plum compiler!")

  var args = get_process_args()
  var path = args.get_maybe(1) or exit(1, "You didn't specify a file.\n")
  var ground = module(path).compile("main (Int)") or(error)
    exit(1, "Oh no! An error occurred:\n\n{error}\n")
  write_file("{path}.ground", ground.bytes)

  exit(0)
}

fun exit(status: Int, message: String): Never {
  stderr.write(message)
  exit(status)
}

fun print_compile_step(step: String) { print(step.pad_right(29)) }
fun report_time(duration: Duration) {
  println("{duration.in_milliseconds().to_int().format().pad_left(4)} ms")
}

fun compile(module: Module, function: String): Result[Ground, Error] {
  var total_timer = start_timer()

  | This is compilation pipeline. We start with an input module and parse it
  | into lines nested by indentation (Bacon) and then an abstract syntax tree
  | (Toast). This allows us to inspect the imports and parse those modules as
  | well.

  print_compile_step("Bacon & Toast")
  var timer = start_timer()
  var toasts = map[Module, Toast]()
  module.parse_toasts(toasts.&)?
  report_time(timer.read_duration())

  | Once we've parsed the entry point module and all imported modules, we
  | type-check everything, resolve identifiers, and figure out types for all
  | expressions. This results in the Egg.

  print_compile_step("Egg")
  var timer = start_timer()
  var egg = toasts.to_egg("{module}.{function}")?
  report_time(timer.read_duration())

  | Similar to the MLIR [0] compiler architecture, we don't have a bunch of
  | type-safe compiler stages, as that would require implementing formatting,
  | hashing, and (most importantly) optimizations for a bunch of stages.
  |
  | Instead, the Egg covers all abstraction levels from a "type checked AST" to
  | a "low-level instructions on bytes". Hence, we only ever use a subset of the
  | Egg nodes -- for example, you will not find an Egg than contains both the
  | builtin node as well as the store_word node.
  | This makes the code of our compiler a bit less type-safe, but way more
  | flexible. We can change the order that language features are lowered in and
  | optimizations are reusable across all compiler stages.
  |
  | [0]: https://mlir.llvm.org/

  | Egg nodes:
  |   param, case_param, int, struct, member, enum, switch, inline_lambda,
  |   call_fun, call_builtin, call_lambda, string, type, cast

  | TODO: add call_generic
  | Eliminating call_generic: We specialize generic functions for the concrete
  | types they are used with (also called "monomorphization"). After this, our
  | code only has concrete types.
  var egg = run_egg_pass("generics", egg, Pass.lower_generics)

  | Egg nodes:
  |   param, case_param, int, struct, member, enum, switch, inline_lambda,
  |   call_fun, call_builtin, call_lambda, string, type, cast

  | Eliminate call_builtin: We turn call_builtin nodes into a variety of
  | specialized nodes, one for each builtin.
  var egg = run_egg_passes_until_stable("builtin calls", egg, list(
    Pass.lower_builtin_calls
  ))

  | Egg nodes:
  |   param, case_param, lower_byte, byte_to_int, int, add, subtract, multiply,
  |   divide, modulo, compare, and, or, xor, shift_left, shift_right, struct,
  |   member, enum, switch, inline_lambda, call_fun, call_lambda, string, box,
  |   unbox, generate_array, array_get, array_set, array_slice, array_len, type,
  |   cast, type_info, static_to_dynamic, dynamic_to_static, crash

  | Eliminate cast, type_info, static_to_dynamic, dynamic_to_static: Because all
  | types are concrete, we turn expressions that operate with types into literal
  | expressions or functions that deal with values of the corresponding type.
  | For example, instead of a cast node, we call a function that traverses the
  | old value and builds up a parallel new value of the new type.
  var egg = run_egg_passes_until_stable("casts, type info, dynamics", egg, list(
    Pass.simplify_casts, Pass.lower_casts,
    Pass.lower_type_infos, Pass.lower_dynamics,
  ))

  | Egg nodes:
  |   param, case_param, lower_byte, byte_to_int, int, add, subtract, multiply,
  |   divide, modulo, compare, and, or, xor, shift_left, shift_right, struct,
  |   member, enum, switch, inline_lambda, call_fun, call_lambda, string, box,
  |   unbox, generate_array, array_get, array_set, array_slice, array_len, type,
  |   crash

  | Eliminate inline_lambda: For every inline_lambda, we create a top-level
  | function that accepts an additional closure parameter â€“ a Box of all
  | captured values. The inline_lambda expressions become raw_lambdas.
  var egg = run_egg_pass("lambdas to funs", egg, Pass.lower_lambdas_to_funs)

  | Egg nodes:
  |   param, case_param, lower_byte, byte_to_int, int, add, subtract, multiply,
  |   divide, modulo, compare, and, or, xor, shift_left, shift_right, struct,
  |   member, enum, switch, raw_lambda, call_fun, call_lambda, string, box,
  |   unbox, generate_array, array_get, array_set, array_slice, array_len, type,
  |   crash

  | Optimize: Now that the most tricky parts have been eliminated (we only have
  | concrete types, lambdas are top-level functions), we optimize the code using
  | a set of idempotent passes, applying them over and over until the Egg
  | stabilizes.
  var passes = list(
    Pass.lower_strings,
    Pass.deduplicate,
    Pass.hoist_known_switch_results,
    Pass.inline_functions,
    Pass.simplify_arithmetics,
    Pass.simplify_arrays,
    Pass.simplify_bitwise,
    Pass.simplify_compare_to_enum,
    Pass.unroll_small_arrays,
    Pass.use_enum_flows,
    Pass.factor_out_loop_fixpoints,
    Pass.hoist_out_of_generators,
    Pass.hoist_out_of_loops,
    Pass.sink_continues,
    Pass.tree_shake,
  )
  var egg = run_egg_passes_until_stable("optimize", egg, passes)

  | Egg nodes:
  |   param, case_param, byte, lower_byte, byte_to_int, int, add, subtract,
  |   multiply, divide, modulo, compare, and, or, xor, shift_left, shift_right,
  |   struct, member, enum, switch, raw_lambda, call_fun, call_lambda, box,
  |   unbox, array, generate_array, array_get, array_set, array_slice,
  |   array_len, type, crash, unreachable, halt, loop, continue

  var passes = passes + list(Pass.lower_bounds_checks)
  var egg = run_egg_passes_until_stable("lower bounds checks", egg, passes)
  var passes = passes + list(Pass.lower_divide_and_modulo_checks)
  var egg = run_egg_passes_until_stable("lower div/mod checks", egg, passes)

  | Egg nodes:
  |   param, case_param, byte, lower_byte, byte_to_int, int, add, subtract,
  |   multiply, unchecked_divide, unchecked_modulo, compare, and, or, xor,
  |   shift_left, shift_right, struct, member, enum, switch, raw_lambda,
  |   call_fun, call_lambda, box, unbox, array,
  |   unchecked_generate_non_empty_array, unchecked_array_get,
  |   unchecked_array_set, unchecked_array_slice, array_len, type, crash,
  |   unreachable, halt, loop, continue

  var egg = run_egg_pass("recursive enums", egg, Pass.lower_recursive_enums)
  var egg = run_egg_pass("introduce ownership", egg, Pass.lower_ownership)
  var egg = run_egg_pass("memory layout", egg, Pass.lower_memory_layouts_1)
  var egg = run_egg_passes_until_stable("optimize", egg, passes)

  | Egg nodes:
  |   param, case_param, byte, lower_byte, byte_to_int, int, add, subtract,
  |   multiply, unchecked_divide, unchecked_modulo, compare, and, or, xor,
  |   shift_left, shift_right, struct, member, enum, switch, raw_lambda,
  |   call_fun, call_lambda, crash, unreachable, halt, loop, continue, null_ptr,
  |   object_new, object_load, object_free, get_refcount, set_refcount,
  |   new_buffer, get_buffer_length, load_buffer_item, store_buffer_item,
  |   store_buffer_bytes, free_buffer

  var egg = run_egg_pass("memory layout", egg, Pass.lower_memory_layouts_2)

  var passes = list(
    Pass.deduplicate,
    | Pass.hoist_known_switch_results, | TODO: does this apply?
    Pass.inline_functions,
    Pass.simplify_aggregates_parts_loads_and_stores,
    Pass.simplify_arithmetics,
    Pass.simplify_bitwise,
    Pass.hoist_out_of_loops,
    Pass.make_switches_branchless,
    Pass.sink_continues,
    Pass.tree_shake,
  )
  var egg = run_egg_passes_until_stable("optimize", egg, passes)
  println(egg)

  | Egg nodes:
  |   param, case_param, byte, lower_byte, byte_to_int, int, add, subtract,
  |   multiply, unchecked_divide, unchecked_modulo, compare, and, or, xor,
  |   shift_left, shift_right, call_fun, call_indirect, crash, unreachable,
  |   halt, loop, continue, null_ptr, object_new, object_load, object_free,
  |   get_refcount, set_refcount, new_buffer, get_buffer_length,
  |   load_buffer_item, store_buffer_item, store_buffer_bytes, free_buffer,
  |   padding, aggregate, part, switch_on_byte

  | var passes = passes + list(Pass.lower_objects_and_buffers)
  | var egg = run_egg_passes_until_stable("objects, buffers", egg, passes)
  | println(egg)

  | Egg nodes:
  |   param, case_param, byte, lower_byte, byte_to_int, int, add, subtract,
  |   multiply, unchecked_divide, unchecked_modulo, compare, and, or, xor,
  |   shift_left, shift_right, call_fun, call_indirect, crash, unreachable,
  |   halt, loop, continue, null_ptr, padding, aggregate, part, switch_on_byte,
  |   malloc, load, store, free

  | var passes = passes + list(Pass.lower_loads_and_stores)

  | Egg nodes:
  |   param, case_param, byte, lower_byte, byte_to_int, int, add, subtract,
  |   multiply, unchecked_divide, unchecked_modulo, compare, and, or, xor,
  |   shift_left, shift_right, call_fun, call_indirect, crash, unreachable,
  |   halt, loop, continue, null_ptr, padding, aggregate, part, switch_on_byte,
  |   malloc, load_byte, load_word, store_byte, store_word, free

  | print_compile_step("Waffle")
  | var timer = start_timer()
  | var waffle = egg.to_waffle()
  | report_time(timer.read_duration())
  | if false then println(waffle)

  | print_compile_step("  optimize")
  | var timer = start_timer()
  | var waffle = waffle.optimize()
  | report_time(timer.read_duration())
  | if false then println(waffle)
  | | if false then {
  | |   println("Running Waffle")
  | |   println(waffle.run(5.to_bytes()))
  | | }

  | print_compile_step("Sushi")
  | var timer = start_timer()
  | var sushi = waffle.to_sushi()
  | report_time(timer.read_duration())
  | if false then println(sushi)

  | | TODO: optimize Sushi:
  | | - put cold blocks at the end
  | | - put frequently-used-together blocks near each other
  | | - merge blocks
  | | - peephole optimizations
  | | - tail call elimination

  | print_compile_step("Ground")
  | var timer = start_timer()
  | var ground = sushi.to_ground()
  | report_time(timer.read_duration())
  | if false then println(ground)
  | | if false then {
  | |   println("Running Ground")
  | |   println(ground.run(5.to_bytes()).debug())
  | | }

  print_compile_step("Total")
  report_time(total_timer.read_duration())

  todo("fds")
  | ok[Ground, Error](ground)
}

fun parse_toasts(
  module: Module, out: &Map[Module, Toast]
): Result[Nothing, Error] {
  if out.contains(module) or module.is_builtin() then
    return ok[Nothing, Error]({})

  var content = none[String]()
  for path in module.file_paths() do {
    var bytes = read_file(path) or continue
    content = some(bytes.to_string())
    break
  }
  var content = content or
    return error[Nothing, Error](error(
      "Couldn't read file from {module.file_paths()}", invalid_src
    ))

  var bacon = content.to_bacon(module)
  var toast = bacon.to_toast()?
  out.put(module, toast)

  for def in toast.defs do
    if def is import_(import_) then {
      for part in import_.parts do {
        var imported = module.resolve_import(part.module) or(error)
          return error[Nothing, Error](error(error, import_.keyword.src))
        imported.parse_toasts(out)?
      }
    }
  ok[Nothing, Error]({})
}

fun run_egg_pass(name: String, egg: Egg, pass: Pass): Egg {
  print_compile_step("  {name}")
  var timer = start_timer()
  var egg = egg.apply(pass)
  report_time(timer.read_duration())
  egg
}

fun run_egg_passes_until_stable(
  name: String, egg: Egg, passes: List[Pass]
): Egg {
  print_compile_step("  {name}")
  var timer = start_timer()
  var funs = map[String, EggFun]()
  for signature in egg.choose_optimization_order() do {
    var mapped = egg.funs.get(signature).map(ApplyUntilStable {
      passes = passes.to_slice(), processed_funs = funs.&
    })
    | eprintln("Mapped {pretty_signature(signature)}")
    | stderr.write(signature, mapped)
    | stderr."\n"
    mapped.verify()
    funs.&.put(signature, mapped)
  }
  var egg = Egg { funs, entry_point = egg.entry_point }
  | eprintln("{hash_before} -> {hash_after}")
  | var egg = egg.apply_until_stable(passes.to_slice())
  report_time(timer.read_duration())
  egg
}
