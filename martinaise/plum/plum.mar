| The Plum Compiler  
|
| Welcome to the entry file to the compiler for Plum, a simple, functional, cozy
| programming language.
|
| Like most compilers, the Plum compiler represents the program as a series of
| compiler stages. Unlike some other compilers, the abstraction gaps between
| these stages are quite small. If you want to do further research, this design
| is sometimes called "microstages". It makes the transformations between
| stages more obvious and simple, but it does require a lot more stages for the
| entire pipeline.
|
| These are the stages of the Plum compiler:
|
| TODO: out of date; update
| - Source Code: Just a string.
| - Bacon:       The lines of the file turned into a tree according to the
|                indentation.
| - Toast:       A parsed representation of the language constructs, suitable
|                for formatting.
| - Egg:         The expressions organized as a graph. Names and functions are
|                resolved.
| - Pudding:     Similar to the Yogurt, but with added dup and drop instructions
|                that enable garbage collection.
| - Pesto:       Data structures have been transformed into C-like structs,
|                associated enums, and pointers between them. It's decided what
|                data is allocated on the stack vs. heap and where exist pointer
|                indirections.
| - Waffle:      Data structures have been memory layouted.
| - Ground:      Everything has been compiled into a series of stack-based
|                instructions.
|
| Most of these compiler stages have a corresponding Martinaise file in this
| directory. These also contain a more detailed explanation.

import ../../../martinaise/stdlib.mar
import bytes.mar
import module.mar
import error.mar
import formatting.mar
import dag.mar

import bacon/mod.mar
import toast/mod.mar
import egg/mod.mar
import waffle/mod.mar
import sushi/mod.mar
import ground/mod.mar

import string_to_bacon/mod.mar
import bacon_to_toast/mod.mar
import toast_to_egg/mod.mar
import egg_to_egg/mod.mar
import egg_to_waffle/mod.mar
import waffle_to_waffle/mod.mar
import waffle_to_sushi/mod.mar
import sushi_to_ground/mod.mar

fun main(): Never {
  eprintln("Welcome to the Plum compiler!")

  var args = get_process_args()
  var path = args.get_maybe(1) or exit(1, "You didn't specify a file.\n")
  var ground = module(path).compile("main (Int)") or(error)
    exit(1, "Oh no! An error occurred:\n\n{error}\n")
  write_file("{path}.ground", ground.bytes)

  exit(0)
}

fun exit(status: Int, message: String): Never {
  stderr.write(message)
  exit(status)
}

fun report_time(duration: Duration) {
  println("{duration.in_milliseconds().to_int().format().pad_left(4)} ms")
}

fun print_compile_step(step: String) { print(step.pad_right(27)) }

fun compile(module: Module, function: String): Result[Ground, Error] {
  var total_timer = start_timer()

  print_compile_step("Bacon & Toast")
  var timer = start_timer()
  var toasts = map[Module, Toast]()
  module.parse_toasts(toasts.&)?
  if false then {
    println("Toasts:")
    for toast in toasts do println("{toast.key}:\n{toast.value}")
  }
  report_time(timer.read_duration())

  print_compile_step("Egg")
  var timer = start_timer()
  var egg = toasts.to_egg("{module}.{function}")?
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  specialize builtin calls")
  var timer = start_timer()
  var egg = egg.specialize_builtin_calls()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  monomorphize")
  var timer = start_timer()
  var egg = egg.monomorphize()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  implement casts")
  var timer = start_timer()
  var egg = egg.implement_casts()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  implement type info")
  var timer = start_timer()
  var egg = egg.implement_type_info()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  implement dynamics")
  var timer = start_timer()
  var egg = egg.implement_dynamics()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  turn lambdas into funs")
  var timer = start_timer()
  var egg = egg.turn_lambdas_into_funs()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  optimize")
  var timer = start_timer()
  var egg = egg.optimize()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  check bounds explicitly")
  var timer = start_timer()
  var egg = egg.check_bounds_explicitly()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  optimize")
  var timer = start_timer()
  var egg = egg.optimize()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  check div/mod explicitly")
  var timer = start_timer()
  var egg = egg.check_divide_and_modulo_explicitly()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  optimize")
  var timer = start_timer()
  var egg = egg.optimize()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  introduce ownership")
  var timer = start_timer()
  var egg = egg.introduce_ownership()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  memory-layout high-level")
  var timer = start_timer()
  var egg = egg.memory_layout_high_level()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  memory-layout low-level")
  var timer = start_timer()
  var egg = egg.memory_layout_low_level()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("  optimize")
  var timer = start_timer()
  var egg = egg.optimize()
  report_time(timer.read_duration())
  if false then println(egg)

  print_compile_step("Waffle")
  var timer = start_timer()
  var waffle = egg.to_waffle()
  report_time(timer.read_duration())
  if false then println(waffle)

  print_compile_step("  optimize")
  var timer = start_timer()
  var waffle = waffle.optimize()
  report_time(timer.read_duration())
  if false then println(waffle)
  | if false then {
  |   println("Running Waffle")
  |   println(waffle.run(5.to_bytes()))
  | }

  print_compile_step("Sushi")
  var timer = start_timer()
  var sushi = waffle.to_sushi()
  report_time(timer.read_duration())
  if false then println(sushi)

  | TODO: optimize Sushi:
  | - put cold blocks at the end
  | - put frequently-used-together blocks near each other
  | - merge blocks
  | - peephole optimizations
  | - tail call elimination

  print_compile_step("Ground")
  var timer = start_timer()
  var ground = sushi.to_ground()
  report_time(timer.read_duration())
  if false then println(ground)
  | if false then {
  |   println("Running Ground")
  |   println(ground.run(5.to_bytes()).debug())
  | }

  print_compile_step("Total                ")
  report_time(total_timer.read_duration())

  | todo("fds")
  ok[Ground, Error](ground)
}
fun parse_toasts(
  module: Module, out: &Map[Module, Toast]
): Result[Nothing, Error] {
  if out.contains(module) or module.is_builtin() then
    return ok[Nothing, Error]({})

  var content = none[String]()
  for path in module.file_paths() do {
    var bytes = read_file(path) or continue
    content = some(bytes.to_string())
    break
  }
  var content = content or
    return error[Nothing, Error](error(
      "Couldn't read file from {module.file_paths()}", invalid_src
    ))

  var bacon = content.to_bacon(module)
  var toast = bacon.to_toast()?
  out.put(module, toast)

  for def in toast.defs do
    if def is import_(import_) then {
      for part in import_.parts do {
        var imported = module.resolve_import(part.module) or(error)
          return error[Nothing, Error](error(error, import_.keyword.src))
        imported.parse_toasts(out)?
      }
    }
  ok[Nothing, Error]({})
}
