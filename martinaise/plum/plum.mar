| The Plum Compiler  
|
| Welcome to the entry file to the compiler for Plum, a simple, functional, cozy
| programming language.
|
| TODO: comment is out of date; update
|
| Like most compilers, the Plum compiler represents the program as a series of
| compiler stages. Unlike some other compilers, the abstraction gaps between
| these stages are quite small. If you want to do further research, this design
| is sometimes called "microstages". It makes the transformations between
| stages more obvious and simple, but it does require a lot more stages for the
| entire pipeline.
|
| These are the stages of the Plum compiler:
|
| - Code:   Just a string.
| - Bacon:  The lines of the file turned into a tree according to the
|           indentation.
| - Toast:  A parsed representation of the language constructs, suitable for
|           formatting.
| - Egg:    The expressions organized as a graph. Names and functions are
|           resolved.
| - Waffle: Data structures have been memory layouted.
| - Ground: Everything has been compiled into a series of stack-based
|           instructions.
|
| Most of these compiler stages have a corresponding Martinaise file in this
| directory. These also contain a more detailed explanation.

import ../../../martinaise/stdlib.mar
import bytes.mar
import module.mar
import error.mar
import formatting.mar
import dag.mar

import bacon/mod.mar
import toast/mod.mar
import egg/mod.mar
import waffle/mod.mar
import sushi/mod.mar
import ground/mod.mar

import string_to_bacon/mod.mar
import bacon_to_toast/mod.mar
import toast_to_egg/mod.mar
import egg_to_egg/mod.mar
import egg_to_waffle/mod.mar
import waffle_to_waffle/mod.mar
import waffle_to_sushi/mod.mar
import sushi_to_ground/mod.mar

fun main(): Never {
  eprintln("Welcome to the Plum compiler!")

  var args = get_process_args()
  var path = args.get_maybe(1) or exit(1, "You didn't specify a file.\n")
  var ground = module(path).compile("main (Int)") or(error)
    exit(1, "Oh no! An error occurred:\n\n{error}\n")
  write_file("{path}.ground", ground.bytes)

  exit(0)
}

fun exit(status: Int, message: String): Never {
  stderr.write(message)
  exit(status)
}

fun print_compile_step(step: String) { print(step.pad_right(29)) }
fun report_time(duration: Duration) {
  println("{duration.in_milliseconds().to_int().format().pad_left(4)} ms")
}

fun compile(module: Module, function: String): Result[Ground, Error] {
  var total_timer = start_timer()

  | Parsing the code  
  | This is compilation pipeline. We start with an input module and parse it
  | into lines nested by indentation (Bacon) and then an abstract syntax tree
  | (Toast). This allows us to inspect the imports and parse those modules as
  | well.

  print_compile_step("Bacon & Toast")
  var timer = start_timer()
  var toasts = map[Module, Toast]()
  module.parse_toasts(toasts.&)?
  report_time(timer.read_duration())

  | Type checking  
  | Once we've parsed the entry point module and all imported modules, we
  | type-check everything, resolve identifiers, and figure out types for all
  | expressions. This results in the Egg.

  print_compile_step("Egg")
  var timer = start_timer()
  var egg = toasts.to_egg("{module}.{function}")?
  report_time(timer.read_duration())

  | What is the Egg?  
  | Similar to the MLIR (Multi-Level Intermediate Representation) [0] compiler
  | architecture, we don't have a bunch of type-safe compiler stages, as that
  | would require implementing formatting, hashing, and (most importantly)
  | optimizations for a bunch of stages.
  |
  | Instead, the Egg covers all abstraction levels from a "type checked AST" to
  | a "low-level instructions on bytes". The individual nodes can represent
  | high-level ideas like "generate_array" to low-level ones like "store_word".
  | In one Egg instance, only a subset of all possible nodes is used.
  |
  | Note that we are intentionally pragmatic here: We trade a bit of type-safety
  | (expressing in types which subset of nodes our representation contains) for
  | flexibility: We can re-use the validation, formatting, hashing, and
  | optimizations across multiple abstraction levels and easily change the order
  | that language features are lowered.
  |
  | [0]: https://mlir.llvm.org/
  
  | Terminology note: The lower_* passes eliminate a kind of node from the Egg,
  | replacing it with lower-level concepts. The other passes (simplify_*, etc.)
  | emit code that is on a similar abstraction level as before.

  egg.assert_only(list(
    "param", "case_param", "int", "struct_", "member", "enum_", "switch_",
    "inline_lambda", "call_fun", "call_builtin", "call_lambda", "string",
    "type", "cast",
  ))

  | Monomorphization  
  | TODO: add call_generic
  | We specialize generic functions for the concrete types they are used with
  | (also called "monomorphization"), starting at the program entry point. After
  | this, our Egg contains only the code reachable from main specialized for
  | concrete types.
  var egg = run_egg_pass("generics", egg, Pass.lower_generics)

  egg.assert_only(list(
    "param", "case_param", "int", "struct_", "member", "enum_", "switch_",
    "inline_lambda", "call_fun", "call_builtin", "call_lambda", "string",
    "type", "cast",
  ))

  | Specializing call_builtin  
  | We turn the rather unspecific call_builtin nodes into a variety of
  | specialized nodes, one for each builtin.
  var egg = run_egg_passes_until_stable("builtin calls", egg, list(
    Pass.lower_builtin_calls
  ))

  egg.assert_only(list(
    "param", "case_param", "lower_byte", "byte_to_int", "int", "add",
    "subtract", "multiply", "divide", "modulo", "compare", "and_", "or_", "xor",
    "shift_left", "shift_right", "struct_", "member", "enum_", "switch_",
    "inline_lambda", "call_fun", "call_lambda", "string", "box", "unbox",
    "generate_array", "array_get", "array_set", "array_slice", "array_len",
    "type", "cast", "type_info", "static_to_dynamic", "dynamic_to_static",
    "crash",
  ))

  | Remove first-class types  
  | Because all types are concrete, we turn expressions that operate with types
  | into literal expressions or functions that deal with values of the
  | corresponding type. For example, instead of a cast node, we call a function
  | that traverses the old value and builds up a parallel new value of the new
  | type.
  var egg = run_egg_passes_until_stable("casts, type info, dynamics", egg, list(
    Pass.simplify_casts,
    Pass.lower_casts,
    Pass.lower_type_infos,
    Pass.lower_dynamics,
  ))

  egg.assert_only(list(
    "param", "case_param", "lower_byte", "byte_to_int", "int", "add",
    "subtract", "multiply", "divide", "modulo", "compare", "and_", "or_", "xor",
    "shift_left", "shift_right", "struct_", "member", "enum_", "switch_",
    "inline_lambda", "call_fun", "call_lambda", "string", "box", "unbox",
    "generate_array", "array_get", "array_set", "array_slice", "array_len",
    "type", "crash", "unreachable",
  ))

  | Eliminate inline lambdas  
  | For every inline_lambda, we create a top-level function that accepts an
  | additional parameter â€“ a Box of all captured values, also called a closure.
  | The inline_lambda expressions become raw_lambdas.
  var egg = run_egg_passes_until_stable("lambdas to funs", egg, list(
    Pass.lower_lambdas_to_funs
  ))

  egg.assert_only(list(
    "param", "case_param", "lower_byte", "byte_to_int", "int", "add",
    "subtract", "multiply", "divide", "modulo", "compare", "and_", "or_", "xor",
    "shift_left", "shift_right", "struct_", "member", "enum_", "switch_",
    "raw_lambda", "call_fun", "call_lambda", "string", "box", "unbox",
    "generate_array", "array_get", "array_set", "array_slice", "array_len",
    "type", "crash", "unreachable",
  ))

  | Optimize the code  
  | Now that the most tricky language features (first-class types and lambdas)
  | have been eliminated/simplified, we optimize the code using a set of
  | idempotent passes, applying them over and over until the Egg stabilizes.
  var passes = list(
    Pass.lower_strings,
    Pass.deduplicate,
    Pass.hoist_known_switch_results,
    Pass.inline_functions,
    Pass.simplify_arithmetics,
    Pass.simplify_arrays,
    Pass.simplify_bitwise,
    Pass.simplify_compare_to_enum,
    Pass.unroll_small_arrays,
    Pass.use_enum_flows,
    Pass.factor_out_loop_fixpoints,
    Pass.hoist_out_of_generators,
    Pass.hoist_out_of_loops,
    Pass.sink_continues,
    Pass.tree_shake,
  )
  var egg = run_egg_passes_until_stable("optimize", egg, passes)

  egg.assert_only(list(
    "param", "case_param", "byte", "lower_byte", "byte_to_int", "int", "add",
    "subtract", "multiply", "divide", "modulo", "compare", "and_", "or_", "xor",
    "shift_left", "shift_right", "struct_", "member", "enum_", "switch_",
    "raw_lambda", "call_fun", "call_lambda", "box", "unbox", "array",
    "generate_array", "array_get", "array_set", "array_slice", "array_len",
    "type", "crash", "unreachable", "halt", "loop", "continue_",
  ))

  | Make checks explicit  
  | Some operations (divide, modulo, generate_array, array_get, array_set,
  | array_slice) validate their inputs, for example, to check that you don't
  | divide by zero or that you don't try to generate an array with a negative
  | length. Otherwise, they crash.
  | Because of this, they are not considered pure and some optimizations such as
  | tree shaking or loop hoisting don't apply to them. Here, we desugar these
  | checked expressions into explicit checks followed by unchecked versions of
  | the expressions that can assume that the inputs are valid.
  var passes = passes + list(Pass.lower_bounds_checks)
  var egg = run_egg_passes_until_stable("lower bounds checks", egg, passes)
  var passes = passes + list(Pass.lower_divide_and_modulo_checks)
  var egg = run_egg_passes_until_stable("lower div/mod checks", egg, passes)

  egg.assert_only(list(
    "param", "case_param", "byte", "lower_byte", "byte_to_int", "int", "add",
    "subtract", "multiply", "unchecked_divide", "unchecked_modulo", "compare",
    "and_", "or_", "xor", "shift_left", "shift_right", "struct_", "member",
    "enum_", "switch_", "raw_lambda", "call_fun", "call_lambda", "box", "unbox",
    "array", "unchecked_generate_non_empty_array", "unchecked_array_get",
    "unchecked_array_set", "unchecked_array_slice", "array_len", "type",
    "crash", "unreachable", "halt", "loop", "continue_",
  ))

  | Track ownership  
  | Until now, we assumed that expressions are values that are somehow garbage
  | collected. Now, we make that garbage collection explicit: We decide which
  | parts of values are stored on the heap and where we have pointer
  | indirections. All heap allocations are reference counted, so we also insert
  | code for adjusting the reference count and freeing values when it reaches
  | zero.

  | Recursive enums can't be stored in a single place/allocation: Because their
  | size is possibly infinite, we need pointer indirections and multiple
  | allocations. So first, we wrap recursive variants of enums with Boxes.
  var egg = run_egg_pass(
    "break up recursive enums", egg, Pass.lower_recursive_enums
  )

  | After that, we insert dup and drop expressions into the code. When a value
  | is created, we are responsible for dropping it when it's no longer used. If
  | it is used multiple times, we need to dup it.
  var egg = run_egg_pass("introduce ownership", egg, Pass.lower_ownership)

  | TODO: optimize on the abstraction level of dup/drop

  | Now, we turn expressions into lower-level ones where we already know the
  | pointer indirections:
  | - lambdas are turned into structs of function pointers and closures
  |   containing the captured variables
  | - noxes are turned into objects
  | - arrays are turned into buffers
  | - dup/drop expressions are turned into function calls
  var egg = run_egg_pass("memory layout", egg, Pass.lower_memory_layouts_1)
  var egg = run_egg_passes_until_stable("optimize", egg, passes)
  eprintln(egg)

  egg.assert_only(list(
    "param", "case_param", "byte", "lower_byte", "byte_to_int", "int", "add",
    "subtract", "multiply", "unchecked_divide", "unchecked_modulo", "compare",
    "and_", "or_", "xor", "shift_left", "shift_right", "struct_", "member",
    "enum_", "switch_", "function_ptr", "call_fun", "call_indirect", "crash",
    "unreachable", "halt", "loop", "continue_", "null_ptr", "object_new",
    "object_load", "object_free", "get_refcount", "set_refcount", "new_buffer",
    "get_buffer_length", "load_buffer_item", "store_buffer_item",
    "store_buffer_bytes", "free_buffer",
  ))

  | Memory layout  
  | Now, think of concrete memory layouts for structs and enums. Every
  | expression is now conceptually just a slice of bytes.

  var egg = run_egg_pass("memory layout", egg, Pass.lower_memory_layouts_2)

  var passes = list(
    Pass.deduplicate,
    | Pass.hoist_known_switch_results, | TODO: does this apply?
    Pass.inline_functions,
    Pass.simplify_aggregates_parts_loads_and_stores,
    Pass.simplify_arithmetics,
    Pass.simplify_bitwise,
    Pass.hoist_out_of_loops,
    Pass.make_switches_branchless,
    Pass.sink_continues,
    Pass.tree_shake,
  )
  var egg = run_egg_passes_until_stable("optimize", egg, passes)
  println(egg)

  egg.assert_only(list(
    "param", "case_param", "byte", "lower_byte", "byte_to_int", "int", "add",
    "subtract", "multiply", "unchecked_divide", "unchecked_modulo", "compare",
    "and_", "or_", "xor", "shift_left", "shift_right", "function_ptr",
    "call_fun", "call_indirect", "crash", "unreachable", "halt", "loop",
    "continue_", "null_ptr", "padding", "aggregate", "part", "switch_on_byte",
    "malloc", "load", "store", "free",
  ))

  | var passes = passes + list(Pass.lower_loads_and_stores)

  | Egg nodes:
  |   param, case_param, byte, lower_byte, byte_to_int, int, add, subtract,
  |   multiply, unchecked_divide, unchecked_modulo, compare, and, or, xor,
  |   shift_left, shift_right, call_fun, call_indirect, crash, unreachable,
  |   halt, loop, continue, null_ptr, padding, aggregate, part, switch_on_byte,
  |   malloc, load_byte, load_word, store_byte, store_word, free

  | print_compile_step("Waffle")
  | var timer = start_timer()
  | var waffle = egg.to_waffle()
  | report_time(timer.read_duration())
  | if false then println(waffle)

  | print_compile_step("  optimize")
  | var timer = start_timer()
  | var waffle = waffle.optimize()
  | report_time(timer.read_duration())
  | if false then println(waffle)
  | | if false then {
  | |   println("Running Waffle")
  | |   println(waffle.run(5.to_bytes()))
  | | }

  | print_compile_step("Sushi")
  | var timer = start_timer()
  | var sushi = waffle.to_sushi()
  | report_time(timer.read_duration())
  | if false then println(sushi)

  | | TODO: optimize Sushi:
  | | - put cold blocks at the end
  | | - put frequently-used-together blocks near each other
  | | - merge blocks
  | | - peephole optimizations
  | | - tail call elimination

  | print_compile_step("Ground")
  | var timer = start_timer()
  | var ground = sushi.to_ground()
  | report_time(timer.read_duration())
  | if false then println(ground)
  | | if false then {
  | |   println("Running Ground")
  | |   println(ground.run(5.to_bytes()).debug())
  | | }

  print_compile_step("Total")
  report_time(total_timer.read_duration())

  todo("fds")
  | ok[Ground, Error](ground)
}

fun parse_toasts(
  module: Module, out: &Map[Module, Toast]
): Result[Nothing, Error] {
  if out.contains(module) or module.is_builtin() then
    return ok[Nothing, Error]({})

  var content = none[String]()
  for path in module.file_paths() do {
    var bytes = read_file(path) or continue
    content = some(bytes.to_string())
    break
  }
  var content = content or
    return error[Nothing, Error](error(
      "Couldn't read file from {module.file_paths()}", invalid_src
    ))

  var bacon = content.to_bacon(module)
  var toast = bacon.to_toast()?
  out.put(module, toast)

  for def in toast.defs do
    if def is import_(import_) then {
      for part in import_.parts do {
        var imported = module.resolve_import(part.module) or(error)
          return error[Nothing, Error](error(error, import_.keyword.src))
        imported.parse_toasts(out)?
      }
    }
  ok[Nothing, Error]({})
}

fun run_egg_pass(name: String, egg: Egg, pass: Pass): Egg {
  print_compile_step("  {name}")
  var timer = start_timer()
  var egg = egg.apply(pass)
  report_time(timer.read_duration())
  egg
}

fun run_egg_passes_until_stable(
  name: String, egg: Egg, passes: List[Pass]
): Egg {
  print_compile_step("  {name}")
  var timer = start_timer()
  var funs = map[String, EggFun]()
  for signature in egg.choose_optimization_order() do {
    var mapped = egg.funs.get(signature).map(ApplyUntilStable {
      passes = passes.to_slice(), processed_funs = funs.&
    })
    | eprintln("Mapped {pretty_signature(signature)}")
    | stderr.write(signature, mapped)
    | stderr."\n"
    mapped.verify()
    funs.&.put(signature, mapped)
  }
  var egg = Egg { funs, entry_point = egg.entry_point }
  | eprintln("{hash_before} -> {hash_after}")
  | var egg = egg.apply_until_stable(passes.to_slice())
  report_time(timer.read_duration())
  egg
}
