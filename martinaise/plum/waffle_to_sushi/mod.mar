import ../plum.mar
import builder.mar

fun to_sushi(waffle: Waffle): Sushi {
  var builder = sushi_builder().&

  var fun_builders = map[String, SushiSectionBuilder]()
  for fun_ in waffle.funs do
    fun_builders.&.put(fun_.key, builder.section(fun_.key))

  var fun_sections = map[String, SectionIndex]()
  for entry in fun_builders do fun_sections.&.put(entry.key, entry.value.index)

  for fun_ in waffle.funs do {
    fun_.value.compile(fun_builders.get(fun_.key), fun_sections)
  }

  builder.finish(fun_sections.get(waffle.entry_point))
}

fun compile(
  fun_: WaffleFun, builder: SushiSectionBuilder, funs: Map[String, SectionIndex]
) {
  var builder = SushiFlowBuilder {
    section = builder, stack = stack_model(0)
  }.&

  builder.mark(fun_.param)
  var param_size = fun_.param.resolve().param.unwrap().size
  builder.stack_size_changed(param_size)

  fun_.body.compile(builder, funs, none[OngoingLoop]())

  if builder.stack is not_diverged then {
    builder.pop_below_top(fun_.body.returns.size(), param_size)
    builder.return_()
  }
  builder.finish()
}

struct OngoingLoop {
  stack_size_at_body_start: Int, param_size: Int, section: SectionIndex
}

fun compile(
  body: WaffleBody, builder: &SushiFlowBuilder, funs: Map[String, SectionIndex],
  surrounding_loop: Maybe[OngoingLoop],
) {
  var stack_size_at_body_start = builder.stack.not_diverged.unwrap().size

  for local in body.locals do {
    | if builder.has_diverged then return {}
    var expr = local.resolve()
    builder.align_to(expr.alignment())
    builder.mark(local)
    expr.compile(builder, funs, surrounding_loop)
    if builder.stack is not_diverged(stack) then {
      var expected_size = stack.mapping.get(local) + expr.size()
      if stack.size != expected_size then
        panic("wrong stack size:
          ' expected {stack.mapping.get(local)} + {expr.size()}, is {stack.size}")
    } else
      panic("diverging expression is not last of body")
  }

  | if builder.has_diverged then return {}
  builder.align_to(body.returns.alignment())
  var locals_size =
    builder.stack.not_diverged.unwrap().size - stack_size_at_body_start
  body.returns.compile(builder, funs, surrounding_loop)

  if builder.stack is not_diverged then
    builder.pop_below_top(body.returns.size(), locals_size)
}

| Compiles an expression. Assumes that the stack is already aligned for the
| expression.
fun compile(
  expr: WaffleExpr, builder: &SushiFlowBuilder, funs: Map[String, SectionIndex],
  surrounding_loop: Maybe[OngoingLoop],
) {
  {
    var stack_size = builder.stack.not_diverged.unwrap().size
    if not(stack_size.is_multiple_of(expr.alignment())) then
      panic("stack not aligned for expr (stack size is {stack_size})")
  }

  switch expr
  case param unreachable()
  case padding(amount) builder.push_padding(amount)
  case byte(byte) builder.push_1(byte)
  case int(int) builder.push_8(int)
  case local(local) builder.copy_from_stack(local, expr.size())
  case aggregate(aggregate) {
    for field in aggregate.iter().enumerate() do
      field.item.compile(builder, funs, surrounding_loop)
  }
  case part(part) {
    | Quite often, you see things like @0.0:8 in the Waffle â€“ for example, if
    | we have an aggregate representing the arguments of a function and we want
    | to get a single argument, we extract that argument.
    | Lowering this in a naive way (first lowering @0, then lowering the part
    | access) leads to crazy amounts of copying: We copy the entire local
    | aggregate to the top of the stack, just to then discard the majority to
    | extract the field we want.
    | So, here, we special-case that pattern.
    if part.of.* is local(local) then {
      builder.copy_from_stack(
        builder.stack.not_diverged.unwrap().mapping.get(local) + part.offset,
        expr.size(),
      )
    } else {
      var padding = builder.align_to(part.of.alignment())
      part.of.compile(builder, funs, surrounding_loop)
      var amount_before_part = padding + part.offset
      var amount_after_part  = part.of.size() - expr.size() - part.offset
      builder.pop(amount_after_part)
      builder.pop_below_top(expr.size(), amount_before_part)
    }
  }
  case switch_(switch_) {
    switch_.condition.compile(builder, funs, surrounding_loop)

    var case_builders = builder.jump_table(switch_.cases.len)
    var after_switch_builder = builder.split("after switch")

    for i in 0..switch_.cases.len do {
      var case_ = switch_.cases.get(i)
      var builder = case_builders.get(i)
      case_.compile(builder.&, funs, surrounding_loop)
      if builder.stack is not_diverged then
        builder.&.jump(after_switch_builder.section.index)
      case_builders.&.set(i, builder)
      builder.finish()
    }

    after_switch_builder.&.join(case_builders)
    builder.finish()
    builder.* = after_switch_builder
  }
  case call(call) {
    var padding = builder.align_to(call.args.alignment())
    call.args.compile(builder, funs, surrounding_loop)
    builder.call(funs.get(call.function), 0 - call.args.size() + expr.size())
    builder.pop_below_top(expr.size(), padding)
  }
  case call_indirect(call) {
    var padding = builder.align_to(call.fun_and_args.alignment())
    call.fun_and_args.compile(builder, funs, surrounding_loop)
    var fun_stack_diff = 0
      - call.fun_and_args.size() | as well as the arguments
      + expr.size()               | and pushes its result
    builder.call_indirect(0.lower_byte(), fun_stack_diff)
    builder.pop_below_top(expr.size(), padding)
  }
  case function_ptr(signature) builder.push_indirect(funs.get(signature))
  case add(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.add_8()
  }
  case subtract(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.sub_8()
  }
  case multiply(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.signed_mul_8()
  }
  case divide(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.signed_div_8()
  }
  case modulo(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.signed_mod_8()
  }
  case compare_zero(arg) {
    var padding = builder.align_to(8)
    arg.compile(builder, funs, surrounding_loop)
    builder.compare_zero_8()
    builder.pop_below_top(1, padding)
  }
  case and_(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.and_8()
  }
  case or_(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.or_8()
  }
  case xor(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.xor_8()
  }
  case shift_left(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.shift_left_8()
  }
  case shift_right(args) {
    args.compile(builder, funs, surrounding_loop)
    builder.shift_right_8()
  }
  case lower_byte(arg) {
    var padding = builder.align_to(8)
    arg.compile(builder, funs, surrounding_loop)
    builder.lower_byte()
    builder.pop_below_top(1, padding)
  }
  case byte_to_int(arg) {
    arg.compile(builder, funs, surrounding_loop)
    builder.byte_to_int()
  }
  case malloc(size) {
    size.compile(builder, funs, surrounding_loop)
    builder.malloc_8_aligned()
  }
  case free(free) {
    var padding = builder.align_to(8)
    free.compile(builder, funs, surrounding_loop) | aggregate of pointer and size
    builder.free_8_aligned()
    builder.pop_below_top(8, padding)
  }
  case load_word(ptr) {
    var padding = builder.align_to(8)
    ptr.compile(builder, funs, surrounding_loop)
    builder.load_8()
    builder.pop_below_top(8, padding)
  }
  case load_byte(ptr) {
    var padding = builder.align_to(8)
    ptr.compile(builder, funs, surrounding_loop)
    builder.load_1()
    builder.pop_below_top(1, padding)
  }
  case store_word(args) {
    var padding = builder.align_to(8)
    args.compile(builder, funs, surrounding_loop) | ptr and value
    builder.store_8()
    builder.pop_below_top(0, padding)
  }
  case store_byte(args) {
    var padding = builder.align_to(8)
    args.compile(builder, funs, surrounding_loop) | ptr and value
    builder.store_1()
    builder.pop_below_top(0, padding)
  }
  case store_bytes(store) {
    var padding_before_ptr = builder.align_to(8)
    store.ptr.compile(builder, funs, surrounding_loop)
    builder.store_bytes(store.bytes)
    builder.pop(padding_before_ptr)
  }
  case crash(message) {
    message.compile(builder, funs, surrounding_loop)
    builder.crash()
  }
  case unreachable {
    builder.unreachable()
  }
  case halt {
    builder.halt()
  }
  case loop_(loop_) {
    builder.mark(loop_.param)
    loop_.initial.compile(builder, funs, surrounding_loop)
    var body = builder.split("loop").&
    var stack_size_at_body_start = body.stack.not_diverged.unwrap().size
    builder.jump(body.section.index)
    builder.finish()
    loop_.body.compile(
      body,
      funs,
      some(OngoingLoop {
        stack_size_at_body_start,
        param_size = loop_.param.resolve().param.unwrap().size,
        section = body.section.index,
      }),
    )
    var after_body = builder.split("after loop").&
    body.jump(after_body.section.index)
    body.finish()
    after_body.join(body.*)
    after_body.pop_below_top(loop_.body.returns.size(), loop_.initial.size())
    builder.* = after_body.*
  }
  case continue_(continue_) {
    continue_.next.compile(builder, funs, surrounding_loop)
    var loop_ = surrounding_loop.unwrap()
    builder.pop_below_top(
      loop_.param_size,
      builder.stack.not_diverged.unwrap().size - loop_.stack_size_at_body_start,
    )
    builder.jump(loop_.section)
    builder.finish()
    builder.stack = StackModel.diverged
  }
}
