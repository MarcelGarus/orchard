import mod.mar

var exported_funs_cache =
  map[Tuple3[String, Slice[FunArg], Module], Maybe[MatchingCallee]]()
    .put_on_heap()

fun lookup_exported_fun(
  name: String, args: Slice[FunArg],
  module: Module, toasts: Map[Module, Toasty],
): Result[Maybe[MatchingCallee], Error] {
  var cache_key = tuple(name, args, module)
  if exported_funs_cache.get_maybe(cache_key) is some(result) then
    return ok[Maybe[MatchingCallee], Error](result)
  var result =
    lookup_exported_fun(name, args, module, toasts, list[Module]().&)?
  exported_funs_cache.put(cache_key, result)
  ok[Maybe[MatchingCallee], Error](result)
}

fun lookup_fun(
  name: String, args: Slice[FunArg],
  module: Module, toasts: Map[Module, Toasty], src: Src,
): Result[MatchingCallee, Error] {
  lookup_fun(name, args, module, toasts, src, list(module).&)
}

struct MatchingCallee {
  kind: MatchingCalleeKind,
  substitutions: Substitutions,
  param_types: Slice[EggType],
  return_type: EggType,
}
enum MatchingCalleeKind { builtin: EggBuiltinFun, fun_: String }

fun ==(a: MatchingCallee, b: MatchingCallee): Bool {
  a.kind == b.kind
    and a.substitutions == b.substitutions
    and a.param_types == b.param_types
    and a.return_type == b.return_type
}
fun ==(a: MatchingCalleeKind, b: MatchingCalleeKind): Bool {
  switch a
  case builtin(a) if b is builtin(b) then a == b else false
  case fun_(a)    if b is fun_(b)    then a == b else false
}

fun hash[H](hasher: H, callee: MatchingCallee) {
  hasher.hash(callee.substitutions)
  hasher.hash(callee.param_types)
  hasher.hash(callee.return_type)
}

fun write[W](writer: W, kind: MatchingCalleeKind) {
  switch kind
  case builtin(builtin) writer.write(builtin)
  case fun_(signature) writer.write(signature)
}

struct FunParam { name: String, type: EggType }

fun param(name: String, type: EggType): FunParam { FunParam { name, type } }

fun write[W](writer: W, param: FunParam) {
  if param.type == type_type then
    writer."{param.name}:{param.type}"
  else
    writer."{param.type}"
}

| Invariant: Arguments that have the type Type also have a compile-time-known
| value.
struct FunArg { value: Maybe[EggType], type: EggType }

fun ==(a: FunArg, b: FunArg): Bool { a.value == b.value and a.type == b.type }
fun hash[H](hasher: H, arg: FunArg) {
  hasher.hash(arg.value)
  hasher.hash(arg.type)
}
fun write[W](writer: W, arg: FunArg) {
  if arg.value is some(type) then writer."{type}:"
  writer."{arg.type}"
}

fun lookup_exported_fun(
  name: String,
  args: Slice[FunArg],
  module: Module,
  toasts: Map[Module, Toasty],
  stack: &List[Module],
): Result[Maybe[MatchingCallee], Error] {
  var cache_key = tuple(name, args, module)
  if exported_funs_cache.get_maybe(cache_key) is some(result) then
    return ok[Maybe[MatchingCallee], Error](result)

  if module == builtin_module then {
    for fun_ in builtin_funs do {
      if fun_.format() == name then {
        var params = fun_.type_signature().params
        var substitutions = args.match_against(params) or(message) {
          return error[Maybe[MatchingCallee], Error](
            error(message, invalid_src)
          )
        }
        var substitutions = substitutions or continue

        var param_types = list[EggType]()
        for param in params do
          param_types.&.push(param.type.specialize(substitutions))
        var param_types = param_types.to_slice()
        var return_type =
          fun_.type_signature().return_type.specialize(substitutions)

        return ok[Maybe[MatchingCallee], Error](some(MatchingCallee {
          kind = MatchingCalleeKind.builtin(fun_),
          substitutions,
          param_types,
          return_type,
        }))
      }
    }
    return ok[Maybe[MatchingCallee], Error](none[MatchingCallee]())
  }
  for fun_ in toasts.get(module).exported_funs do
    if fun_.name.string == name then {
      var params = list[FunParam]()
      for param in fun_.args.iter().&.enumerate() do
        params.&.push(FunParam {
          name = param.item.name.string,
          type = param.item.type.compile(module, toasts)?,
        })
      var params = params.to_slice()

      switch args.match_against(params)
      case ok(substitutions) {
        switch substitutions
        case none continue
        case some {
          var result = some(
            lookup_fun(name, args, module, toasts, fun_.name.src, stack)?
          )
          exported_funs_cache.put(cache_key, result)
          return ok[Maybe[MatchingCallee], Error](result)
        }
      }
      case error(message)
        return error[Maybe[MatchingCallee], Error](error(
          message, fun_.name.src
        ))
    }
  ok[Maybe[MatchingCallee], Error](none[MatchingCallee]())
}

fun signature(module: Module, name: String, params: Slice[FunParam]): String {
  var b = string_builder().&
  b."{module}.{name}"
  for param in params do
    if param.type == type_type then
      b." {param.name}: {param.type}"
    else
      b." {param.type}"
  b.to_string()
}

fun match_against(
  args: Slice[FunArg],
  params: Slice[FunParam],
  constraints: &TypeVariableConstraints,
): Bool {
  args.len == params.len or return false
  for both in zip(args.iter(), params.iter()) do {
    var arg = both.a
    var param = both.b
    arg.type.match_against(param.type, constraints) or return false
    if arg.type == type_type then {
      var result = arg.value.unwrap().match_against(
        type_variable(param.name), constraints
      )
      if not(result) then unreachable()
    }
  }
  true
}

fun match_against(
  args: Slice[FunArg], params: Slice[FunParam]
): Result[Maybe[Substitutions], String] {
  var constraints = constraints()
  args.match_against(params, constraints.&) or
    return ok[Maybe[Substitutions], String](none[Substitutions]())
  var substitutions = constraints.check_coherency() or
    return ok[Maybe[Substitutions], String](none[Substitutions]())

  | Make sure that all type variables are constrained.
  var type_vars = set[String]()
  for param in params do param.type.collect_type_variables(type_vars.&)
  var all_constrained = true
  for var_ in type_vars do
    if not(substitutions.substitutions.contains(var_)) then
      all_constrained = false
  all_constrained or
    return error[Maybe[Substitutions], String]({
      var b = string_builder().&
      b."Function with args"
      for param in params do b." {param.name}: {param.type}"
      b." matches, but not all type
        'variables are constrained:"
      for var_ in type_vars do {
        b."\n  {var_} "
        switch substitutions.substitutions.get_maybe(var_)
        case some(type) b."= {type}"
        case none b."is unconstrained"
      }
      b.to_string()
    })

  ok[Maybe[Substitutions], String](some(substitutions))
}

fun lookup_fun(
  name: String,
  args: Slice[FunArg],
  module: Module,
  toasts: Map[Module, Toasty],
  src: Src,
  stack: &List[Module],
): Result[MatchingCallee, Error] {
  if module == builtin_module then {
    unreachable()
    | for builtin in builtin_funs do {
    |   if "{builtin}" == name then {
    |     var params = builtin.type_signature().params
    |     var substitutions = args.match_against(params) or(message) {
    |       return error[MatchingCallee, Error](error(message, src))
    |     }
    |     var substitutions = substitutions or continue

    |     var param_types = list[EggType]()
    |     for param in params do
    |       param_types.&.push(param.type.specialize(substitutions))
    |     var param_types = param_types.to_slice()
    |     var return_type =
    |       builtin.type_signature().return_type.specialize(substitutions)

    |     return ok[MatchingCallee, Error](MatchingCallee {
    |       kind = MatchingCalleeKind.builtin(builtin),
    |       substitutions,
    |       param_types,
    |       return_type,
    |     })
    |   }
    | }
    | return error[MatchingCallee, Error](error("Unknown builtin function.", src))
  }

  var matches = set[MatchingCallee]()
  var toast = toasts.get(module)
  for fun_ in toast.funs do {
    fun_.name.string == name or continue

    var params = list[FunParam]()
    for param in fun_.params do
      params.&.push(FunParam {
        name = param.name.string, type = param.type.compile(module, toasts)?
      })
    var params = params.to_slice()

    var signature = signature(module, fun_.name.string, params)

    var substitutions = args.match_against(params) or(message)
      return error[MatchingCallee, Error](error(message, src))
    var substitutions = substitutions or continue

    var param_types = list[EggType]()
    for param in params do
      param_types.&.push(param.type.specialize(substitutions))
    var param_types = param_types.to_slice()
    var return_type =
      fun_.return_type.compile(module, toasts)?.specialize(substitutions)

    matches.&.put(MatchingCallee {
      kind = MatchingCalleeKind.fun_(signature),
      substitutions,
      param_types,
      return_type,
    })
  }
  for imported in toast.imports do {
    if stack.iter().&.contains(imported) then continue
    stack.push(imported)
    if lookup_exported_fun(name, args, imported, toasts, stack)?
    is some(fun_)
    then matches.&.put(fun_)
    stack.pop()
  }

  if matches.is_empty() then
    return error[MatchingCallee, Error]({
      var b = string_builder().&
      b."No function matches this signature:\n
        '  {name}"
      for arg in args do b." {arg}"
      var name_matches = lookup_named_funs(name, module, toasts)?
      if name_matches.is_empty() then {
        b."\nIn fact, there are no functions with that name in scope."
      } else {
        b."\nFor these functions, the types don't match:"
        for name_match in name_matches do {
          b."\n  {name_match.name}"
          for param in name_match.params do b." {param}"
          b."  doesn't match"
        }
      }
      error(b.to_string(), src)
    })

  if matches.map.size > 1 then
    return error[MatchingCallee, Error]({
      var b = string_builder().&
      b."Your code contains this call:\n
        '  {name}"
      for arg in args do b." {arg}"
      b."\nThis matches {matches.map.size} functions:"
      for match in matches do {
        b."\n  {match.kind}"
        for param in match.param_types do b." {param}"
        b." -> {match.return_type}"
        if match.substitutions.substitutions.is_not_empty() then
          b." with {match.substitutions}"
      }
      error(b.to_string(), src)
    })

  ok[MatchingCallee, Error](matches.iter().&.next().unwrap())
}
