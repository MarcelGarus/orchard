| Looking up Types and Functions

import mod.mar

fun lookup_exported_type(
  name: String, num_args: Int,
  module: Module, toasts: Map[Module, Toast],
): Result[Maybe[ToastTypeDef], Error] {
  lookup_exported_type(name, num_args, module, toasts, list[Module]().&)
}
fun lookup_type(
  name: String, num_args: Int,
  module: Module, toasts: Map[Module, Toast], src: Src,
): Result[ToastTypeDef, Error] {
  lookup_type(name, num_args, module, toasts, src, list[Module]().&)
}
fun lookup_exported_fun(
  name: String, args: Slice[FunArg],
  module: Module, toasts: Map[Module, Toast],
): Result[Maybe[MatchingCallee], Error] {
  lookup_exported_fun(name, args, module, toasts, list[Module]().&)
}
fun lookup_fun(
  name: String, args: Slice[FunArg],
  module: Module, toasts: Map[Module, Toast], src: Src,
): Result[MatchingCallee, Error] {
  lookup_fun(name, args, module, toasts, src, list[Module]().&)
}

fun lookup_exported_type(
  name: String,
  num_args: Int,
  module: Module,
  toasts: Map[Module, Toast],
  stack: &List[Module],
): Result[Maybe[ToastTypeDef], Error] {
  if module == builtin_module then {
    for type in builtin_types do
      if type.name == name and type.args == num_args then
        return ok[Maybe[ToastTypeDef], Error](some(ToastTypeDef {
          name = name @ invalid_src,
          params = {
            var params = list[StringAndSrc]()
            for arg in 0..num_args do params.&.push("{arg}" @ invalid_src)
            params.to_slice()
          },
          type = ToastType.primitive(ToastTypePrimitive {
            name,
            args = {
              var the_args = list[ToastType]()
              for arg in 0..num_args do
                the_args.&.push(ToastType.variable("{arg}" @ invalid_src))
              the_args.to_slice()
            },
          })
        }))
    return ok[Maybe[ToastTypeDef], Error](none[ToastTypeDef]())
  }
  for def in toasts.get(module).defs do
    if def is export(export) then
      for item in export.items do
        if item is type(type) then
          if type.name.string == name and type.args.len == num_args then
            return ok[Maybe[ToastTypeDef], Error](some(
              lookup_type(
                type.name.string, num_args, module, toasts, type.name.src, stack
              )?
            ))
  ok[Maybe[ToastTypeDef], Error](none[ToastTypeDef]())
}

fun lookup_type(
  name: String,
  num_args: Int,
  module: Module,
  toasts: Map[Module, Toast],
  src: Src,
  stack: &List[Module],
): Result[ToastTypeDef, Error] {
  if module == builtin_module then {
    | The lookup_exported_type function already resolves the type defs from the
    | builtin module instead of using this function. As there is also no code
    | inside the builtin module that could depend on internal types, this should
    | never be reached.
    unreachable()
  }

  var candidates = list[ToastTypeDef]()
  for def in toasts.get(module).defs do
    switch def
    case type(type) {
      | TODO: check if name matches
      if type.name.string == name and type.params.len == num_args then
        candidates.&.push(type)
    }
    case import_(import_) {
      for imported in import_.modules do {
        var imported = module.resolve_import(imported)?
        if stack.iter().&.contains(imported) then continue
        stack.push(imported)
        if lookup_exported_type(name, num_args, imported, toasts, stack)?
        is some(exported)
        then candidates.&.push(exported)
        stack.pop()
      }
    }
    default {}
  if candidates.is_empty() then
    return error[ToastTypeDef, Error](error(
      "Type {name} with {num_args} args does not exist in {module}.", src
    ))
  if candidates.len > 1 then
    return error[ToastTypeDef, Error](error({
      var b = string_builder().&
      b."Multiple types named {name} with {num_args} args exist in {module}:"
      for candidate in candidates do
        b."\n - {candidate.debug()}"
      b.to_string()
    }, src))
  ok[ToastTypeDef, Error](candidates.get(0))
}

struct MatchingCallee {
  kind: MatchingCalleeKind,
  substitutions: Substitutions,
  param_types: Slice[EggType],
  return_type: EggType,
}
enum MatchingCalleeKind { builtin: EggBuiltinFun, fun_: String }
fun write[W](writer: W, kind: MatchingCalleeKind) {
  switch kind
  case builtin(builtin) writer.write(builtin)
  case fun_(signature) writer.write(signature)
}

struct FunParam { name: String, type: EggType }

| Invariant: Arguments that have the type Type also have a compile-time-known
| value.
struct FunArg { value: Maybe[EggType], type: EggType }

fun write[W](writer: W, arg: FunArg) {
  if arg.value is some(type) then writer."{type}:"
  writer."{arg.type}"
}

fun lookup_exported_fun(
  name: String,
  args: Slice[FunArg],
  module: Module,
  toasts: Map[Module, Toast],
  stack: &List[Module],
): Result[Maybe[MatchingCallee], Error] {
if module == builtin_module then {
    todo("support looking up exported builtin funs")
  }
  for def in toasts.get(module).defs do
    if def is export(export) then
      for item in export.items do
        if item is fun_(fun_) then
          if fun_.name.string == name then {
            todo("Todo: Type-check whether function matches")
            | return ok[Maybe[MatchingCallee], Error](some(type))
          }
  ok[Maybe[MatchingCallee], Error](none[MatchingCallee]())
}

fun signature(module: Module, name: String, params: Slice[FunParam]): String {
  var b = string_builder().&
  b."{module}.{name}"
  for param in params do
    if param.type == type_type then
      b." {param.name}: {param.type}"
    else
      b." {param.type}"
  b.to_string()
}

fun match_against(
  args: Slice[FunArg],
  params: Slice[FunParam],
  constraints: &TypeVariableConstraints,
): Bool {
  args.len == params.len or return false
  for both in zip(args.iter(), params.iter()) do {
    var arg = both.a
    var param = both.b
    arg.type.match_against(param.type, constraints) or return false
    if arg.type == type_type then {
      var result = arg.value.unwrap().match_against(
        type_variable(param.name), constraints
      )
      if not(result) then unreachable()
    }
  }
  true
}

fun match_against(
  args: Slice[FunArg], params: Slice[FunParam]
): Result[Maybe[Substitutions], String] {
  var constraints = constraints()
  args.match_against(params, constraints.&) or
    return ok[Maybe[Substitutions], String](none[Substitutions]())
  var substitutions = constraints.check_coherency() or
    return ok[Maybe[Substitutions], String](none[Substitutions]())

  | Make sure that all type variables are constrained.
  var type_vars = set[String]()
  for param in params do param.type.collect_type_variables(type_vars.&)
  var all_constrained = true
  for var_ in type_vars do
    if not(substitutions.substitutions.contains(var_)) then
      all_constrained = false
  all_constrained or
    return error[Maybe[Substitutions], String]({
      var b = string_builder().&
      b."Function with args"
      for param in params do b." {param.name}: {param.type}"
      b." matches, but not all type
        'variables are constrained:"
      for var_ in type_vars do {
        b."\n  {var_} "
        switch substitutions.substitutions.get_maybe(var_)
        case some(type) b."= {type}"
        case none b."is unconstrained"
      }
      b.to_string()
    })

  ok[Maybe[Substitutions], String](some(substitutions))
}

fun lookup_fun(
  name: String,
  args: Slice[FunArg],
  module: Module,
  toasts: Map[Module, Toast],
  src: Src,
  stack: &List[Module],
): Result[MatchingCallee, Error] {
  if module == builtin_module then {
    for builtin in builtin_funs do {
      if "{builtin}" == name then {
        var params = list[FunParam]()
        for param in builtin.type_signature().params.iter().&.enumerate() do
          params.&.push(FunParam {
            name = "arg_{param.index}", type = param.item
          })
        var params = params.to_slice()
        var substitutions = args.match_against(params) or(message) {
          return error[MatchingCallee, Error](error(message, src))
        }
        var substitutions = substitutions or continue

        var param_types = list[EggType]()
        for param in params do
          param_types.&.push(param.type.specialize(substitutions))
        var param_types = param_types.to_slice()
        var return_type =
          builtin.type_signature().return_type.specialize(substitutions)

        return ok[MatchingCallee, Error](MatchingCallee {
          kind = MatchingCalleeKind.builtin(builtin),
          substitutions,
          param_types,
          return_type,
        })
      }
    }
    return error[MatchingCallee, Error](error("Unknown builtin function.", src))
  }

  var matches = list[MatchingCallee]()
  for def in toasts.get(module).defs do
    switch def
    case fun_(fun_) {
      fun_.name.string == name or continue

      var params = list[FunParam]()
      for param in fun_.params do
        params.&.push(FunParam {
          name = param.name.string, type = param.type.compile(module, toasts)?
        })
      var params = params.to_slice()

      var signature = signature(module, fun_.name.string, params)

      var substitutions = args.match_against(params) or(message) {
        return error[MatchingCallee, Error](error(message, src))
      }
      var substitutions = substitutions or continue

      var param_types = list[EggType]()
      for param in params do
        param_types.&.push(param.type.specialize(substitutions))
      var param_types = param_types.to_slice()
      var return_type =
        fun_.return_type.compile(module, toasts)?.specialize(substitutions)

      matches.&.push(MatchingCallee {
        kind = MatchingCalleeKind.fun_(signature),
        substitutions,
        param_types,
        return_type,
      })
    }
    case import_(import_) {
      for imported in import_.modules do {
        var imported = module.resolve_import(imported)?
        if lookup_exported_fun(name, args, module, toasts)? is some(fun_) then
          matches.&.push(fun_)
      }
    }
    default {}

  if matches.is_empty() then
    return error[MatchingCallee, Error]({
      var b = string_builder().&
      b."There is no matching function.\n
        '  {"{name}".pad_left(30)}"
      for arg in args do
        if arg.type == type_type then
            b." {arg.value}: {arg.type}"
          else
            b." {arg.type}"
      | for item in name_matches do {
      |   var module_name_params =
      |     switch item
      |     case local_fun(fun_) {
      |       var params = list[FunParam]()
      |       for param in fun_.params do
      |         params.&.push(FunParam {
      |           name = param.name.string,
      |           type = param.type.compile(module, types)?,
      |         })
      |       tuple(module, name, params.to_slice())
      |     }
      |     case imported_fun(imported)
      |       tuple(imported.module, imported.name.string, imported.params)

      |   var module = module_name_params.a
      |   var name = module_name_params.b
      |   var params = module_name_params.c

      |   b."\n  {"{module}.{name}".pad_left(30)}"
      |   for param in params do
      |     if param.type == type_type then
      |       b." {param.name}: {param.type}"
      |     else
      |       b." {param.type}"
      |   var constraints = constraints()
      |   args.match_against(params, constraints.&) or {
      |     b."  doesn't match types"
      |     continue
      |   }
      |   var substitutions = constraints.check_coherency() or {
      |     b."  has impossible constraints:"
      |     for constraint in constraints.constraints do
      |       b." {constraint}"
      |     continue
      |   }
      | }
      error(b.to_string(), src)
    })

  if matches.len > 1 then
    return error[MatchingCallee, Error]({
      var b = string_builder().&
      b."Multiple functions match {name} {args}:"
      for match in matches do
        b."\n  {match.kind} with {match.substitutions}"
      error(b.to_string(), src)
    })

  var matching_callee = matches.get(0)

  ok[MatchingCallee, Error](matching_callee)
}
