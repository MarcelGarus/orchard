import mod.mar

fun lookup_exported_type(
  name: String, num_args: Int,
  module: Module, toasts: Map[Module, Toast],
): Result[Maybe[ToastTypeDef], Error] {
  lookup_exported_type(name, num_args, module, toasts, list[Module]().&)
}

fun lookup_type(
  name: String, num_args: Int,
  module: Module, toasts: Map[Module, Toast], src: Src,
): Result[ToastTypeDef, Error] {
  lookup_type(name, num_args, module, toasts, src, list[Module]().&)
}

fun lookup_exported_type(
  name: String,
  num_args: Int,
  module: Module,
  toasts: Map[Module, Toast],
  stack: &List[Module],
): Result[Maybe[ToastTypeDef], Error] {
  if module == builtin_module then {
    for type in builtin_types do
      if type.name == name and type.args == num_args then
        return ok[Maybe[ToastTypeDef], Error](some(ToastTypeDef {
          name = name @ invalid_src,
          params = {
            var params = list[StringAndSrc]()
            for arg in 0..num_args do params.&.push("{arg}" @ invalid_src)
            params.to_slice()
          },
          type = ToastType.primitive(ToastTypePrimitive {
            name,
            args = {
              var the_args = list[ToastType]()
              for arg in 0..num_args do
                the_args.&.push(ToastType.variable("{arg}" @ invalid_src))
              the_args.to_slice()
            },
          })
        }))
    return ok[Maybe[ToastTypeDef], Error](none[ToastTypeDef]())
  }
  for def in toasts.get(module).defs do
    if def is export(export) then
      for item in export.items do
        if item is type(type) then
          if type.name.string == name and type.args.len == num_args then
            return ok[Maybe[ToastTypeDef], Error](some(
              lookup_type(
                type.name.string, num_args, module, toasts, type.name.src, stack
              )?
            ))
  ok[Maybe[ToastTypeDef], Error](none[ToastTypeDef]())
}

fun lookup_type(
  name: String,
  num_args: Int,
  module: Module,
  toasts: Map[Module, Toast],
  src: Src,
  stack: &List[Module],
): Result[ToastTypeDef, Error] {
  if module == builtin_module then {
    | The lookup_exported_type function already resolves the type defs from the
    | builtin module instead of using this function. As there is also no code
    | inside the builtin module that could depend on internal types, this should
    | never be reached.
    unreachable()
  }

  var candidates = set[ToastTypeDef]()
  for def in toasts.get(module).defs do
    switch def
    case type(type) {
      if type.name.string == name and type.params.len == num_args then
        candidates.&.put(type)
    }
    case import_(import_) {
      for imported in import_.modules do {
        var imported = module.resolve_import(imported)?
        if stack.iter().&.contains(imported) then continue
        stack.push(imported)
        if lookup_exported_type(name, num_args, imported, toasts, stack)?
        is some(exported)
        then candidates.&.put(exported)
        stack.pop()
      }
    }
    default {}

  if candidates.is_empty() then
    return error[ToastTypeDef, Error](error(
      "Type {name} with {num_args} args does not exist in {module}.", src
    ))
  if candidates.map.size > 1 then
    return error[ToastTypeDef, Error](error({
      var b = string_builder().&
      b."Multiple types named {name} with {num_args} args exist here:"
      for candidate in candidates do
        b."\n - {candidate.debug()}"
      b.to_string()
    }, src))

  ok[ToastTypeDef, Error](candidates.iter().&.next().unwrap())
}
