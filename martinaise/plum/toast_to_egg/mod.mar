| Converting Toast To Egg

import ../plum.mar
import lookup.mar
import types/mod.mar
import visible.mar

fun to_egg(
  toasts: Map[Module, Toast], entry_module: Module, entry_fun: String
): Result[Egg, Error] {
  var funs = map[String, EggFun]()
  for toast in toasts do {
    var module = toast.key
    var toast = toast.value
    for def in toast.defs do
      switch def
      case import_(import_) check(import_)
      case export(export) check(export, module, toasts)?
      case type(type) check(type, module, toasts)?
      case fun_(fun_) funs.&.put(compile(fun_, module, toasts)?)
  }
  ok[Egg, Error](Egg { entry_point = "{entry_module}.{entry_fun}", funs })
}

fun check(import_: ToastImport) {
  | We don't actually need to do anything. During the creation of the
  | Map[Module, Toast], we have already looked at all the imports and parsed
  | the respective imported files, crashing with a compiler error if a file was
  | not found.
}

fun check(
  export: ToastExport, module: Module, toasts: Map[Module, Toast]
): Result[Nothing, Error] {
  | TODO: Check that the exported items actually exist.
  for item in export.items do
    switch item
    case type(type)
      lookup_type(
        type.name.string, type.args.len, module, toasts, type.name.src
      )?.ignore()
    case fun_(fun_) eprintln("TODO: Ensure that {fun_.name.string} exists in {module}")
  ok[Nothing, Error]({})
}

fun check(
  type_def: ToastTypeDef, module: Module, toasts: Map[Module, Toast]
): Result[Nothing, Error] {
  | TODO: check that the same type var doesn't appear twice
  var env = map[String, EggType]()
  for param in type_def.params do
    env.&.put(param.string, type_variable(param.string))
  type_def.type.compile(env, module, toasts)?
  ok[Nothing, Error]({})
}

| fun compile(
|   type: ToastType, module: Module, toasts: Map[Module, Toast]
| ): Result[EggType, Error] {
|   ok[ToastType, Error](
|     switch type
|     case primitive(primitive) {
|       var args = list[ToastType]()
|       for arg in primitive.args do args.&.push(arg.specialize(env)?)
|       var args = args.to_slice()
      
|       ToastType.primitive(ToastTypePrimitive { name = primitive.name, args })
|     }
|     case variable(variable)
|       env.get_maybe(variable.string) or
|         return error[ToastType, Error](error(
|           "Tried to use {variable.string}, but that type doesn't exist. (speci.)",
|           variable.src
|         ))
|     case call(call) {
|       var args = list[ToastType]()
|       for arg in call.args do args.&.push(arg.specialize(env)?)
|       var args = args.to_slice()
|       ToastType.call(ToastTypeCall { name = call.name, args })
|     }
|     case struct_(struct_) {
|       var fields = list[ToastTypeField]()
|       for field in struct_ do
|         fields.&.push(ToastTypeField {
|           name = field.name, type = field.type.specialize(env)?
|         })
|       var fields = fields.to_slice()
|       ToastType.struct_(fields)
|     }
|     case enum_(enum_) {
|       var variants = list[ToastTypeVariant]()
|       for variant in enum_ do
|         variants.&.push(ToastTypeVariant {
|           name = variant.name, type = variant.type.specialize(env)?
|         })
|       var variants = variants.to_slice()
|       ToastType.enum_(variants)
|     }
|     case lambda(lambda) {
|       var args = list[ToastType]()
|       for arg in lambda.args do args.&.push(arg.specialize(env)?)
|       var args = args.to_slice()
|       var return_type = lambda.return_type.specialize(env)?
|       ToastType.lambda(ToastTypeLambda {
|         args, return_type = return_type.put_on_heap()
|       })
|     }
|   )
| }

struct OngoingTypeCall { name: String, args: Slice[EggType], depth: Int }

fun write[W](writer: W, call: OngoingTypeCall) {
  writer."{call.name}"
  for arg in call.args do writer." {arg}"
}

fun compile(
  type: ToastType,
  env: Map[String, EggType],
  module: Module,
  toasts: Map[Module, Toast],
): Result[EggType, Error] {
  type.compile(env, module, toasts, list[OngoingTypeCall]().&, 0)
}

fun compile(
  type: ToastType,
  env: Map[String, EggType],
  module: Module,
  toasts: Map[Module, Toast],
  stack: &List[OngoingTypeCall],
  depth: Int,
): Result[EggType, Error] {
  return ok[EggType, Error](
    switch type
    case primitive(primitive) {
      var name = primitive.name
      if name == "Never" then type_never
      else if name == "Type"  then type_type
      else if name == "Byte"  then type_byte
      else if name == "Int"   then type_int
      else if name == "Box" then
        type_box_without_canonicalizing(
          primitive.args.get(0).compile(env, module, toasts, stack, depth + 1)?
        )
      else if name == "Array" then
        type_array_without_canonicalizing(
          primitive.args.get(0).compile(env, module, toasts, stack, depth + 1)?
        )
      else unreachable()
    }
    case variable(variable) type_variable(variable.string)
    case call(call) {
      var name = call.name

      var args = list[EggType]()
      for arg in call.args do
        args.&.push(arg.compile(env, module, toasts, stack, depth))
      var args = args.to_slice()

      | Are we recursively lowering a type? If so, we need to insert a recursive
      | type instead of endlessly digging down into the type.
      for parent in stack do
        if parent.name == name.string and parent.args == args then
          return ok[EggType, Error](type_recursive(depth - parent.depth))

      | Look for a type with the name.
      var called_def = lookup_type(
        name.string, args.len, module, toasts, name.src
      )?
      called_def.params.len == args.len or panic("bad lookup")

      var env = map[String, EggType]()
      for arg in zip(called_def.params.iter(), args.iter()) do
        env.&.put(arg.a.string, arg.b)
      var called = called_def.type.specialize(env)?

      stack.&.push(OngoingTypeCall { name = name.string, args, depth })
      var type = called.compile(env, module, toasts, stack, depth)?
      stack.&.pop()

      type
    }
    case struct_(struct_) {
      var fields = map[String, EggType]()
      for field in struct_ do {
        if fields.contains(field.name.string) then
          return error[EggType, Error](error(
            "Struct contains multiple fields named {field.name.string}.",
            field.name.src,
          ))
        fields.&.put(
          field.name.string, field.type.compile(stack, depth + 1, defs)?
        )
      }
      type_struct_without_canonicalizing(fields)
    }
    case enum_(enum_) {
      var variants = map[String, EggType]()
      for variant in enum_ do {
        if variants.contains(variant.name.string) then
          return error[EggType, Error](error(
            "Enum contains multiple variants named {variant.name.string}.",
            variant.name.src,
          ))
        variants.&.put(
          variant.name.string,
          variant.type.compile(stack, depth + 1, defs)?
        )
      }
      type_enum_without_canonicalizing(variants)
    }
    case lambda(lambda) {
      var args = list[EggType]()
      for arg in lambda.args do
        args.&.push(arg.compile(stack, depth + 1, defs)?)
      var args = args.to_slice()

      var return_type =
        lambda.return_type.compile(stack, depth + 1, defs)?

      type_lambda_without_canonicalizing(args, return_type)
    }
  )
}

fun specialize(
  type: ToastType, env: Map[String, ToastType]
): Result[ToastType, Error] {
  var type =
    switch type
    case primitive(primitive) {
      var args = list[ToastType]()
      for arg in primitive.args do args.&.push(arg.specialize(env)?)
      var args = args.to_slice()
      ToastType.primitive(ToastTypePrimitive { name = primitive.name, args })
    }
    case variable(variable)
      env.get_maybe(variable.string) or
        return error[ToastType, Error](error(
          "Tried to use {variable.string}, but that type doesn't exist in the
          ' specializations.",
          variable.src
        ))
    case call(call) {
      var args = list[ToastType]()
      for arg in call.args do args.&.push(arg.specialize(env)?)
      var args = args.to_slice()
      ToastType.call(ToastTypeCall { name = call.name, args })
    }
    case struct_(struct_) {
      var fields = list[ToastTypeField]()
      for field in struct_ do
        fields.&.push(ToastTypeField {
          name = field.name, type = field.type.specialize(env)?
        })
      var fields = fields.to_slice()
      ToastType.struct_(fields)
    }
    case enum_(enum_) {
      var variants = list[ToastTypeVariant]()
      for variant in enum_ do
        variants.&.push(ToastTypeVariant {
          name = variant.name, type = variant.type.specialize(env)?
        })
      var variants = variants.to_slice()
      ToastType.enum_(variants)
    }
    case lambda(lambda) {
      var args = list[ToastType]()
      for arg in lambda.args do args.&.push(arg.specialize(env)?)
      var args = args.to_slice()
      var return_type = lambda.return_type.specialize(env)?
      ToastType.lambda(ToastTypeLambda {
        args, return_type = return_type.put_on_heap()
      })
    }
  ok[ToastType, Error](type)
}

fun compile(
  fun_: ToastFun, module: Module, toasts: Map[Module, Toast]
): Result[EggFun, Error] {
  var params = list[FunParam]()
  for param in fun_.params do
    params.&.push(FunParam {
      name = param.name.string, type = param.type.compile(module, toasts)?
    })
  var params = params.to_slice()
  var signature = signature(module, fun_.name.string, params)

  var visible = visible()
  var builder = egg_body_builder().&

  var param_types = list[EggType]()
  for param in fun_.params do {
    var type = param.type.compile(module, toasts)?
    visible.&.define(param.name.string, builder.param(type))
    param_types.&.push(type)
  }
  var param_types = param_types.to_slice()

  | Push the type variables into the body.
  for var_ in param_types.collect_type_variables() do
    visible.&.define(var_, builder.type(type_variable(var_)))
  for param in fun_.params do
    if param.type.compile(module, toasts)? == type_type then
      visible.&.define(
        param.name.string, builder.type(type_variable(param.name.string))
      )

  var returned = fun_.body.compile(builder, module, visible.&, toasts)?
  | TODO: What's up with this?
  | var last = none[EggId]()
  | for expr in fun_.body.body.unwrap() do
  |   last = some(builder.push(
  |     expr.compile(builder, module, visible.&, toasts)?
  |   ))
  | var returned = last.unwrap()

  var return_type = fun_.return_type.compile(module, toasts)?
  returned.type().is_assignable_to(return_type) or
    return error[EggFun, Error](error(
      "Function returns something different than its claimed return type:\n
      'Claimed: {return_type}\n
      'Actual:  {returned.type()}",
      fun_.name.src,
    ))
  var returned = builder.cast(returned, return_type)

  var body = builder.finish(returned)

  ok[EggFun, Error](EggFun { signature, body })
}

fun compile(
  expr: ToastExpr,
  builder: &EggBodyBuilder,
  module: Module,
  visible: &Visible,
  toasts: Map[Module, Toast],
): Result[EggId, Error] {
  ok[EggId, Error](
    switch expr
    case todo builder.crash(builder.string("todo"), type_never)
    case int(int) builder.int(int.int)
    case string(string) builder.string(string.string)
    case type(type) builder.type(type.compile(module, toasts)?)
    case struct_(struct_)
      builder.struct_({
        var fields = map[String, EggId]()
        var names = set[String]()
        for field in struct_.fields do {
          var name = field.name.string
          var value = field.value.compile(builder, module, visible, toasts)?
          if names.contains(name) then
            return error[EggId, Error](error(
              "Field {name} is in the struct multiple times.",
              struct_.ampersand.src,
            ))
          fields.&.put(name, value)
          names.&.put(name)
        }
        fields
      })
    case enum_(enum_) {
      var name = enum_.name.string
      var value = enum_.value.compile(builder, module, visible, toasts)?
      builder.enum_(type_enum(map(name -> value.type())), name, value)
    }
    case switch_(switch_) {
      | Compile the condition.
      var condition = switch_.condition.compile(builder, module, visible, toasts)?
      var variant_types = condition.type().plum().enum_
        or return error[EggId, Error](error(
          "Switched on non-enum: {condition.type()}", switch_.percent.src
        ))

      | Make sure that no variant is handled twice, that all variants are
      | handled, and that no extra variants are handled.
      var handled_variants = set[String]()
      for case_ in switch_.cases do {
        if handled_variants.contains(case_.symbol.string) then
          return error[EggId, Error](error(
            "{case_.symbol.string} is handled multiple times.",
            switch_.percent.src,
          ))
        handled_variants.&.put(case_.symbol.string)
      }
      for variant in variant_types do
        if not(handled_variants.contains(variant.key)) then
          return error[EggId, Error](error(
            "{variant.key} is not handled.", switch_.percent.src
          ))
      for variant in handled_variants do
        if not(variant_types.contains(variant)) then
          return error[EggId, Error](error(
            "Handling non-existent variant {variant}.", switch_.percent.src
          ))

      | Compile the individual cases.
      var case_compilers = map[String, Tuple2[EggBodyBuilder, EggId]]()
      var case_types = list[EggType]()
      for case_ in switch_.cases do {
        var symbol = case_.symbol.string
        var snapshot = visible.snapshot()
        var case_builder = egg_body_builder().&
        var payload = case_builder.case_param(condition, symbol)
        if case_.payload is some(pattern) then
          pattern.compile_pattern(
            payload, case_builder, module, visible, toasts
          )?

        var returns = case_.body.compile(
          case_builder, module, visible, toasts
        )?
        visible.restore(snapshot)
        case_compilers.&.put(symbol, tuple(case_builder.*, returns))
        case_types.&.push(returns.type())
      }
      var common_type = union(case_types.to_slice()) or
        return error[EggId, Error](error(
          "Couldn't union toasts {case_types}", switch_.percent.src
        ))
      var common_type = common_type
      var cases = map[String, EggBody]()
      for compiler in case_compilers do {
        var symbol = compiler.key
        var returns = compiler.value.b
        var compiler = compiler.value.a
        var actual_return = compiler.&.cast(returns, common_type)
        cases.&.put(symbol, compiler.finish(actual_return))
      }

      builder.switch_(condition, cases)
    }
    case name(name)
      visible.lookup(name.string) or
        return error[EggId, Error](error(
          "Unknown referenced name {name.string}.", name.src
        ))
    case lambda(lambda) {
      var snapshot = visible.snapshot()
      var lambda_builder = egg_body_builder().&
      for param in lambda.params do {
        var name = param.name.string
        var type = param.type.compile(module, toasts)?
        visible.define(name, lambda_builder.param(type))
      }
      var returns = lambda.body.compile(
        lambda_builder, module, visible, toasts
      )?
      var lambda_body = lambda_builder.finish(returns)
      visible.restore(snapshot)

      builder.inline_lambda(lambda_body)
    }
    case call(call) {
      var args = list[EggId]()
      for arg in call.args do
        args.&.push(arg.compile(builder, module, visible, toasts)?)
      var args = args.to_slice()

      | Find the function name -- either some(String) if it's a function call
      | or none if it's a lambda call.
      var function_name =
        switch call.function.*
        case name(name) {
          | Check if the call is actually a struct access.
          if args.len == 1 then
            if args.get(0).type().plum_not_extended() is struct_(fields) then
              if fields.contains(name.string) then
                return ok[EggId, Error](
                  builder.member(args.get(0), name.string)
                )

          switch visible.lookup(name.string)
          case some none[StringAndSrc]()
          case none some(name)
        }
        default none[StringAndSrc]()

      switch function_name
      case some(name) { | top-level function
        | Resolve arguments of the type Type.
        var arg_values = list[FunArg]()
        for i in 0..args.len do {
          var arg = args.get(i)
          arg_values.&.push(
            if arg.type() == type_type then {
              var type_value =
                arg.resolve().type
                  or return error[EggId, Error](error(
                    "Arguments of the type Type have to be known at
                    'compile-time. Arg is {args.get(i).debug()}",
                    name.src
                  ))
              FunArg { value = some(type_value), type = type_type }
            } else
              FunArg { value = none[EggType](), type = arg.type() }
          )
        }
        var arg_values = arg_values.to_slice()

        | Look for a matching function.
        var match = lookup_fun(
          name.string, arg_values, module, toasts, name.src
        )?

        | Cast arguments
        var cast_args = list[EggId]()
        for both in zip(args.iter(), match.param_types.iter()) do
          cast_args.&.push(builder.cast(both.a, both.b))
        var args = cast_args.to_slice()

        | Call the function.
        switch match.kind
        case fun_(signature)
          builder.call(signature, match.substitutions, args, match.return_type)
        case builtin(builtin) builder.call(builtin, match.substitutions, args)
      }
      case none { | lambda
        var lambda = call.function.compile(builder, module, visible, toasts)?
        var lambda_type = lambda.type()
        var lambda_type = lambda_type.plum().lambda or
          return error[EggId, Error](error(
            "Tried to call non-lambda: {lambda_type}", call.function.src()
          ))

        | Cast arguments
        if args.len != lambda_type.args.len then
          return error[EggId, Error](error({
            var b = string_builder().&
            b."
              'Tried to call a lambda with the wrong number of arguments.\n
              '  lambda needs {lambda_type.args.len} arguments:"
            for param in lambda_type.args do b." {param}"
            b."\n
              '   called with {args.len} arguments:"
            for arg in args do b." {arg.type()}"
            b.to_string()
          }, call.function.src()))
        var cast_args = list[EggId]()
        for both in zip(args.iter(), lambda_type.args.iter()) do {
          var arg = both.a
          var expected_type = both.b
          arg.type().is_assignable_to(expected_type) or
            return error[EggId, Error](error(
              "Tried to call lambda with wrong toasts.", call.function.src()
            ))
          cast_args.&.push(builder.cast(arg, expected_type))
        }
        var args = cast_args.to_slice()

        builder.call(lambda, args)
      }
    }
    case var_(var_) {
      var value = var_.right.compile(builder, module, visible, toasts)?
      var_.left.compile_pattern(value, builder, module, visible, toasts)?
      value
    }
    case body(exprs) {
      var last = none[EggId]()
      for expr in exprs do {
        last = some(expr.compile(builder, module, visible, toasts)?)
      }
      last or unreachable()
    }
  )
}

fun compile_pattern(
  pattern: ToastExpr,
  matched: EggId,
  builder: &EggBodyBuilder,
  module: Module,
  visible: &Visible,
  toasts: Map[Module, Toast],
): Result[Nothing, Error] {
  switch pattern
  case todo error[Nothing, Error](error("Todo in pattern.", pattern.src()))
  case int
    error[Nothing, Error](error(
      "Int literals can't be in patterns.", pattern.src()
    ))
  case string
    error[Nothing, Error](error(
      "String literals can't be in patterns.", pattern.src()
    ))
  case type
    error[Nothing, Error](error(
      "Type literals can't be in patterns.", pattern.src()
    ))
  case struct_(pattern) {
    var field_types = matched.type().plum().struct_ or
      return error[Nothing, Error](error(
        "Tried to use a struct pattern to match on {matched.type()}.",
        pattern.ampersand.src,
      ))

    for field in pattern.fields do
      field_types.contains(field.name.string) or
        return error[Nothing, Error](error(
          "Patterns refers to {field.name.string}, but that is not in the
          'struct {matched.type()}.",
          field.name.src,
        ))
    var matched_fields = set[String]()
    for field in pattern.fields do matched_fields.&.put(field.name.string)
    for field in field_types do
      matched_fields.contains(field.key) or
        return error[Nothing, Error](error(
          "Pattern does not bind field {field.key} of {matched.type()}.",
          pattern.ampersand.src,
        ))

    for field in pattern.fields do {
      var field_type = field_types.get(field.name.string)
      var matched_value = builder.member(matched, field.name.string)
      field.value.compile_pattern(
        matched_value, builder, module, visible, toasts
      )?
    }

    ok[Nothing, Error]({})
  }
  case enum_
    error[Nothing, Error](error("Enums can't be in patterns.", pattern.src()))
  case switch_ unreachable()
  case name(name) {
    visible.define(name.string, matched)
    ok[Nothing, Error]({})
  }
  case lambda
    error[Nothing, Error](error("Lambdas can't be in patterns.", pattern.src()))
  case call
    error[Nothing, Error](error("Calls can't be in patterns.", pattern.src()))
  case var_
    error[Nothing, Error](error(
      "Variable declarations can't be in patterns.", pattern.src()
    ))
  case body
    error[Nothing, Error](error("Bodies can't be in patterns.", pattern.src()))
}
