import mod.mar

fun lookup_exported_named_funs(
  name: String, module: Module, toasts: Map[Module, Toast]
): Result[Slice[MatchingName], Error] {
  lookup_exported_named_funs(name, module, toasts, list[Module]().&)
}

fun lookup_named_funs(
  name: String, module: Module, toasts: Map[Module, Toast]
): Result[Slice[MatchingName], Error] {
  lookup_named_funs(name, module, toasts, list[Module]().&)
}

struct MatchingName { name: String, params: Slice[FunParam] }

fun lookup_exported_named_funs(
  name: String,
  module: Module,
  toasts: Map[Module, Toast],
  stack: &List[Module],
): Result[Slice[MatchingName], Error] {
  if module == builtin_module then {
    for fun_ in builtin_funs do {
      if fun_.format() == name then {
        return ok[Slice[MatchingName], Error](list(
          MatchingName { name, params = fun_.type_signature().params }
        ).to_slice())
      }
    }
    return ok[Slice[MatchingName], Error](empty_slice[MatchingName]())
  }
  var matches = list[MatchingName]()
  for def in toasts.get(module).defs do
    if def is export(export) then {
      for item in export.items do
        if item is fun_(fun_) then
          if fun_.name.string == name then {
            var params = list[FunParam]()
            for param in fun_.args.iter().&.enumerate() do
              params.&.push(FunParam {
                name = param.item.name.string,
                type = param.item.type.compile(module, toasts)?,
              })
            matches.&.push(MatchingName { name, params = params.to_slice() })
          }
    }
  ok[Slice[MatchingName], Error](matches.to_slice())
}

fun lookup_named_funs(
  name: String,
  module: Module,
  toasts: Map[Module, Toast],
  stack: &List[Module],
): Result[Slice[MatchingName], Error] {
  if module == builtin_module then unreachable()

  var matches = list[MatchingName]()
  for def in toasts.get(module).defs do
    switch def
    case fun_(fun_) {
      fun_.name.string == name or continue
      var params = list[FunParam]()
      for param in fun_.params do
        params.&.push(FunParam {
          name = param.name.string, type = param.type.compile(module, toasts)?
        })
      matches.&.push(MatchingName { name, params = params.to_slice() })
    }
    case import_(import_) {
      for imported in import_.modules do {
        var imported = module.resolve_import(imported)?
        for match
        in lookup_exported_named_funs(name, imported, toasts, stack)?
        do matches.&.push(match)
      }
    }
    default {}

  ok[Slice[MatchingName], Error](matches.to_slice())
}
