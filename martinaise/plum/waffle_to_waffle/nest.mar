import mod.mar

fun must_have_been_used(used: Bool): Result[Nothing, Nothing] {
  if used then ok[Nothing, Nothing]({}) else error[Nothing, Nothing]({})
}

| Tries to nest the local inside the expression. If an impure expression happens
| before the previous local is used (such as a call, store, etc.), then we
| cannot nest the previous local directly in here because that would change the
| order of impure expressions. In that case, this function returns none.
fun try_nest_local(
  expr: WaffleExpr, local: WaffleId, used: &Bool
): Result[WaffleExpr, Nothing] {
  ok[WaffleExpr, Nothing](
    switch expr
    case param unreachable()
    case padding expr
    case local(id) {
      if id == local then {
        used.* = true
        id.resolve()
      } else
        waffle_local(id)
    }
    case byte(byte) waffle_byte(byte)
    case lower_byte(arg) waffle_lower_byte(arg.try_nest_local(local, used)?)
    case byte_to_int(arg) waffle_byte_to_int(arg.try_nest_local(local, used)?)
    case int(int) waffle_int(int)
    case add(args) waffle_add(args.try_nest_local(local, used)?)
    case subtract(args) waffle_subtract(args.try_nest_local(local, used)?)
    case multiply(args) waffle_multiply(args.try_nest_local(local, used)?)
    case divide(args) waffle_divide(args.try_nest_local(local, used)?)
    case modulo(args) waffle_modulo(args.try_nest_local(local, used)?)
    case and_(args) waffle_and(args.try_nest_local(local, used)?)
    case or_(args) waffle_or(args.try_nest_local(local, used)?)
    case xor(args) waffle_xor(args.try_nest_local(local, used)?)
    case shift_left(args) waffle_shift_left(args.try_nest_local(local, used)?)
    case shift_right(args) waffle_shift_right(args.try_nest_local(local, used)?)
    case compare_zero(arg) waffle_compare_zero(arg.try_nest_local(local, used)?)
    case aggregate(aggregate) {
      var parts = list[WaffleExpr]()
      for part in aggregate do
        parts.&.push(part.try_nest_local(local, used)?)
      waffle_aggregate(parts.to_slice())
    }
    case part(part)
      waffle_part(
        part.of.try_nest_local(local, used)?, part.offset, part.layout
      )
    case switch_(switch_) {
      var condition = switch_.condition.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_switch(condition, switch_.cases)
    }
    case call(call) {
      var args = call.args.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_call(call.function, args, call.layout)
    }
    case call_indirect(call) {
      var fun_and_args = call.fun_and_args.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_call_indirect(fun_and_args, call.layout)
    }
    case fun_ptr(signature) waffle_fun_ptr(signature)
    case malloc(size) waffle_malloc(size.try_nest_local(local, used)?)
    case free(free) {
      var free = free.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_free(free)
    }
    case load_word(ptr) {
      var ptr = ptr.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_load_word(ptr)
    }
    case load_byte(ptr) {
      var ptr = ptr.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_load_byte(ptr)
    }
    case store_word(store) {
      var store = store.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_store_word(store)
    }
    case store_byte(store) {
      var store = store.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_store_byte(store)
    }
    case store_bytes(store) {
      var ptr = store.ptr.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_store_bytes(ptr, store.bytes)
    }
    case crash(args) {
      var args = args.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_crash(args)
    }
    case unreachable {
      used.must_have_been_used()?
      waffle_unreachable
    }
    case halt {
      used.must_have_been_used()?
      waffle_halt
    }
    case loop_(loop_) {
      var initial = loop_.initial.try_nest_local(local, used)?
      used.must_have_been_used()?
      waffle_loop(loop_.param, initial, loop_.body.*)
    }
    case continue_(continue_)
      waffle_continue(
        continue_.next.try_nest_local(local, used)?, continue_.layout
      )
  )
}

fun try_nest_local(
  expr: WaffleExpr, previous: WaffleId
): Result[WaffleExpr, Nothing] {
  var used = false
  var new_version = expr.try_nest_local(previous, used.&)?
  used.must_have_been_used()?
  ok[WaffleExpr, Nothing](new_version)
}

| If (pure or unpure) locals are defined and then immediately used without an
| impure expression in between, we move them.
fun nest_locals(body: WaffleBody): WaffleBody {
  var num_references = body.count_references()

  var locals = list[WaffleId]()
  for local in body.locals do {
    locals.&.push(local)
    | Repeatedly try to merge the last two locals.
    loop {
      if locals.len < 2 then break
      var current = locals.last()
      var previous = locals.get(locals.len - 2)
      if {num_references.get_maybe(previous) or 0} == 1 then
        if current.resolve().try_nest_local(previous)
        is ok(current_containing_previous)
        then {
          update(current, current_containing_previous)
          locals.&.pop() | pop current
          locals.&.pop() | pop previous
          locals.&.push(current) | push current containing previous
          continue
        }
      break
    }
  }

  var returns = body.returns
  loop {
    if locals.last_maybe() is some(previous) then
      if {num_references.get_maybe(previous) or 0} == 1 then
        if returns.try_nest_local(previous) is ok(return_containing_previous)
        then {
          locals.&.pop().ignore()
          returns = return_containing_previous
          continue
        }
    break
  }

  WaffleBody { locals = locals.to_slice(), returns }
}
