| Optimizing the Waffle  

import ../plum.mar
import is_cheap.mar
import is_pure.mar
import tree_shake.mar
import nest.mar

fun optimize(waffle: Waffle): Waffle {
  var funs = map[String, WaffleFun]()
  for fun_ in waffle.funs do funs.&.put(fun_.key, fun_.value.optimize())
  Waffle { entry_point = waffle.entry_point, funs }
}

fun optimize(fun_: WaffleFun): WaffleFun {
  var mapping = map[WaffleId, WaffleId]()
  var body = fun_.body.optimize().nest_locals()
  WaffleFun { param = fun_.param, body }
}

fun optimize(body: WaffleBody): WaffleBody {
  | Optimize the expression in-place (they keep their IDs).
  for local in body.locals do
    update(local, local.resolve().optimize())
  var body = WaffleBody {
    locals = body.locals, returns = body.returns.optimize()
  }

  var body = body.tree_shake()
  | var body = body.nest_locals()
  body
}

| Optimizes the expression. This function assumes that all expressions that this
| expressions depends on are already optimized.
fun optimize(expr: WaffleExpr): WaffleExpr {
  switch expr
  case local(id) {
    var referenced = id.resolve()
    if referenced.is_cheap() then return referenced
    | if referenced.size() == 0 then
    |   return waffle_aggregate(empty_slice[WaffleExpr]())
    expr
  }
  case lower_byte(arg) waffle_lower_byte(arg.optimize())
  case byte_to_int(arg) waffle_byte_to_int(arg.optimize())
  case add(args) {
    var args = args.optimize()
    if args is aggregate(parts) then {
      if parts.len == 2 then {
        var a = parts.get(0)
        var b = parts.get(1)
        if a is int(a) then if b is int(b) then return waffle_int(a + b)
        if a is int(a) then if a == 0 then return b
        if b is int(b) then if b == 0 then return a
      }
    }
    waffle_add(args)
  }
  case subtract(args) {
    var args = args.optimize()
    if args is aggregate(parts) then {
      if parts.len == 2 then {
        var a = parts.get(0)
        var b = parts.get(1)
        if a is int(a) then if b is int(b) then return waffle_int(a - b)
        if b is int(b) then if b == 0 then return a
      }
    }
    waffle_subtract(args)
  }
  case multiply(args) {
    var args = args.optimize()
    if args is aggregate(parts) then {
      if parts.len == 2 then {
        var a = parts.get(0)
        var b = parts.get(1)
        if a is int(a) then if b is int(b) then return waffle_int(a * b)
        if a is int(a) then if a == 1 then return b
        if b is int(b) then if b == 1 then return a
      }
    }
    waffle_multiply(args)
  }
  case divide(args) waffle_divide(args.optimize())
  case modulo(args) waffle_modulo(args.optimize())
  case and_(args) waffle_and(args.optimize())
  case or_(args) waffle_or(args.optimize())
  case xor(args) waffle_xor(args.optimize())
  case shift_left(args) waffle_shift_left(args.optimize())
  case shift_right(args) waffle_shift_right(args.optimize())
  case compare_zero(arg) waffle_compare_zero(arg.optimize())
  case aggregate(aggregate) {
    var parts = list[WaffleExpr]()
    for part in aggregate do parts.&.push(part.optimize())
    waffle_aggregate(parts.to_slice())
  }
  case part(part)
    waffle_part(part.of.optimize(), part.offset, part.layout, 1)
  case switch_(switch_) {
    var cases = list[WaffleBody]()
    for case_ in switch_.cases do cases.&.push(case_.optimize())
    waffle_switch(switch_.condition.optimize(), cases.to_slice())
  }
  case call(call)
    waffle_call(call.function, call.args.optimize(), call.layout.size, call.layout.alignment)
  case call_indirect(call)
    waffle_call_indirect(call.fun_and_args.optimize(), call.layout.size, call.layout.alignment)
  case malloc(size) waffle_malloc(size.optimize())
  case free(free) waffle_free(free.optimize())
  case load_word(ptr) waffle_load_word(ptr.optimize())
  case load_byte(ptr) waffle_load_byte(ptr.optimize())
  case store_word(store) {
    var store = store.optimize()
    if store is aggregate(parts) then {
      if parts.len == 2 then {
        waffle_store_word(parts.get(0), parts.get(1))
      } else {
        waffle_store_word(store)
      }
    } else {
      waffle_store_word(store)
    }
  }
  case store_byte(store) {
    var store = store.optimize()
    if store is aggregate(parts) then {
      if parts.len == 2 then {
        waffle_store_byte(parts.get(0), parts.get(1))
      } else {
        waffle_store_byte(store)
      }
    } else {
      waffle_store_byte(store)
    }
  }
  case store_bytes(store) waffle_store_bytes(store.ptr.optimize(), store.bytes)
  case crash(message) waffle_crash(message.optimize())
  case unreachable expr
  case loop_(loop_)
    waffle_loop(loop_.param, loop_.initial.optimize(), loop_.body.optimize())
  case continue_(continue_)
    waffle_continue(
      continue_.next.optimize(), continue_.layout.size, continue_.layout.alignment
    )
  default expr
}
