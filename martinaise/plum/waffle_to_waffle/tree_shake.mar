import mod.mar

fun is_pure(expr: WaffleExpr): Bool {
  switch expr
  case param false
  case padding true
  case byte true
  case int true
  case local true
  case aggregate(aggregate) {
    for part in aggregate do if not(part.is_pure()) then return false
    true
  }
  case part(part) part.of.is_pure()
  case switch_(switch_) {
    if not(switch_.condition.is_pure()) then return false
    false | TODO
    | for case_ in switch_.cases do case_.collect_referenced(dag, out)
  }
  case call false
  case call_indirect false
  case function_ptr true
  case lower_byte(arg)  arg.is_pure()
  case byte_to_int(arg) arg.is_pure()
  case add(args) args.is_pure()
  case subtract(args) args.is_pure()
  case multiply(args) args.is_pure()
  case divide(args) args.is_pure()
  case modulo(args) args.is_pure()
  case shift_left(args) args.is_pure()
  case shift_right(args) args.is_pure()
  case compare_zero(arg) arg.is_pure()
  case and_(args) args.is_pure()
  case or_(args)  args.is_pure()
  case xor(args)  args.is_pure()
  case malloc false
  case free false
  case load_word false
  case load_byte false
  case store_word false
  case store_byte false
  case store_bytes false
  case crash false
  case unreachable false
  case halt false
  case loop_ false
  case continue_ false
}

fun collect_referenced(expr: WaffleExpr, out: &Set[WaffleId]) {
  switch expr
  case param {}
  case padding {}
  case byte {}
  case int {}
  case local(id) out.put(id)
  case aggregate(aggregate)
    for part in aggregate do part.collect_referenced(out)
  case part(part) part.of.collect_referenced(out)
  case switch_(switch_) {
    switch_.condition.collect_referenced(out)
    for case_ in switch_.cases do case_.collect_referenced(out)
  }
  case call(call) call.args.collect_referenced(out)
  case call_indirect(call) {
    call.fun_and_args.collect_referenced(out)
  }
  case function_ptr(signature) {}
  case lower_byte(arg)  arg.collect_referenced(out)
  case byte_to_int(arg) arg.collect_referenced(out)
  case add(args) args.collect_referenced(out)
  case subtract(args) args.collect_referenced(out)
  case multiply(args) args.collect_referenced(out)
  case divide(args) args.collect_referenced(out)
  case modulo(args) args.collect_referenced(out)
  case shift_left(args) args.collect_referenced(out)
  case shift_right(args) args.collect_referenced(out)
  case compare_zero(arg) arg.collect_referenced(out)
  case and_(args) args.collect_referenced(out)
  case or_(args)  args.collect_referenced(out)
  case xor(args)  args.collect_referenced(out)
  case malloc(size) size.collect_referenced(out)
  case free(args) args.collect_referenced(out)
  case load_word(ptr) ptr.collect_referenced(out)
  case load_byte(ptr) ptr.collect_referenced(out)
  case store_word(store) {
    store.collect_referenced(out)
  }
  case store_byte(store) {
    store.collect_referenced(out)
  }
  case store_bytes(store) store.ptr.collect_referenced(out)
  case crash(message) message.collect_referenced(out)
  case unreachable {}
  case halt {}
  case loop_(loop_) {
    loop_.initial.collect_referenced(out)
    loop_.body.collect_referenced(out)
  }
  case continue_(continue_) continue_.next.collect_referenced(out)
}
fun collect_referenced(body: WaffleBody, out: &Set[WaffleId]) {
  for local in body.locals do local.resolve().collect_referenced(out)
  body.returns.collect_referenced(out)
}

| Tree shakes the body. Assumes that expressions within this body are already
| optimized. This function is shallow, only removing unnecessary locals from the
| current body (not inner bodies).
fun tree_shake(body: WaffleBody): WaffleBody {
  | We go through the body from the bottom to the top, tracking which locals are
  | used referenced later in the body. This way, when we encounter an
  | expression, we know immediately whether we can throw it away.
  var referenced_later_on = set[WaffleId]()
  body.returns.collect_referenced(referenced_later_on.&)

  var rev_locals = list[WaffleId]()
  for local in body.locals.rev_iter() do {
    var expr = local.resolve()

    if not(referenced_later_on.contains(local)) and expr.is_pure() then continue

    expr.collect_referenced(referenced_later_on.&)
    rev_locals.&.push(local)
  }
  var locals = list[WaffleId]()
  for id in rev_locals.to_slice().rev_iter() do locals.&.push(id)

  WaffleBody { locals = locals.to_slice(), returns = body.returns }
}
