import mod.mar

fun memory_layout_low_level(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(MemoryLayoutLowLevel {}))
  Egg { entry_point = egg.entry_point, funs }
}

struct MemoryLayoutLowLevel {}

fun map(
  id: EggId, mapper: MemoryLayoutLowLevel,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mapper, mapping)
  switch expr
  case struct_(struct_) {
    var layout = id.type().memory_layout_struct()
    var parts = list[EggId]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case field(name) struct_.get(name)
        case padding(amount) builder.padding(amount)
      )
    builder.aggregate(parts.to_slice())
  }
  case member(member) {
    var struct_layout =
      id.resolve().member.unwrap().of.type().memory_layout_struct()
    var field_layout = id.type().memory_layout()
    builder.part(
      member.of,
      struct_layout.field_to_offset.get(member.name),
      field_layout.size,
      | field_layout.alignment,
    )
  }
  case enum_(enum_) {
    var enum_layout = id.type().memory_layout_enum()
    var variant_layout = enum_layout.variants.get(enum_.variant)
    var parts = list[EggId]()
    for part in variant_layout.parts do
      switch part
      case payload parts.&.push(enum_.payload)
      case padding(amount) parts.&.push(builder.padding(amount))
      case tag(tag) {
        for i in 0..enum_layout.tag_size do {
          parts.&.push(builder.byte(tag.lower_byte()))
          tag = tag / 256
        }
      }
    builder.aggregate(parts.to_slice())
  }
  case switch_(switch_) {
    var condition = switch_.condition
    var enum_type = id.resolve().switch_.unwrap().condition.type()
    var layout = enum_type.memory_layout_enum()

    var cases = uninitialized_slice[EggBody](layout.tag_to_variant.size)
    for entry in layout.tag_to_variant do {
      var case_ = switch_.cases.get(entry.value)
      var payload_layout = enum_type.variant(entry.value).memory_layout()
      var builder = egg_body_builder().&
      var body = builder.finish(case_.fill(
        list(builder.part(condition, 0, payload_layout.size)).to_slice(),
        builder,
      ))
      cases.&.set(entry.key, body)
    }

    for offset_in_tag in 0..layout.tag_size do {
      | Group groups of 256 cases into a single case.
      var num_new_cases = cases.len + 255 / 256
      var new_cases = uninitialized_slice[EggBody](num_new_cases)
      for i in 0..num_new_cases do {
        var builder = egg_body_builder().&
        var body = builder.finish(
          builder.switch_on_byte(
            builder.part(condition, layout.tag_offset + offset_in_tag, 1),
            | cases.subslice()
            cases.subslice({i * 256}..min(i + 1 * 256, cases.len)),
          )
        )
        new_cases.&.set(i, body)
      }
      cases = new_cases
    }
    if cases.len != 1 then unreachable()

    var case_body = cases.get(0)
    for child in case_body.children do builder.children.&.push(child)
    case_body.returns
  }
  default builder.push(expr)
}
