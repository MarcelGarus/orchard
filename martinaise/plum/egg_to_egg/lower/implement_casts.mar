import mod.mar

fun implement_casts(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(ImplementCasts { funs = funs.& }))
  Egg { funs, entry_point = egg.entry_point }
}

struct ImplementCasts { funs: &Map[String, EggFun] }

fun map(
  id: EggId, mapper: ImplementCasts,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mapper, mapping)
  if expr is cast(cast) then
    return builder.compile_and_call_cast_fun(cast.what, cast.type, mapper.funs)
  builder.push(expr)
}

fun compile_and_call_cast_fun(
  builder: &EggBodyBuilder, what: EggId, type: PlumType,
  funs: &Map[String, EggFun],
): EggId {
  builder.call(
    compile_cast_fun(what.type(), type, funs),
    no_substitutions,
    list(what).to_slice(),
    type,
  )
}

fun compile_cast_fun(
  from: PlumType, to: PlumType, funs: &Map[String, EggFun]
): String {
  var signature = "cast {from} to {to}"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*) | placeholder
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var value = builder.param(from)
      builder.finish(
        if from.internal_kind() is never then builder.unreachable(to)
        else if from == to then value | This cast is the identity fun!
        else
          switch to.kind()
          case type unreachable()
          case byte unreachable()
          case int unreachable()
          case array(to_item_type)
            builder.generate_array(builder.array_len(value), {
              var builder = egg_body_builder().&
              var index = builder.param(type_int)
              builder.finish(
                builder.compile_and_call_cast_fun(
                  builder.array_get(value, index), to_item_type, funs
                ),
              )
            })
          case struct_(to_field_types)
            builder.struct_({
              var to_fields = map[String, EggId]()
              for field in to_field_types do
                to_fields.&.put(
                  field.key,
                  builder.compile_and_call_cast_fun(
                    builder.member(value, field.key), field.value, funs
                  ),
                )
              to_fields
            })
          case enum_(to_variant_types)
            builder.switch_(value, {
              var cases = map[String, EggBody]()
              for variant in from.kind().enum_.unwrap() do
                cases.&.put(variant.key, {
                  var builder = egg_body_builder().&
                  var payload = builder.case_param(value, variant.key)
                  builder.finish(
                    builder.enum_(
                      to,
                      variant.key,
                      builder.compile_and_call_cast_fun(
                        payload, to_variant_types.get(variant.key), funs
                      ),
                    )
                  )
                })
              cases
            })
          case lambda(to_lambda_type) {
            var from_lambda_type = from.kind().lambda.unwrap()
            builder.inline_lambda({
              var builder = egg_body_builder().&
              var outer_params = list[EggId]()
              for param in to_lambda_type.args do
                outer_params.&.push(builder.param(param))
              var inner_params = list[EggId]()
              for param
              in zip(outer_params.iter(), from_lambda_type.args.iter())
              do
                inner_params.&.push(
                  builder.compile_and_call_cast_fun(param.a, param.b, funs)
                )
              builder.finish(
                builder.compile_and_call_cast_fun(
                  builder.call(value, inner_params.to_slice()),
                  from_lambda_type.return_type,
                  funs,
                ),
              )
            })
          }
          default panic("casting {from} to {to} is not supported")
      )
    }
  })
  signature
}
