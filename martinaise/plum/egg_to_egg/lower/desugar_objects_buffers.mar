import mod.mar

| TODO: split?

fun desugar_objects_buffers(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(DesugarObjectsBuffers {}))
  Egg { funs, entry_point = egg.entry_point }
}

struct DesugarObjectsBuffers {}

fun map(
  id: EggId, mapper: DesugarObjectsBuffers,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mapper, mapping)
  switch expr
  | Objects are stored on the heap with the following layout:
  | [refcount][value]
  case object_new(value) {
    var layout = value.type().memory_layout()
    var ptr = builder.malloc(builder.int(8 + layout.size))
    builder.store(ptr, builder.int(1)) | refcount
    builder.store(builder.add(ptr, builder.int(8)), value)
    ptr
  }
  case object_load(load) {
    var layout = load.type.memory_layout()
    builder.load(
      builder.add(load.ptr, builder.int(8)), layout.size, | layout.alignment
    )
  }
  case object_free(free) {
    var layout = free.type.memory_layout()
    builder.free(free.ptr, builder.int(8 + layout.size))
  }
  case get_refcount(get) builder.load(get.ptr, 8)
  case set_refcount(set) builder.store(set.ptr, set.refcount)
  | Buffers are stored on the heap with the following layout:
  | [refcount][length][item][item][item]...
  case new_buffer(new) {
    var item_layout = new.item_type.memory_layout()
    var ptr = builder.malloc(builder.add(
      builder.int(16), | refcount + length
      builder.multiply(new.length, builder.int(item_layout.stride_size())),
    ))
    builder.store(ptr, builder.int(1))
    builder.store(builder.add(ptr, builder.int(8)), new.length)
    ptr
  }
  case get_buffer_length(ptr)
    builder.load(builder.add(ptr, builder.int(8)), 8)
  case load_buffer_item(load) {
    var item_layout = load.item_type.memory_layout()
    var offset = builder.add(
      builder.int(16), | refcount + length
      builder.multiply(load.index, builder.int(item_layout.stride_size())),
    )
    builder.load(
      builder.add(load.buffer, offset), item_layout.size, | item_layout.alignment
    )
  }
  case store_buffer_item(store) {
    var item_layout = store.item_type.memory_layout()
    var items_base = builder.add(store.buffer, builder.int(16)) | refcount + len
    builder.store(
      builder.add(
        items_base,
        builder.multiply(store.index, builder.int(item_layout.stride_size())),
      ),
      store.item,
    )
  }
  case store_buffer_bytes(store)
    builder.store_bytes(builder.add(store.buffer, builder.int(16)), store.bytes)
  case free_buffer(free) {
    var item_layout = free.item_type.memory_layout()
    var len = builder.load(builder.add(free.buffer, builder.int(8)), 8)
    var size = builder.add(
      builder.int(16), | refcount + length
      builder.multiply(len, builder.int(item_layout.stride_size())),
    )
    builder.free(free.buffer, size)
  }
  default builder.push(expr)
}
