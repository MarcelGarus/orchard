import mod.mar

fun split_loads_and_stores(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(SplitLoadsAndStores {}))
  Egg { funs, entry_point = egg.entry_point }
}

struct SplitLoadsAndStores {}

fun map(
  id: EggId, mapper: SplitLoadsAndStores,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mapper, mapping)
  switch expr
  case load(load) {
    var cursor = 0
    var parts = list[EggId]()
    loop if cursor + 8 > load.size then break else {
      parts.&.push(
        builder.load_word(builder.add(load.ptr, builder.int(cursor)))
      )
      cursor = cursor + 8
    }
    loop if cursor == load.size then break else {
      parts.&.push(
        builder.load_byte(builder.add(load.ptr, builder.int(cursor)))
      )
      cursor = cursor + 1
    }
    builder.aggregate(parts.to_slice())
  }
  case store(store) {
    var size = store.value.type().size()
    var cursor = 0
    loop if cursor + 8 > size then break else {
      builder.store_word(
        builder.add(store.ptr, builder.int(cursor)),
        builder.part(store.value, cursor, 8),
      )
      cursor = cursor + 8
    }
    loop if cursor == size then break else {
      builder.store_byte(
        builder.add(store.ptr, builder.int(cursor)),
        builder.part(store.value, cursor, 1),
      )
      cursor = cursor + 1
    }
    builder.nothing()
  }
  default builder.push(expr)
}
