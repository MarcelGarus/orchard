import mod.mar

fun memory_layout_high_level(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do {
    | eprintln("memory_layout_high_level {fun_.key}")
    funs.&.put(fun_.key, fun_.value.memory_layout_high_level(funs.&))
  }
  Egg { entry_point = egg.entry_point, funs }
}

fun memory_layout_high_level(fun_: EggFun, funs: &Map[String, EggFun]): EggFun {
  fun_.map(MemLayoutHighLevel { funs })
}

struct MemLayoutHighLevel { funs: &Map[String, EggFun] }

fun map(
  id: EggId,
  layout: MemLayoutHighLevel,
  builder: &EggBodyBuilder,
  mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.resolve()

  switch expr
  case param(type) builder.param(type.to_pesto())
  case dup(dup) {
    builder.desugared_dup(dup.id.map(mapping.*), dup.type)
    builder.nothing()
  }
  case drop(drop) {
    builder.desugared_drop(drop.id.map(mapping.*), drop.type, layout.funs)
    builder.nothing()
  }
  case enum_(enum_) {
    var payload = enum_.payload.map(mapping.*)
    if enum_.type.variant(enum_.variant).is_unboxed_recursive() then
      payload =   builder.object_new(payload)
    builder.enum_(enum_.type, enum_.variant, payload)
  }
  case switch_(switch_) {
    var condition = switch_.condition.map(mapping.*)
    var cases = map[String, EggBody]()
    for case_ in switch_.cases do {
      var variant = case_.key
      var case_ = case_.value
      var builder = egg_body_builder().&

      var payload_type = condition.type().variant(variant)
      var payload = builder.param(payload_type.to_pesto())
      if payload_type.is_unboxed_recursive() then
        payload = builder.object_load(payload, payload_type.to_pesto())
      mapping.put(case_.params.get(0), payload)

      for child in case_.children do
        mapping.put(child, child.map(layout, builder, mapping))

      var body = builder.finish(case_.returns.map(mapping.*))
      cases.&.put(variant, body)
    }
    builder.switch_(condition, cases)
  }
  case raw_lambda(lambda)
    builder.struct_(map(
      "closure" -> lambda.closure.map(mapping.*),
      "body" -> builder.function_ptr(lambda.fun_),
      "free" -> builder.function_ptr(
        free_box_fun(lambda.closure.type().plum().box.unwrap(), layout.funs)
      ),
    ))
  case call_fun(call) {
    | var args = map[String, EggId]()
    | for arg in call.args.iter().enumerate() do
    |   args.&.put("{arg.index}", mapping.get(arg.item))
    | var args = builder.struct_(args)

    builder.call(
      call.fun_, no_substitutions, call.args.map(mapping.*), call.return_type.to_pesto()
    )
  }
  case call_lambda(call) {
    var lambda = call.lambda.map(mapping.*)
    var closure_ptr = builder.member(lambda, "closure")
    var body_ptr = builder.member(lambda, "body")

    | var args = map[String, EggId]()
    | for arg in call.args.iter().enumerate() do
    |   args.&.put("{arg.index}", mapping.get(arg.item))
    | args.&.put("{call.args.len}", closure_ptr)
    | var args = builder.struct_(args)

    builder.call_indirect(
      body_ptr,
      call.args.map(mapping.*),
      call.lambda.type().plum().lambda.unwrap().return_type.to_pesto(),
    )
  }
  case box(value) {
    if value.type().num_inhabitants() <= NumInhabitants.one then
      builder.null_ptr()
    else
      builder.object_new(value.map(mapping.*))
  }
  case unbox(box) {
    var box_type = box.type()
    var ptr = box.map(mapping.*)
    var inner_type = box_type.plum().box.unwrap()
    if inner_type.num_inhabitants() <= NumInhabitants.one then
      builder.construct_inhabitant(inner_type)
    else {
      var inner = builder.object_load(ptr, inner_type.to_pesto())
      builder.desugared_dup(inner, inner_type)
      builder.desugared_drop(ptr, box_type, layout.funs)
      inner
    }
  }
  case array(array) {
    if array.items.len == 0 then
      return builder.struct_(map(
        "buffer" -> builder.null_ptr(),
        "start" -> builder.int(0),
        "end" -> builder.int(0),
      ))

    | Special case byte arrays.
    | TODO: do this later in the compilation
    var all_bytes = true
    for item in array.items do
      if not(item.resolve() is byte) then all_bytes = false
    if all_bytes then {
      var buffer = builder.new_buffer(
        type_byte.to_pesto(), builder.int(array.items.len)
      )
      var bytes = list[Byte]()
      for byte in array.items do bytes.&.push(byte.resolve().byte.unwrap())
      builder.store_buffer_bytes(buffer, bytes.to_slice())
      return builder.struct_(map(
        "buffer" -> buffer,
        "start" -> builder.int(0),
        "end" -> builder.int(array.items.len),
      ))
    }

    var item_type = id.type().plum().array.unwrap()
    var buffer = builder.new_buffer(
      item_type.to_pesto(), builder.int(array.items.len)
    )
    for item in array.items.iter().enumerate() do
      builder.store_buffer_item(
        buffer,
        item.item.type().to_pesto(),
        builder.int(item.index),
        item.item.map(mapping.*),
      )
    builder.struct_(map(
      "buffer" -> buffer,
      "start" -> builder.int(0),
      "end" -> builder.int(array.items.len),
    ))
  }
  case unchecked_generate_non_empty_array(gen) {
    var length = gen.length.map(mapping.*)
    var generator = gen.generator
    var item_type = generator.returns.type()
    var buffer = builder.new_buffer(item_type.to_pesto(), length)
    builder.loop_(list(builder.int(0)).to_slice(), {
      var builder = egg_body_builder().&
      var cursor = builder.param(type_int)
      builder.finish(
        builder.switch_on_ordering(
          builder.compare(cursor, length),
          {
            var builder = egg_body_builder().&
            mapping.put(generator.params.get(0), cursor)
            for child in generator.children do
              mapping.put(child, child.map(layout, builder, mapping))
            var item = generator.returns.map(mapping.*)
            builder.store_buffer_item(buffer, item_type.to_pesto(), cursor, item)
            builder.finish(
              builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                type_nothing.to_pesto(),
              )
            )
          },
          egg_body_builder().finish_with_nothing(),
          egg_body_builder().finish_with_unreachable(type_nothing.to_pesto()),
        )
      )
    })
    builder.struct_(map(
      "buffer" -> buffer, "start" -> builder.int(0), "end" -> length
    ))
  }
  case array_len(array) {
    var array_type = array.type()
    var array = array.map(mapping.*)
    var length = builder.subtract(
      builder.member(array, "end"), builder.member(array, "start")
    )
    builder.drop(array, array_type)
    return length
  }
  case unchecked_array_get(args) {
    var array_type = args.array.type()
    var item_type = array_type.plum().array.unwrap()
    var array = args.array.map(mapping.*)
    var index = args.index.map(mapping.*)
    var item = builder.load_buffer_item(
      builder.member(array, "buffer"),
      item_type.to_pesto(),
      builder.add(builder.member(array, "start"), index),
    )
    builder.dup(item, item_type)
    builder.drop(array, array_type)
    item
  }
  case unchecked_array_set(args) {
    var array_type = args.array.type()
    var item_type = array_type.plum().array.unwrap()
    var array = args.array.map(mapping.*)
    var index = args.index.map(mapping.*)
    var item = args.item.map(mapping.*)
    var buffer = builder.member(array, "buffer")
    var start = builder.member(array, "start")
    var end = builder.member(array, "end")

    | If the buffer's reference count is 1, we have exclusive ownership and can
    | mutate the buffer in place. Otherwise, we copy the part of the buffer that
    | this array points to, and then we set the item in that copy.
    var owned_array = builder.switch_on_ordering(
      builder.compare(builder.get_refcount(buffer), builder.int(1)),
      egg_body_builder().finish_with_unreachable(array_type.to_pesto()),
      egg_body_builder().finish(array),
      {
        var builder = egg_body_builder().&
        var length = builder.subtract(end, start)
        var copy = builder.new_buffer(item_type.to_pesto(), length)
        builder.decrement_refcount(buffer)
        builder.loop_(list(builder.int(0)).to_slice(), {
          var builder = egg_body_builder().&
          var cursor = builder.param(type_int)
          builder.finish(builder.switch_on_ordering(
            builder.compare(cursor, length),
            {
              var builder = egg_body_builder().&
              var item = builder.load_buffer_item(
                buffer, item_type.to_pesto(), builder.add(start, cursor)
              )
              builder.store_buffer_item(
                copy, item_type.to_pesto(), cursor, item
              )
              builder.finish(builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(), type_ptr
              ))
            },
            egg_body_builder().finish(copy),
            egg_body_builder().finish_with_unreachable(type_ptr),
          ))
        })
        builder.finish(builder.struct_(map(
          "buffer" -> copy, "start" -> builder.int(0), "length" -> length
        )))
      },
    )

    var offset = builder.add(start, index)
    var previous = builder.load_buffer_item(
      buffer, item_type.to_pesto(), offset
    )
    builder.drop(previous, item_type)
    builder.store_buffer_item(buffer, item_type.to_pesto(), offset, item)
    owned_array
  }
  case array_slice(args) {
    var array = args.array.map(mapping.*)
    var start = args.start.map(mapping.*)
    var end = args.end.map(mapping.*)
    var old_start = builder.member(array, "start")
    builder.struct_(map(
      "buffer" -> builder.member(array, "buffer"),
      "start" -> builder.add(old_start, start),
      "end" -> builder.add(old_start, end),
    ))
  }
  case type builder.nothing()
  case crash(crash)
    builder.crash(crash.message.map(mapping.*), crash.type.to_pesto())
  case unreachable(type) builder.unreachable(type.to_pesto())
  case continue_(continue_)
    builder.continue_(continue_.next.map(mapping.*), continue_.type.to_pesto())
  default {
    builder.push(id.map_children(layout, mapping))
  }
}

| Traverses the value and dups all inner values. If it reaches a pointer, it
| just increments that pointer's reference count instead of traversing further.
fun desugared_dup(
  builder: &EggBodyBuilder, value: EggId, type: EggType
) {
  if not(type.to_pesto().contains_ptr()) then return {}

  switch type.plum()
  case variable unreachable()
  case byte {}
  case int {}
  case type {}
  case box(inner_type)
    if inner_type.num_inhabitants() > NumInhabitants.one then
      builder.increment_refcount(value).ignore()
  case array {
    var buffer = builder.member(value, "buffer")
    builder.if_not_null_ptr(buffer, {
      var builder = egg_body_builder().&
      builder.finish(builder.increment_refcount(buffer))
    })
  }
  case never builder.unreachable(type_nothing).ignore()
  case struct_
    for field in type.plum().struct_.unwrap() do
      builder.desugared_dup(builder.member(value, field.key), field.value)
  case enum_ {
    var cases = map[String, EggBody]()
    for variant in type.enum_() do {
      var builder = egg_body_builder().&
      var payload_type = value.type().variant(variant.key)
      var payload = builder.param(payload_type)
      if payload_type.is_unboxed_recursive() then
        builder.increment_refcount(payload).ignore()
      else
        builder.desugared_dup(payload, variant.value)
      cases.&.put(variant.key, builder.finish_with_nothing())
    }
    builder.switch_(value, cases).ignore()
  }
  case lambda
    builder.increment_refcount(builder.member(value, "closure")).ignore()
}

| Traverses the value and drops all inner values. If it reaches a pointer, it
| just decrements pointer's reference count instead of traversing further. If
| the reference count reaches zero, it drops the pointed-to value and frees the
| allocation.
fun desugared_drop(
  builder: &EggBodyBuilder, value: EggId, type: EggType,
  funs: &Map[String, EggFun],
) {
  if not(type.to_pesto().contains_ptr()) then return {}

  switch type.plum()
  case variable unreachable()
  case byte {}
  case int {}
  case type {}
  case box(inner_type)
    if inner_type.num_inhabitants() > NumInhabitants.one then
      builder.if_refcount_zero(builder.decrement_refcount(value), {
        var builder = egg_body_builder().&
        builder.call(
          free_box_fun(inner_type, funs),
          no_substitutions,
          list(value).to_slice(),
          type_nothing.to_pesto(),
        )
        builder.finish_with_nothing()
      })
  case array(item_type) {
    var buffer = builder.member(value, "buffer")
    builder.if_not_null_ptr(buffer, {
      var builder = egg_body_builder().&
      var new_refcount = builder.decrement_refcount(buffer)
      builder.if_refcount_zero(new_refcount, {
        var builder = egg_body_builder().&
        builder.call(
          free_buffer_fun(item_type, funs),
          no_substitutions,
          list(buffer).to_slice(),
          type_nothing.to_pesto(),
        )
        builder.finish_with_nothing()
      })
      builder.finish_with_nothing()
    })
  }
  case never {}
  case struct_
    for field in type.plum().struct_.unwrap() do
      builder.desugared_drop(
        builder.member(value, field.key), field.value, funs
      )
  case enum_(variant_types) {
    var cases = map[String, EggBody]()
    for variant in variant_types do {
      var payload_type = variant.value
      var builder = egg_body_builder().&
      var payload = builder.param(payload_type)
      if payload_type.is_unboxed_recursive() then
        builder.if_refcount_zero(builder.decrement_refcount(payload), {
          var builder = egg_body_builder().&
          builder.call(
            free_box_fun(payload_type, funs),
            no_substitutions,
            list(payload).to_slice(),
            type_nothing.to_pesto(),
          )
          builder.finish_with_nothing()
        })
      else
        builder.desugared_drop(payload, payload_type, funs)

      cases.&.put(variant.key, builder.finish_with_nothing())
    }
    builder.switch_(value, cases).ignore()
  }
  case lambda {
    var closure_ptr = builder.member(value, "closure")
    var new_refcount = builder.decrement_refcount(closure_ptr)
    builder.if_refcount_zero(new_refcount, {
      var builder = egg_body_builder().&
      var free_fun_ptr = builder.member(value, "free")
      builder.call_indirect(
        free_fun_ptr, list(closure_ptr).to_slice(), type_nothing.to_pesto()
      )
      builder.finish_with_nothing()
    })
  }
}

| Expects a box with refcount 0. Drops the inner value and frees the allocation.
fun free_box_fun(inner_type: EggType, funs: &Map[String, EggFun]): String {
  var signature = "free (Box {inner_type})"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*)
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var box = builder.param(type_ptr)
      if inner_type.num_inhabitants() <= NumInhabitants.one then {
        | This function will never be called, as the box is always a null ptr.
        | We may still need to construct the free function as part of the ABI.
        | For example, if code returns a lambda, that lambda needs to have a
        | closure pointer, body pointer, and closure free pointer. If the lambda
        | doesn't capture any variables, the closure is empty and we save the
        | heap allocation, storing a null ptr instead. When you drop the lambda,
        | you have to check for null pointers. The function for freeing the
        | closure should never be called.
        builder.finish_with_unreachable(type_nothing)
      } else {
        var inner = builder.object_load(box, inner_type.to_pesto())
        builder.desugared_drop(inner, inner_type, funs)
        builder.object_free(box, inner_type.to_pesto())
        builder.finish_with_nothing()
      }
    }
  })
  signature
}

| Expects an array with refcount 0. Drops the inner values and frees the
| allocation.
fun free_buffer_fun(item_type: EggType, funs: &Map[String, EggFun]): String {
  var signature = "drop (Buffer {item_type})"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*)
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var buffer = builder.param(item_type.to_pesto())
      var len = builder.get_buffer_length(buffer)

      builder.loop_(list(builder.int(0)).to_slice(), {
        var builder = egg_body_builder().&
        var cursor = builder.param(type_int)
        var cmp = builder.compare(cursor, len)
        builder.switch_on_ordering(
          cmp,
          egg_body_builder().finish_with_unreachable(type_nothing.to_pesto()),
          egg_body_builder().finish_with_nothing(),
          {
            var builder = egg_body_builder().&
            var item = builder.load_buffer_item(
              buffer, item_type.to_pesto(), cursor
            )
            builder.desugared_drop(item, item_type, funs)
            builder.finish(
              builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                type_nothing.to_pesto(),
              )
            )
          },
        ).ignore()
        builder.finish_with_nothing()
      })

      builder.free_buffer(buffer, item_type.to_pesto())
      builder.finish_with_nothing()
    }
  })
  signature
}

var type_pesto_array = type_struct(map(
  "buffer" -> type_ptr,
  "start" -> type_ptr,
  "length" -> type_ptr,
))

var type_pesto_lambda = type_struct(map(
  "closure" -> type_ptr,
  "body" -> type_ptr,
  "free" -> type_ptr,
))

fun to_pesto(type: EggType): EggType {
  switch type.plum_not_extended()
  case variable unreachable()
  case byte type_byte
  case int type_int
  case type type_nothing
  case box type_ptr
  case array type_pesto_array
  case never type_never
  case struct_(struct_) {
    var fields = map[String, EggType]()
    for field in struct_ do fields.&.put(field.key, field.value.to_pesto())
    type_struct(fields)
  }
  case enum_(enum_) {
    var variants = map[String, EggType]()
    for variant in enum_ do {
      var payload = variant.value
      variants.&.put(
        variant.key,
        if payload.is_unboxed_recursive() then
          type_ptr
        else
          payload.to_pesto(),
      )
    }
    type_enum(variants)
  }
  case lambda type_pesto_lambda
  case recursive unreachable() | TODO: panics for recursive structs
}

fun is_unboxed_recursive(type: EggType): Bool { type.is_unboxed_recursive(1) }
fun is_unboxed_recursive(type: EggType, depth: Int): Bool {
  switch type.plum_not_extended()
  case variable unreachable()
  case never false
  case byte false
  case int false
  case type false
  case box false
  case array false
  case struct_(struct_) {
    for field in struct_ do
      if field.value.is_unboxed_recursive(depth + 1) then return true
    false
  }
  case enum_(enum_) {
    for variant in enum_ do
      if variant.value.is_unboxed_recursive(depth + 1) then return true
    false
  }
  case lambda false
  case recursive(level) level >= depth
}

fun contains_ptr(type: EggType): Bool {
  switch type.pesto()
  case never false
  case byte false
  case int false
  case struct_(fields) {
    for field in fields do if field.value.contains_ptr() then return true
    false
  }
  case enum_(variants) {
    for variant in variants do if variant.value.contains_ptr() then return true
    false
  }
  case ptr true
}