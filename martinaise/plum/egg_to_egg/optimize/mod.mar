| Welcome to the Egg optimizer! This file contains lots of code, so I'll point
| out some general themes going on here. The code here is used to turn a Egg
| into a more optimized Egg.
|
| This is achieved by constant folding operations, inlining function calls,
| analyzing fixpoints of recursive expressions, and pulling impure operations
| out of the tree.

import ../mod.mar
import choose_order.mar
import deduplicate.mar
import enum_flow.mar
import fixpoints.mar
import hoist.mar
import tree_shake.mar

fun optimize(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for signature in egg.choose_optimization_order() do {
    | eprintln("Optimizing {signature}")
    | stderr.write("original", egg.funs.get(signature))
    var optimized = egg.funs.get(signature).map(Optimize { optimized = funs.& })
    | eprintln("Optimized {signature}:")
    | stderr.write("optimized", optimized)
    | stderr."\n"
    optimized.verify()
    funs.&.put(signature, optimized)
  }
  Egg { funs, entry_point = egg.entry_point }.tree_shake()
}
fun optimize_without_inlining(body: EggBody): EggBody {
  body.map(
    Optimize { optimized = map[String, EggFun]().& }, map[EggId, EggId]().&
  )
}

var optimized_cache = map[EggId, EggBody]().put_on_heap()

struct Optimize { optimized: &Map[String, EggFun] }
fun map(
  body: EggBody, optimize: Optimize, mapping: &Map[EggId, EggId]
): EggBody {
  var body = {
    | Explicitly do not map the params. We try applying optimizations again and
    | again until the expression doesn't change anymore. As params are compared
    | using their identity, optimizing them as well would cause infinite
    | recursion.
    var builder = egg_body_builder().&
    for param in body.params do
      mapping.put(
        param,
        switch param.resolve()
        case param builder.push(param)
        case case_param(param)
          builder.case_param(param.switch_on.map(mapping.*), param.variant)
        default unreachable(),
      )
    for child in body.children do
      mapping.put(child, child.map(optimize, builder, mapping))
    builder.finish(body.returns.map(mapping.*))
  }

  body
    .use_enum_flow()
    .deduplicate()
    .tree_shake()
}
fun map(
  old: EggId,
  optimize: Optimize, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  | eprintln("Optimizing {old.debug()} {old.resolve().debug()}")
  | stderr."\n"
  | stderr.write(old, namespace().&, indentation(1))
  | stderr."\n"

  switch old.resolve()
  case param panic("should not be optimized")
  case case_param panic("should not be optimized")
  default {}

  if optimized_cache.get_maybe(old) is some(new) then {
    for param in new.params do builder.push(param)
    for child in new.children do builder.push(child)
    return new.returns
  }


  | A version of the expression with optimized children. For example, if the
  | current expression is a switch, this will create the same switch but with
  | optimized bodies.
  var children_optimized = old.map_children(optimize, mapping).create()

  | eprintln("Children optimized: {children_optimized.debug()} {children_optimized.resolve().debug()}")
  | stderr."\n"
  | stderr.write(children_optimized, namespace().&, indentation(1))
  | stderr."\n"

  | A body that contains:
  | - unoptimized expressions that resulted from optimizing the current
  |   expression
  | - the current slightly optimized expression
  var slightly_optimized = {
    var builder = egg_body_builder().&
    builder.finish(children_optimized.optimize(optimize, builder))
  }

  | eprintln("old:      {old.debug()}")
  | eprintln("children: {children_optimized.debug()}")
  | eprintln("slight:   {slightly_optimized.debug()}")

  | A body that contains:
  | - fully optimized expressions that resulted from optimizing the current
  |   expression
  | - the current fully optimized expression
  var fully_optimized =
    if slightly_optimized.returns == children_optimized then {
      | The current expression could not be further optimized apart from
      | optimizing its children.
      slightly_optimized
    } else {
      | The current expression was broken down into some smaller expressions.
      | Optimize those recursively.
      var builder = egg_body_builder().&
      for child in slightly_optimized.children do
        mapping.put(child, child.map(optimize, builder, mapping))
      builder.finish(slightly_optimized.returns.map(mapping.*))
    }

  | eprintln("full:     {fully_optimized.debug()}")

  for child in fully_optimized.children do builder.push(child)

  mapping.put(old, fully_optimized.returns)
  optimized_cache.put(old, fully_optimized)
  fully_optimized.returns
}

| Assuming that the dependencies of the expression are accessible in the
| builder and already optimized, emit expressions that are equivalent to
| performing the expression.
fun optimize(id: EggId, optimize: Optimize, builder: &EggBodyBuilder): EggId {
  | eprintln("Optimizing {id.debug()}")
  | stderr.write(id, namespace().&, indentation(1))
  | stderr."\n"

  switch id.resolve()
  case inline_lambda(lambda) {
    panic("don't lambda")
    
    | TODO: remove
    | Assuming that the lambda will run often, hoisting pure expressions out of
    | it prevents recalculating them over and over every time the lambda is
    | called.
    |
    | a = ...
    | ---------------------------------------
    | lambda c:           |  b = multiply a a
    |   d = multiply a a  |  lambda d:
    |   e = add c d       |    e = add b d
    |   e                 |    e
    var hoisted = lambda.hoist_from_body_running_often()
    if hoisted.hoisted.is_not_empty() then {
      for id in hoisted.hoisted do builder.push(id)
      return builder.inline_lambda(hoisted.body)
    }
  }
  case raw_lambda(lambda) {
    | We want to merge nested recursive lambdas.
    | eprintln("Lambda")
    | var shape = lambda.closure.shape()
    | eprintln("Closure shape: {shape.debug()}")
    | if shape.contains_lambda() then
    |   if optimize.optimized.get_maybe(lambda.fun_) is some(fun_) then
    |     fun_.specialize_for_closure_shape(shape, optimize)
  }
  case member(member) {
    | Constant fold members of known structs.
    |
    | a = ...
    | b = ...
    | c = & foo: a bar: b
    | -------------------
    | member c.foo  |  a
    if member.of.resolve() is struct_(fields) then
      return fields.get(member.name)
  }
  case switch_(switch_) {
    | Constant fold switches on enums of known variants.
    |
    | a = &
    | b = | true: a
    | -----------------------
    | switch b       |  int 2
    |   true d:      |
    |     e = int 2  |
    |     e          |
    |   false f:     |
    |     g = int 3  |
    |     g          |
    if switch_.condition.resolve() is enum_(enum_) then
      return switch_.cases.get(enum_.variant).fill(enum_.payload, builder)

    | If all cases are either the same value that doesn't depend on parameters
    | or unreachable, replace the switch with that value.
    |
    | a = ...
    | ---------------------------------
    | switch a             |  int 3
    |   true b:            |
    |     c = unreachable  |
    |     c                |
    |   false d:           |
    |     e = int 3        |
    |     e                |
    var reachable_cases = list[MapEntry[String, EggBody]]()
    for case_ in switch_.cases do
      if not(case_.value.is_unreachable()) then reachable_cases.&.push(case_)
    if reachable_cases.is_empty() then return builder.unreachable(id.type())
    else if not(reachable_cases.get(0).value.uses_params()) then {
      var common = reachable_cases.get(0).value.without_params()
      | eprintln("common: {common.debug()}")
      var inline = true
      for case_ in reachable_cases do {
        if not(inline) then break
        if case_.value.without_params() != common then inline = false
      }
      | eprintln("filling common? {inline}")
      if inline then return common.fill(empty_slice[EggId](), builder)
    }

    | If all non-diverging cases are the same and don't depend on parameters,
    | pull them out of the switch, leaving the switch to evaluate to Nothing.
    | This then leaves simpler, more constant-foldable ingredients for later
    | expressions.
    |
    | a = ...
    | ---------------------------------
    | switch a       |  b =
    |   true b:      |    switch a
    |     c = crash  |      true c:
    |     c          |        d = crash
    |   false d:     |        d
    |     e = int 3  |      false e:
    |     e          |        f = &
    |                |        f
    |                |  int 3
    var non_diverging_cases = list[MapEntry[String, EggBody]]()
    for case_ in switch_.cases do
      if not(case_.value.definitely_diverges_biased()) then
        non_diverging_cases.&.push(case_)
    if non_diverging_cases.is_not_empty()
      and not(non_diverging_cases.get(0).value.uses_params())
    then {
      var common = non_diverging_cases.get(0).value.without_params()
      var nothing = egg_body_builder().&.nothing()
      var is_body_just_returning_nothing =
        common.returns == nothing and {
          common.children.is_empty() or
            common.children.len == 1 and common.children.get(0) == nothing
        }
      var inline = not(is_body_just_returning_nothing)
      for case_ in non_diverging_cases do {
        if not(inline) then break
        if case_.value.without_params() != common then inline = false
      }
      if inline then {
        builder.switch_(switch_.condition, {
          var new_cases = map[String, EggBody]()
          for case_ in switch_.cases do
            new_cases.&.put(
              case_.key,
              if case_.value.without_params() == common
              then {
                var builder = egg_body_builder().&
                for param in case_.value.params do builder.params.&.push(param)
                builder.finish(builder.nothing())
              }
              else case_.value
            )
          new_cases
        })
        return common.fill(empty_slice[EggId](), builder)
      }
    }

    | Consider "inlining" switches that switch on the result of other switches.
    |
    | c = compare a b       |  c = compare a b
    | d =                   |  d =
    |   switch c            |    switch c
    |     less e:           |      less e:
    |       f = &           |        f = crash
    |       g = | false: f  |        f
    |       g               |      equal g:
    |     equal h:          |        h = &
    |       i = &           |        h
    |       j = | true: i   |      less i:
    |       j               |        j = crash
    |     greater k:        |        j
    |       l = &           |
    |       m = | true: l   |
    |       m               |
    | n =                   |
    |   switch d            |
    |     true o:           |
    |       p = &           |
    |       p               |
    |     false q:          |
    |       r = crash       |
    | if switch_.condition.resolve() is switch_(inner_switch) then {
    |   var all_cases_known = true
    |   for case_ in inner_switch.cases do
    |     if not(case_.value.expr.resolve() is enum_) then all_cases_known = false
    |   | If not all cases are known, we would have copy the entire outer switch
    |   | into at least one case of the inner switch. That's a huge code
    |   | explosion, so let's not do that.
    |   if all_cases_known then {
    |     | Calculate how much code explosion we would have. For example, if one
    |     | case of the outer switch is really big and multiple branches from the
    |     | inner switch evaluate to that variant, maybe we don't want to inline
    |     | the code.
    |     var max_outer_case_complexity = 0
    |     for case_ in switch_.cases do
    |       max_outer_case_complexity =
    |         max(max_outer_case_complexity, case_.value.expr.num_exprs())
    |     if max_outer_case_complexity <= 2 then {
    |       return switch_(inner_switch.condition.*, expr.type, {
    |         var new_cases = map[String, EggBody]()
    |         for case_ in inner_switch.cases do
    |           new_cases.&.put(
    |             case_.key,
    |             body(
    |               case_.value.params,
    |               switch_(case_.value.expr, expr.type, switch_.cases)
    |                 ,
    |             ),
    |           )
    |         new_cases
    |       })
    |     }
    |   }
    | }

    | TODO: Inner switch but one variant of the outer switch is never chosen;
    | case could be optimized to unreachable.

    | TODO: If a switch diverges in a case, when switching on the same
    | expression later, the diverging case is unreachable.
  }
  case call_fun(call) {
    | TODO: Try to run the function at compile time.

    | Inline the function, if:
    | - The function has already been visited during the optimization pass.
    |   Otherwise, mutually recursive functions might hang the compiler.
    | - The function size fits in some upper bound.
    |   Otherwise, we may get exponential code explosion.
    | - The function is not generic.
    |   Otherwise, the function might call itself with different type arguments
    |   and we can't model that, not even using a recursive expression. After
    |   monomorphization, no generic functions exist, so every function has a
    |   chance of being inlined eventually.
    |
    | a = int 3
    | b = int 2
    | --------------------------------
    | call + a b  |  add a b  |  int 5
    if call.substitutions.substitutions.size == 0 then
      if optimize.optimized.get_maybe(call.fun_) is some(fun_) then {
        if fun_.body.num_exprs() <= 50 then {
          if not(fun_.recurses(call.fun_)) and not(fun_.contains_lambda()) then {
            | eprintln("inlining {call.fun_}")
            | eprintln("fun:\n")
            | stderr.write(Egg { funs = map(call.fun_ -> fun_), entry_point = "" })
            | stderr."\n"
            return fun_.body.fill(call.args, builder)
          } else if fun_.only_recurses_in_tail_position(call.fun_) then {
            | return builder.loop_(
            |   call.args,
            |   fun_.body.call_to_continue_(call.fun_, call.return_type),
            | )
          } else {
            | We don't inline general recursive functions.
          }
        }
      }

    | TODO: recurses only in tail position? turn into a loop!
    
  }
  case call_lambda(call) {
    | Inline calls of lambda literals.
    |
    | a =
    |   lambda b:
    |     c = int 3
    |     d = add b c
    |     d
    | e = int 4
    | ----------------------------------
    | call lambda a with e  |  f = int 3
    |                       |  add e f
    if call.lambda.resolve() is inline_lambda(lambda_body) then
     return lambda_body.fill(call.args, builder)

    | Inline calls of lambda literals.
    if call.lambda.resolve() is raw_lambda(lambda) then {
      var full_args = list[EggId]()
      for arg in call.args do full_args.&.push(arg)
      full_args.&.push(lambda.closure)
      return builder.call(
        lambda.fun_,
        no_substitutions,
        full_args.to_slice(),
        lambda.type.kind().lambda.unwrap().return_type,
      )
    }
  }
  case cast(cast) {
    | Remove unnecessary casts.
    |
    | a = int 2
    | ------------------
    | cast a (Int)  |  a
    if cast.what.type() == cast.type then return cast.what

    | Instead of casting enums, construct them directly with the correct type.
    |
    | a = &
    | b = | none: a (| none: (&))
    | ------------------------------------------------------------------------
    | cast b (| none: (&) some: (Int))  |  | none: a (| none: (&) some: (Int))
    if cast.what.resolve() is enum_(enum_) then {
      return builder.enum_(
        cast.type,
        enum_.variant,
        builder.cast(
          enum_.payload, cast.type.kind().enum_.unwrap().get(enum_.variant)
        ),
      )
    }
  }
  case lower_byte(arg) {
    | Constant fold.
    if arg.resolve() is int(int) then return builder.byte(int.lower_byte())

    | lower_byte(byte_to_int(a)) = a
    if arg.resolve() is byte_to_int(a) then return a
  }
  case byte_to_int(arg) {
    | Constant fold.
    if arg.resolve() is byte(byte) then return builder.int(byte.to_int())
  }
  case add(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a + b)

    | 0 + x = x
    if a.resolve() is int(a) then if a == 0 then return b

    | x + 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | (x - y) + y = x
    if a.resolve() is subtract(args) then if b == args.b then return args.a

    | x + (y - x) = y
    if b.resolve() is subtract(args) then if a == args.b then return args.a
  }
  case subtract(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a - b)

    | x - 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | (x + y) - y = x
    if a.resolve() is add(args) then if args.b == b then return args.a
  }
  case multiply(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a * b)

    | 1 * x = x
    if a.resolve() is int(a) then if a == 1 then return b

    | x * 1 = x
    if b.resolve() is int(b) then if b == 1 then return a
  }
  case divide(args) {
    var a = args.a
    var b = args.b

    | Constant fold crash.
    if b.resolve() is int(b) then if b == 0 then
      return builder.crash(builder.string("divide by zero"), type_int)

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a / b)

    | x / 1 = x
    if b.resolve() is int(b) then if b == 1 then return a
  }
  case modulo(args) {
    var a = args.a
    var b = args.b

    | Constant fold crash.
    if b.resolve() is int(b) then if b == 0 then
      return builder.crash(builder.string("modulo by zero"), type_int)

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a % b)

    | x % 1 = 0
    if b.resolve() is int(b) then if b == 1 then return builder.int(0)
  }
  case and_(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a & b)

    | 0 & x = 0
    if a.resolve() is int(a) then if a == 0 then return builder.int(0)
  
    | x & 0 = 0
    if b.resolve() is int(b) then if b == 0 then return builder.int(0)

    | -1 & x = x
    if a.resolve() is int(a) then if a == -1 then return b

    | x & -1 = x
    if b.resolve() is int(b) then if b == -1 then return a
  }
  case or_(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(or(a, b))

    | 0 or x = x
    if a.resolve() is int(a) then if a == 0 then return b
  
    | x or 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | -1 or x = -1
    if a.resolve() is int(a) then if a == -1 then return builder.int(-1)
  
    | x or -1 = -1
    if b.resolve() is int(b) then if b == -1 then return builder.int(-1)
  }
  case xor(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a ^ b)
    
    | x xor x = 0
    if a == b then return builder.int(0)
  }
  case compare(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.enum_(
        type_ordering,
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater",
        builder.nothing()
      )

    | compare(x, x) == equals
    if a == b then
      return builder.enum_(type_ordering, "equal", builder.nothing())

    | compare((x - y), 0) = compare(x, y)
    if a.resolve() is subtract(sub) then if b.resolve() is int(b) then
      if b == 0 then return builder.compare(sub.a, sub.b)
    
    | Note: Because add and subtract wrap around, we can't optimize something
    | like compare(x + 1, x) to greater.
  }
  case unbox(box) {
    | unbox(box(x)) = x
    if box.resolve() is box(inner) then return inner
  }
  case unchecked_generate_non_empty_array(args) {
    | For small arrays, specialize and constant fold the generator for each
    | index.
    |
    | a = int 4
    | ----------------------------------------------------------
    | unchecked_generate_non_empty_array a  |  b = multiply 0 0
    |   generator b:                        |  c = multiply 1 1
    |     c = multiply b b                  |  d = multiply 2 2
    |     c                                 |  e = multiply 3 3
    |                                       |  f = array b c d e
    if args.length.resolve() is int(length) then if length <= 10 then {
      var items = list[EggId]()
      for index in 0..length do
        items.&.push(args.generator.fill(builder.int(index), builder))
      return builder.array(items.to_slice(), args.generator.returns.type())
    }

    | Hoist expressions (even potentially crashing ones) out of the generator as
    | long as they don't depend on the index or hoisting would change the order
    | of potentially crashing expressions.
    var hoisted = args.generator.hoist_from_body_running_at_least_once()
    if hoisted.hoisted.is_not_empty() then {
      for id in hoisted.hoisted do builder.push(id)
      return builder.unchecked_generate_non_empty_array(
        args.length, hoisted.body
      )
    }
  }
  case unchecked_array_get(args) {
    | Constant fold.
    if args.array.resolve() is array(array) then
      if args.index.resolve() is int(index) then
        return if (0..array.items.len).contains(index) then
          array.items.get(index)
        else
          builder.unreachable(array.item_type)
  }
  case unchecked_array_set(args) {
    | Constant fold.
    if args.array.resolve() is array(array) then
      if args.index.resolve() is int(index) then
        return if (0..array.items.len).contains(index) then {
          var new_items = list[EggId]()
          for item in array.items do new_items.&.push(item)
          new_items.&.set(index, args.item)
          builder.array(new_items.to_slice(), array.item_type)
        } else
          builder.unreachable(type_array(array.item_type))
  }
  case unchecked_array_slice(args) {
    var start = args.start
    var end = args.end

    | Note: We intentionally do not constant-fold array slices of array literals
    | into new array literals, even though this would be a correct
    | transformation. In some scenarios, such as when the original array is
    | never used again, this transformation makes sense.
    | However, because the newly created array literal has a completely new
    | identity and is not related to the original array, this prevents other
    | important optimizations such as fixpoint analysis.

    switch args.array.resolve()
    | case array(array) {
    |   | Constant fold.
    |   if start.resolve() is int(start) then if end.resolve() is int(end) then
    |     return
    |       if (0..array.items.len).contains(start)
    |         and (0..=array.items.len).contains(end)
    |         and start <= end
    |       then builder.array(array.items.subslice(start..end), array.item_type)
    |       else builder.unreachable(type_array(array.item_type))
    | }
    case unchecked_array_slice(inner_args)
      | Merge the two nested slice operations into one.
      return builder.unchecked_array_slice(
        inner_args.array,
        builder.add(inner_args.start, args.start),
        builder.add(inner_args.start, args.end),
      )
    default {}
  }
  case array_len(array) {
    switch array.resolve()
    case array(array)
      | Constant fold.
      return builder.int(array.items.len)
    case generate_array(gen)
      | length(generate_array(length, generator)) = length
      return gen.length
    case unchecked_generate_non_empty_array(gen)
      | length(unchecked_generate_non_empty_array(length, generator)) = length
      return gen.length
    case array_slice(args)
      | length(array_slice(array, start, end)) = end - start
      return builder.subtract(args.end, args.start)
    case unchecked_array_slice(args)
      | length(unchecked_array_slice(array, start, end)) = end - start
      return builder.subtract(args.end, args.start)
    default {}
  }
  case string(string) {
    var bytes = list[EggId]()
    for byte in string.bytes() do bytes.&.push(builder.byte(byte))
    return builder.struct_(map(
      "utf8_bytes" -> builder.array(bytes.to_slice(), type_byte),
    ))
  }
  case loop_(loop_) {
    | Remove the loop if the body doesn't continue, but just runs through to
    | completion.
    if not(loop_.body.contains_continue())
      then return loop_.body.fill(loop_.initial, builder)

    | Find fixpoint.
    var fixpoint = loop_.find_fixpoint(optimize)
    if not(fixpoint.is_trivial()) then {
      var dehydrated_initial = fixpoint.dehydrate(loop_.initial, builder)
      var new_body = {
        var builder = egg_body_builder().&
        var dehydrated_params = {
          var res = list[EggId]()
          for d in dehydrated_initial do res.&.push(builder.param(d.type()))
          res.to_slice()
        }
        var rehydrated = fixpoint.hydrate(dehydrated_params, builder)
        builder.finish(loop_.body.fill(rehydrated, builder))
      } .optimize_without_inlining()
        .replace_continues(fixpoint)
      return builder.loop_(dehydrated_initial, new_body)
    }

    | TODO:
    | Hoist expressions indepdent of the loop variables out of the loop.
    | var hoisted = rec.body.hoist_from_body_running_at_least_once()
    | if hoisted.hoisted.is_not_empty() then {
    |   for id in hoisted.hoisted do builder.push(id)
    |   return builder.recursive(rec.initial, hoisted.body)
    | }

    | TODO: loop without variables? remove and turn recurse into "halt" expressions
  }
  | case recurse(args) {
  |   | Push recurse into switch cases.
  |   if args.len == 1 then if args.get(0).resolve() is switch_(switch_) then {
  |     return switch_(switch_.condition.resolve(), type, {
  |       var cases = map[String, EggBody]()
  |       for case_ in switch_.cases do
  |         cases.&.put(
  |           case_.key,
  |           EggBody {
  |             params = case_.value.params,
  |             expr = recurse(list(case_.value.expr).to_slice(), type)
  |               
  |           }
  |         )
  |       cases
  |     })
  |   }
  | }
  default {}

  builder.push(id)
}

| fun recurses(body: EggBody): Bool {
|   for child in body.children do if child.recurses() then return true
|   false
| }
| fun recurses(id: EggId): Bool {
|   switch id.resolve()
|   case recursive false
|   case recurse true
|   default {
|     for child in id.children() do if child.recurses() then return true
|     false
|   }
| }

fun children(id: EggId): Slice[EggId] {
  var children = list[EggId]()
  id.visit_children(GatherChildren { children = children.& })
  children.to_slice()
}
struct GatherChildren { children: &List[EggId] }
fun visit(id: EggId, gather: GatherChildren) { gather.children.push(id) }

| The number of expressions inside this expression.
fun num_exprs(body: EggBody): Int {
  var count = 0
  body.visit(CountExprs { count = count.& })
  count
}
struct CountExprs { count: &Int }
fun visit(id: EggId, counter: CountExprs) {
  counter.count += 1
  id.visit_children(counter)
}

| Converts calls to the given function into continue expressions.
fun call_to_continue_(body: EggBody, fun_: String, return_type: EggType): EggBody {
  body.map(CallToContinue { called = fun_, return_type }, map[EggId, EggId]().&)
}
struct CallToContinue { called: String, return_type: EggType }
fun map(
  id: EggId, mapper: CallToContinue,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mapper, mapping)
  if expr is call_fun(call) then
    if call.fun_ == mapper.called then
      return builder.continue_(call.args, mapper.return_type)
  builder.push(expr)
}

| Fills the body with concrete arguments for its parameters.
fun fill(body: EggBody, args: Slice[EggId], builder: &EggBodyBuilder): EggId {
  | eprintln("Filling\n")
  | stderr.write(body, namespace().&, indentation(1))
  | stderr."\nwith {args.debug()}\n"
  var mapping = map[EggId, EggId]().&
  for both in zip(body.params.iter(), args.iter()) do
    mapping.put(both.a, both.b)
  for old in body.children do {
    var new = old.map(Fill {}, builder, mapping)
    mapping.put(old, new)
  }
  body.returns.map(mapping.*)
}
fun fill(body: EggBody, arg: EggId, builder: &EggBodyBuilder): EggId {
  body.fill(list(arg).to_slice(), builder)
}
fun fill(body: EggBody, mapping: Map[EggId, EggId]): EggBody {
  var mapping = mapping.copy()
  body.map(Fill {}, mapping.&)
}
struct Fill {}
fun map(
  expr: EggId, fill: Fill, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]
): EggId {
  builder.push(expr.map_children(fill, mapping))
}

fun without_params(body: EggBody): EggBody {
  EggBody {
    params = empty_slice[EggId](),
    children = body.children,
    returns = body.returns,
  }
}

| fun replace_recurses_with_lambda(body: EggBody, params: Slice[EggId]): EggBody {
|   body.map(ReplaceRecursesWithLambda { params }, map[EggId, EggId]().&)
| }
| struct ReplaceRecursesWithLambda { params: Slice[EggId] }
| fun map(id: EggId, mapper: ReplaceRecursesWithLambda, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]): EggId {
|   var expr = id.map_children(mapper, mapping)
|   if expr is recurse(rec) then
|     builder.lambda({
|       var builder = egg_body_builder().&
|       for param in mapper.params do builder.params.&.push(param)
|       builder.finish(builder.recurse({
|         var args = list[EggId]()
|         for arg in rec.next do args.&.push(arg)
|         for param in mapper.params do args.&.push(param)
|         args.to_slice()
|       }, rec.type.kind().lambda.unwrap().return_type))
|     })
|   else
|     builder.push(expr)
| }
