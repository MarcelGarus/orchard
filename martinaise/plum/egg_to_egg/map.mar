import mod.mar

fun map[M](fun_: EggFun, mapper: M): EggFun {
  EggFun { body = fun_.body.map(mapper, map[EggId, EggId]().&) }
}

fallback fun map[M](
  body: EggBody, mapper: M, mapping: &Map[EggId, EggId]
): EggBody {
  body.map_children(mapper, mapping)
}

| TODO: keep param identities?
fun map_children[M](
  body: EggBody, mapper: M, mapping: &Map[EggId, EggId]
): EggBody {
  var builder = egg_body_builder().&
  for param in body.params do
    mapping.put(param, param.map(mapper, builder, mapping))
  for child in body.children do {
    var mapped = child.map(mapper, builder, mapping)
    mapping.put(child, mapped)
  }
  builder.finish(body.returns.map(mapping.*))
}

fun map_children[M](
  id: EggId, mapper: M, mapping: &Map[EggId, EggId]
): EggExpr {
  switch id.resolve()
  case param(type) EggExpr.param(type)
  case case_param(param)
    EggExpr.case_param(EggCaseParam {
      switch_on = param.switch_on.map(mapping.*), variant = param.variant
    })
  case type(type) EggExpr.type(type)
  case int(int) EggExpr.int(int)
  case string(string) EggExpr.string(string)
  case struct_(struct_) {
    var fields = map[String, EggId]()
    for field in struct_ do fields.&.put(field.key, field.value.map(mapping.*))
    EggExpr.struct_(fields)
  }
  case enum_(enum_)
    EggExpr.enum_(EggEnum {
      type = enum_.type,
      variant = enum_.variant,
      payload = enum_.payload.map(mapping.*),
    })
  case inline_lambda(body) EggExpr.inline_lambda(body.map(mapper, mapping))
  case raw_lambda(lambda)
    EggExpr.raw_lambda(EggRawLambda {
      fun_ = lambda.fun_,
      closure = lambda.closure.map(mapping.*),
      type = lambda.type,
    })
  case member(member)
    EggExpr.member(EggMember {
      of = member.of.map(mapping.*), name = member.name
    })
  case switch_(switch_) {
    var condition = switch_.condition.map(mapping.*)
    var cases = map[String, EggBody]()
    for case_ in switch_.cases do
      cases.&.put(case_.key, case_.value.map(mapper, mapping))
    EggExpr.switch_(EggSwitch { condition, cases })
  }
  case call_fun(call)
    EggExpr.call_fun(EggCallFun {
      fun_ = call.fun_,
      substitutions = call.substitutions,
      args = call.args.map(mapping.*),
      return_type = call.return_type,
    })
  case call_lambda(call)
    EggExpr.call_lambda(EggCallLambda {
      lambda = call.lambda.map(mapping.*), args = call.args.map(mapping.*)
    })
  case call_builtin(call)
    EggExpr.call_builtin(EggCallBuiltin {
      builtin = call.builtin,
      substitutions = call.substitutions,
      args = call.args.map(mapping.*),
    })
  case cast(cast)
    EggExpr.cast(EggCast { what = cast.what.map(mapping.*), type = cast.type })
  case byte(byte) EggExpr.byte(byte)
  case lower_byte(arg) EggExpr.lower_byte(arg.map(mapping.*))
  case byte_to_int(arg) EggExpr.byte_to_int(arg.map(mapping.*))
  case add(args) EggExpr.add(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case subtract(args)
    EggExpr.subtract(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case multiply(args)
    EggExpr.multiply(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case divide(args)
    EggExpr.divide(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case modulo(args)
    EggExpr.modulo(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case and_(args) EggExpr.and_(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case or_(args) EggExpr.or_(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case xor(args) EggExpr.xor(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case compare(args)
    EggExpr.compare(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case unchecked_divide(args)
    EggExpr.unchecked_divide(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case unchecked_modulo(args)
    EggExpr.unchecked_modulo(tuple(args.a.map(mapping.*), args.b.map(mapping.*)))
  case box(arg) EggExpr.box(arg.map(mapping.*))
  case unbox(arg) EggExpr.unbox(arg.map(mapping.*))
  case array(array)
    EggExpr.array(EggArray {
      items = array.items.map(mapping.*), item_type = array.item_type
    })
  case generate_array(args)
    EggExpr.generate_array(EggGenerateArray {
      length = args.length.map(mapping.*),
      generator = args.generator.map(mapper, mapping),
    })
  case array_get(args)
    EggExpr.array_get(EggArrayGet {
      array = args.array.map(mapping.*), index = args.index.map(mapping.*)
    })
  case array_set(args)
    EggExpr.array_set(EggArraySet {
      array = args.array.map(mapping.*),
      index = args.index.map(mapping.*),
      item = args.item.map(mapping.*),
    })
  case array_slice(args)
    EggExpr.array_slice(EggArraySlice {
      array = args.array.map(mapping.*),
      start = args.start.map(mapping.*),
      end = args.end.map(mapping.*),
    })
  case array_len(arg) EggExpr.array_len(arg.map(mapping.*))
  case unchecked_generate_non_empty_array(args)
    EggExpr.unchecked_generate_non_empty_array(EggGenerateArray {
      length = args.length.map(mapping.*),
      generator = args.generator.map(mapper, mapping),
    })
  case unchecked_array_get(args)
    EggExpr.unchecked_array_get(EggArrayGet {
      array = args.array.map(mapping.*), index = args.index.map(mapping.*)
    })
  case unchecked_array_set(args)
    EggExpr.unchecked_array_set(EggArraySet {
      array = args.array.map(mapping.*),
      index = args.index.map(mapping.*),
      item = args.item.map(mapping.*),
    })
  case unchecked_array_slice(args)
    EggExpr.unchecked_array_slice(EggArraySlice {
      array = args.array.map(mapping.*),
      start = args.start.map(mapping.*),
      end = args.end.map(mapping.*),
    })
  case type_info(arg) EggExpr.type_info(arg.map(mapping.*))
  case static_to_dynamic(arg) EggExpr.static_to_dynamic(arg.map(mapping.*))
  case dynamic_to_static(convert)
    EggExpr.dynamic_to_static(EggDynamicToStatic {
      dynamic = convert.dynamic.map(mapping.*), static = convert.static
    })
  case crash(crash)
    EggExpr.crash(EggCrash {
      message = crash.message.map(mapping.*), type = crash.type
    })
  case unreachable(type) EggExpr.unreachable(type)
  case loop_(loop_)
    EggExpr.loop_(EggLoop {
      initial = loop_.initial.map(mapping.*), body = loop_.body.map(mapper, mapping)
    })
  case continue_(continue_)
    EggExpr.continue_(EggContinue {
      next = continue_.next.map(mapping.*), type = continue_.type
    })
  case dup(dup)
    EggExpr.dup(EggDup { id = dup.id.map(mapping.*), type = dup.type })
  case drop(drop)
    EggExpr.drop(EggDrop { id = drop.id.map(mapping.*), type = drop.type })
  case pesto_param(type) EggExpr.pesto_param(type)
  case function_ptr(signature) EggExpr.function_ptr(signature)
  case pesto_call_fun(call)
    EggExpr.pesto_call_fun(EggPestoCallFun {
      fun_ = call.fun_,
      args = call.args.map(mapping.*),
      return_type = call.return_type,
    })
  case call_indirect(call)
    EggExpr.call_indirect(EggCallIndirect {
      function_ptr = call.function_ptr.map(mapping.*),
      args = call.args.map(mapping.*),
      return_type = call.return_type,
    })
  case new(id) EggExpr.new(id.map(mapping.*))
  case load(load)
    EggExpr.load(EggLoad { ptr = load.ptr.map(mapping.*), type = load.type })
  case free(free)
    EggExpr.free(EggFree { ptr = free.ptr.map(mapping.*), type = free.type })
  case get_refcount(ptr) EggExpr.get_refcount(ptr.map(mapping.*))
  case set_refcount(set)
    EggExpr.set_refcount(EggSetRefcount {
      ptr = set.ptr.map(mapping.*), refcount = set.refcount.map(mapping.*)
    })
  case new_buffer(new_buffer)
    EggExpr.new_buffer(EggNewBuffer {
      item_type = new_buffer.item_type, length = new_buffer.length.map(mapping.*)
    })
  case get_buffer_length(arg) EggExpr.get_buffer_length(arg.map(mapping.*))
  case load_buffer_item(load)
    EggExpr.load_buffer_item(EggLoadBufferItem {
      buffer = load.buffer.map(mapping.*),
      item_type = load.item_type,
      index = load.index.map(mapping.*),
    })
  case store_buffer_item(store)
    EggExpr.store_buffer_item(EggStoreBufferItem {
      buffer = store.buffer.map(mapping.*),
      item_type = store.item_type,
      index = store.index.map(mapping.*),
      item = store.item.map(mapping.*),
    })
  case store_buffer_bytes(store)
    EggExpr.store_buffer_bytes(EggStoreBufferBytes {
      buffer = store.buffer.map(mapping.*), bytes = store.bytes
    })
  case free_buffer(free)
    EggExpr.free_buffer(EggFreeBuffer {
      buffer = free.buffer.map(mapping.*), item_type = free.item_type
    })  
  case pesto_crash(crash)
    EggExpr.pesto_crash(EggPestoCrash {
      message = crash.message.map(mapping.*), type = crash.type
    })
  case pesto_unreachable(type) EggExpr.pesto_unreachable(type)
  case pesto_continue(continue_)
    EggExpr.pesto_continue(EggPestoContinue {
      next = continue_.next.map(mapping.*), type = continue_.type
    })
}

fun map(id: EggId, mapping: Map[EggId, EggId]): EggId {
  mapping.get_maybe(id) or id
}
fun map(ids: Slice[EggId], mapping: Map[EggId, EggId]): Slice[EggId] {
  var new = list[EggId]()
  for old in ids do new.&.push(old.map(mapping))
  new.to_slice()
}
fun map(
  tuple: Tuple2[EggId, EggId], mapping: Map[EggId, EggId]
): Tuple2[EggId, EggId] {
  tuple(tuple.a.map(mapping), tuple.b.map(mapping))
}
fun map(body: EggBody, mapping: Map[EggId, EggId]): EggBody {
  EggBody {
    params = body.params.map(mapping),
    children = body.children.map(mapping),
    returns = body.returns.map(mapping),
  }
}
