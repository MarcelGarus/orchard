import mod.mar

var type_cache = map[EggId, EggType]().put_on_heap()

fun type(id: EggId): EggType {
  if type_cache.get_maybe(id) is some(type) then return type
  var type = id.calculate_type()
  type_cache.put(id, type)
  type
}
fun calculate_type(id: EggId): EggType {
  switch id.resolve()
  case param(param) param.type
  case case_param(param)
    param.switch_on.type().plum().enum_.unwrap("case param of non-enum")
      .get(param.variant)
  case type type_type
  case int type_int
  case string type_string
  case struct_(fields) {
    var field_types = map[String, EggType]()
    for field in fields do field_types.&.put(field.key, field.value.type())
    type_struct(field_types)
  }
  case enum_(enum_) enum_.type
  case inline_lambda(body) {
    var param_types = list[EggType]()
    for param in body.params do param_types.&.push(param.type())
    type_lambda(param_types.to_slice(), body.returns.type())
  }
  case raw_lambda(lambda) lambda.type
  case member(member) {
    var of_type = member.of.type()
    if of_type.contains_recursion() then
      of_type.plum().struct_.unwrap("member  of non-struct").get(member.name)
    else
      of_type.pesto().struct_.unwrap("member of non-struct").get(member.name)
  }
  case switch_(switch_)
    switch_.cases.iter().&.next().unwrap("switch with no cases")
      .value.returns.type()
  case call_generic_fun(call) call.return_type
  case call_fun(call) call.return_type
  case call_lambda(call)
    call.lambda.type().plum().lambda.unwrap("calling non-lambda").return_type
  case call_builtin(call)
    call.builtin.type_signature().return_type.specialize(call.substitutions)
  case cast(cast) cast.type
  case byte type_byte
  case lower_byte type_byte
  case byte_to_int type_int
  case add type_int
  case subtract type_int
  case multiply type_int
  case divide type_int
  case modulo type_int
  case compare type_ordering
  case compare_zero type_ordering
  case and_ type_int
  case or_ type_int
  case xor type_int
  case shift_left type_int
  case shift_right type_int
  case unchecked_divide type_int
  case unchecked_modulo type_int
  case box(arg) type_box(arg.type())
  case unbox(arg) arg.type().plum().box.unwrap("unbox of non-box")
  case array(array) type_array(array.item_type)
  case generate_array(args) type_array(args.generator.returns.type())
  case array_get(args)
      args.array.type().plum().array.unwrap("array_get of non-array")
  case array_set(args) args.array.type()
  case array_slice(args) args.array.type()
  case array_len type_int
  case unchecked_generate_non_empty_array(args)
    type_array(args.generator.returns.type())
  case unchecked_array_get(args)
    args.array.type().plum().array.unwrap("unchecked_array_get of non-array")
  case unchecked_array_set(args) args.array.type()
  case unchecked_array_slice(args) args.array.type()
  case type_info type_type_info
  case static_to_dynamic type_dynamic
  case dynamic_to_static(args) args.static
  case crash(crash) crash.type
  case raw_crash type_never
  case unreachable(type) type
  case loop_(loop_) loop_.body.returns.type()
  case continue_(continue_) continue_.type
  case dup type_nothing
  case drop type_nothing
  case fun_ptr type_ptr
  case call_indirect(call) call.return_type
  case null_ptr type_ptr
  case object_new(id) type_ptr
  case object_load(load) load.type
  case object_free(free) type_nothing
  case get_refcount type_int
  case set_refcount type_nothing
  case new_buffer type_ptr
  case get_buffer_length type_int
  case load_buffer_item(load) load.item_type
  case store_buffer_item type_nothing
  case store_buffer_bytes type_nothing
  case free_buffer type_nothing
  case padding(amount) type_bytes(MemoryLayout { size = amount, alignment = 1 })
  case aggregate(parts) {
    var size = 0
    var alignment = 1
    for part in parts do {
      var layout = part.type().memory_layout()
      size = size + layout.size
      alignment = max(alignment, layout.alignment)
    }
    type_bytes(MemoryLayout { size, alignment })
  }
  case part(part) type_bytes(part.layout)
  case switch_on_byte(switch_) switch_.cases.get(0).returns.type()
  case malloc type_ptr
  case free type_nothing
  case load(load) type_bytes(load.layout)
  case store type_nothing
  case store_bytes type_nothing
  case load_word type_int
  case load_byte type_byte
  case store_word type_nothing
  case store_byte type_nothing
  default unreachable("tried to get type of {id.resolve().debug()}")
}
