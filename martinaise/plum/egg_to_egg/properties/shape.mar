| Something we know about the shape of an expression. Sorted roughly from
| highest to lowest quality (this is not a total ordering, so some order is
| arbitrary).
| 
|            id
|       ___//  \\___
|    __/   /    \   \___
|   /     /      \      \
|  |     |       |       |
| int  struct  lambda  array
|  |     |       |     slice
|   \     \     /        |
|    \____ \   /________/
|          \\ //
|           hole

import mod.mar

enum Shape {
  self: EggId, | Only exists temporarily while figuring out the return shape of recursive functions.
  id: EggId, | We know the exact expression.
  int: Int,
  struct_: ShapeStruct,
  enum_: ShapeEnum,
  | box: &Shape, TODO
  array_slice: ShapeArraySlice,
  hole: EggType, | We know nothing about the expression.
}
struct ShapeStruct { fields: Map[String, Shape], type: EggType }
struct ShapeEnum { variants: Map[String, Shape], type: EggType }
struct ShapeArraySlice { array: EggId, start: &Shape, end: &Shape }

fun ==(a: Shape, b: Shape): Bool {
  switch a
  case self(a)        if b is self(b)        then a == b else false
  case id(a)          if b is id(b)          then a == b else false
  case int(a)         if b is int(b)         then a == b else false
  case struct_(a)     if b is struct_(b)     then a == b else false
  case enum_(a)       if b is enum_(b)       then a == b else false
  case array_slice(a) if b is array_slice(b) then a == b else false
  case hole(a)        if b is hole(b)        then a == b else false
}
fun ==(a: ShapeStruct, b: ShapeStruct): Bool {
  a.fields == b.fields and a.type == b.type
}
fun ==(a: ShapeEnum, b: ShapeEnum): Bool {
  a.variants == b.variants and a.type == b.type
}
fun ==(a: ShapeArraySlice, b: ShapeArraySlice): Bool {
  a.array == b.array and a.start.* == b.start.* and a.end.* == b.end.*
}

fun write[W](writer: W, shape: Shape) {
  switch shape
  case self writer."(self)"
  case id(id) writer."(id:{id.id.index.debug()})"
  case int(int) writer."(int {int})"
  case struct_(struct_) {
    writer."(&"
    for field in struct_.fields do writer." {field.key}: {field.value}"
    writer.")"
  }
  case enum_(enum_) {
    writer."(|"
    for variant in enum_.variants do writer." {variant.key}: {variant.value}"
    writer.")"
  }
  case array_slice(slice)
    writer."(slice {slice.array.id.index.debug()} {slice.start.*} {slice.end.*})"
  case hole writer."(?)"
}

fun type(shape: Shape): EggType {
  switch shape
  case self(self) self.type()
  case id(id) id.type()
  case int type_int
  case struct_(struct_) struct_.type
  case enum_(enum_) enum_.type
  case array_slice(slice) type_array(slice.array.type())
  case hole(type) type
}

| Returns the shape of an ID (not Shape.id, but something less precise).
fun shape(id: EggId): Shape {
  switch id.resolve()
  case case_param(param) {
    if param.switch_on.shape() is enum_(enum_shape) then
      if enum_shape.variants.get_maybe(param.variant) is some(shape) then
        return shape
    Shape.hole(id.type())
  }
  case struct_(struct_) {
    var fields = map[String, Shape]()
    for field in struct_ do fields.&.put(field.key, Shape.id(field.value))
    Shape.struct_(ShapeStruct { fields, type = id.type() })
  }
  case member(member)
    if member.of.shape() is struct_(struct_) then
      struct_.fields.get(member.name)
    else
      Shape.hole(id.type())
  case enum_(enum_)
    Shape.enum_(ShapeEnum {
      variants = map(enum_.variant -> enum_.payload.shape()),
      type = id.type(),
    })
  case switch_(switch_) {
    var shapes = list[Shape]()
    for case_ in switch_.cases do
      shapes.&.push(case_.value.returns.shape())
    if shapes.is_empty() then return Shape.hole(id.type())
    var common = shapes.get(0)
    for shape in shapes.to_slice().without_first() do
      common = merge(common, shape)
    common
  }
  case call_fun(call) Shape.hole(call.return_type)
  case array(array)
    Shape.array_slice(ShapeArraySlice {
      array = id,
      start = Shape.int(0).put_on_heap(),
      end = Shape.int(array.items.len).put_on_heap(),
    })
  case unchecked_array_slice(slice)
    Shape.array_slice(ShapeArraySlice {
      array = slice.array,
      start = Shape.id(slice.start).put_on_heap(),
      end = Shape.id(slice.end).put_on_heap(),
    })
  default Shape.hole(id.type())
}

fun merge(a: Shape, b: Shape): Shape {
  | eprintln("  Merging {a} and {b}")
  if a is self then return b
  if b is self then return a
  if a is id(a_id) then
    if b is id(b_id) then if a_id == b_id then return Shape.id(a_id)
  if a is id(a_id) then return merge(a_id.shape(), b)
  if b is id(b_id) then return merge(a, b_id.shape())
  if a is int(a_int) then
    if b is int(b_int) then if a_int == b_int then return a
  if a is struct_(a_struct) then
    if b is struct_(b_struct) then
      return Shape.struct_(merge(a_struct, b_struct))
  if a is enum_(a_enum) then
    if b is enum_(b_enum) then
      return Shape.enum_(merge(a_enum, b_enum))
  if a is array_slice(a_slice) then
    if b is array_slice(b_slice) then
      if merge(a_slice, b_slice) is some(merged) then
        return Shape.array_slice(merged)
  Shape.hole(a.type())
}
fun merge(a: Slice[Shape], b: Slice[Shape]): Slice[Shape] {
  var merged = list[Shape]()
  for both in zip(a.iter(), b.iter()) do
    merged.&.push(merge(both.a, both.b))
  merged.to_slice()
}

fun merge(a: ShapeStruct, b: ShapeStruct): ShapeStruct {
  var fields = map[String, Shape]()
  for field in a.fields do
    fields.&.put(field.key, merge(field.value, b.fields.get(field.key)))
  ShapeStruct { fields, type = a.type }
}

fun merge(a: ShapeEnum, b: ShapeEnum): ShapeEnum {
  var variants = map[String, Shape]()
  for variant in a.variants do variants.&.put(variant.key, variant.value)
  for variant in b.variants do
    variants.&.put(
      variant.key,
      if variants.get_maybe(variant.key) is some(a_payload) then
        merge(a_payload, variant.value)
      else
        variant.value
    )
  ShapeEnum { variants, type = a.type }
}

fun merge(a: ShapeArraySlice, b: ShapeArraySlice): Maybe[ShapeArraySlice] {
  if a.array != b.array then return none[ShapeArraySlice]()
  some(ShapeArraySlice {
    array = a.array,
    start = merge(a.start.*, b.start.*).put_on_heap(),
    end = merge(a.end.*, b.end.*).put_on_heap(),
  })
}
