import mod.mar

fun merge_switch_chains(body: EggBody): EggBody {
  var num_references = body.count_references()
  |eprintln("{num_references.debug()}")

  var builder = egg_body_builder().&
  for param in body.params do builder.push(param)
  for i in 0..{body.children.len - 1} do {
    var a = body.children.get(i)
    var b = body.children.get(i + 1)

    switch try_merging_switches(a, b, num_references, builder)
    case error builder.push(a)
    case ok(merged) {
      | eprintln("todo: merged switches {a.debug()} and {b.debug()} into {merged.debug()}")
      var mapping = map(b -> merged).&
      | eprintln("original ids: {body.children.debug()}. i = {i}")
      for id in body.children.without_first(i + 2) do
        mapping.put(id, builder.push(id.map_children(Fill {}, mapping)))
      return builder.finish(body.returns.map(mapping.*))
    }
  }

  body
}
fun try_merging_switches(
  a: EggId, b: EggId, num_references: Map[EggId, Int], builder: &EggBodyBuilder
): Result[EggId, Nothing] {
  var not_possible = error[EggId, Nothing]({})

  var a_switch = a.resolve().switch_ or return not_possible
  var b_switch = b.resolve().switch_ or return not_possible

  b_switch.condition == a or return not_possible
  {num_references.get_maybe(a) or 0} == 1 or return not_possible

  | Make sure that every case of the first switch refers to a different case of
  | the second switch.
  var reached_cases_of_second = set[String]()
  for case_ in a_switch.cases do
    if not(case_.value.definitely_diverges_biased()) then {
      var maps_to = {case_.value.returns.resolve().enum_ or return not_possible}
        .variant
      if reached_cases_of_second.contains(maps_to) then return not_possible
      reached_cases_of_second.&.put(maps_to)
    }

  |eprintln("todo: merge:")
  |stderr.write(a, namespace().&, indentation(1))
  |stderr."\n"
  |stderr.write(b, namespace().&, indentation(1))
  |stderr."\n"

  var cases = map[String, EggBody]()
  for a_case in a_switch.cases do {
    var builder = egg_body_builder().&
    var a_payload = builder.case_param(a_switch.condition, a_case.key)
    var a_result = a_case.value.fill(a_payload, builder)
    var total_result =
      if a_case.value.definitely_diverges_biased() then {
        builder.unreachable(b.type())
      } else {
        var a_result = a_result.resolve().enum_.unwrap()
        var b_case = b_switch.cases.get(a_result.variant)
        var b_payload = a_result.payload
        var b_result = b_case.fill(b_payload, builder)
        b_result
      }
    var body = builder.finish(total_result)
    cases.&.put(a_case.key, body)
  }
  var merged = builder.switch_(a_switch.condition, cases)

  ok[EggId, Nothing](merged)
}
