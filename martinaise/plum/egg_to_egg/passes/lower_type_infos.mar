import mod.mar

fun lower_type_infos(id: EggId, builder: &EggBodyBuilder): EggId {
  var type = id.resolve().type_info or return id
  builder.type_info_expr(type.resolve().type.unwrap()) | TODO: what if it's not comptime?
}

fun type_info_expr(builder: &EggBodyBuilder, type: EggType): EggId {
  var variant_and_payload =
    switch type.plum_not_extended()
    case variable panic("not monomorphized yet")
    case byte tuple("byte", builder.nothing())
    case int tuple("int", builder.nothing())
    case type tuple("type", builder.nothing())
    case box(inner_type) tuple("box", builder.type_info_expr(inner_type))
    case array(item_type) tuple("array", builder.type_info_expr(item_type))
    case never tuple("never", builder.nothing())
    case struct_(struct_)
      tuple(
        "struct",
        builder.array({
          var fields = list[EggId]()
          for field in struct_ do
            fields.&.push(builder.struct_(map(
              "name" -> builder.desugared_string(field.key),
              "type" -> builder.type_info_expr(field.value),
            )))
          fields.to_slice()
        }, type_type_info_fields),
      )
    case enum_(enum_)
      tuple(
        "enum",
        builder.array({
          var variants = list[EggId]()
          for variant in enum_ do
            variants.&.push(builder.struct_(map(
              "name" -> builder.desugared_string(variant.key),
              "type" -> builder.type_info_expr(variant.value),
            )))
            variants.to_slice()
        }, type_type_info_variants),
      )
    case lambda(lambda)
      tuple(
        "lambda",
        builder.struct_(map(
          "arguments" -> builder.array({
            var args = list[EggId]()
            for arg in lambda.args do args.&.push(builder.type_info_expr(arg))
            args.to_slice()
          }, type_type_info_lambda_args),
          "return_type" -> builder.type_info_expr(lambda.return_type),
        )),
      )
    case recursive(level) tuple("recursive", builder.int(level))

  builder.enum_(type_type_info, variant_and_payload.a, variant_and_payload.b)
}
