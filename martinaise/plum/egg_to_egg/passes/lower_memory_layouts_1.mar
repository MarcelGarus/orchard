| High-Level Memory Layouting  
|
| Here, we decide on high-level memory layouts: We decide which data is
| allocated together, where we have pointer indirections, and how we dup and
| drop the types.
|
| TODO: this is aspirational
| Never               -> Never
| Byte                -> Byte
| Int                 -> Int
| & foo: Foo bar: Bar -> if inhabitants(Foo * Bar) = 0: Never
|                        if inhabitants(Foo * Bar) > 0: & foo: Foo bar: Bar
| | foo: Foo bar: Bar -> | foo: Foo bar: Bar
| Box Foo             -> if inhabitants(Foo) = 0: Never
|                        if inhabitants(Foo) > 0:  Ptr
| Array Foo           -> if inhabitants(Foo) = 0: &
|                        if inhabitants(Foo) = 1: Int
|                        if inhabitants(Foo) > 1: & buffer: Ptr start: Int end: Int
| \ Foo Bar -> Baz    -> if inhabitants(Foo * Bar) = 0: &
|                        if inhabitants(Foo * Bar) > 0: & body: Ptr closure: Ptr free: Ptr

import mod.mar

fun lower_memory_layouts_1(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(LowerMemoryLayouts1 { funs = funs.& }))
  Egg { entry_point = egg.entry_point, funs }
}

struct LowerMemoryLayouts1 { funs: &Map[String, EggFun] }

fun map(
  body: EggBody, mapper: LowerMemoryLayouts1, mapping: &Map[EggId, EggId]
): EggBody {
  var builder = egg_body_builder().&
  for param in body.params do
    mapping.put(
      param,
      switch param.resolve()
      case param(type) builder.param(type.desugar_boxes_arrays_lambdas())
      case case_param(param)
        builder.case_param(param.switch_on.map(mapping.*), param.variant)
      default unreachable()
    )
  for child in body.children do {
    var mapped = child.map(mapper, builder, mapping)
    mapping.put(child, mapped)
  }
  builder.finish(body.returns.map(mapping.*))
}

fun map(
  id: EggId, mapper: LowerMemoryLayouts1,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  switch id.resolve()
  case dup(dup) {
    builder.desugared_dup(dup.id.map(mapping.*), dup.type)
    builder.nothing()
  }
  case drop(drop) {
    builder.desugared_drop(drop.id.map(mapping.*), drop.type, mapper.funs)
    builder.nothing()
  }
  case type builder.nothing()
  case enum_(enum_)
    builder.enum_(
      enum_.type.desugar_boxes_arrays_lambdas(),
      enum_.variant,
      enum_.payload.map(mapping.*)
    )
  case box(value) {
    if value.type().num_inhabitants() <= NumInhabitants.one then
      builder.null_ptr()
    else
      builder.object_new(value.map(mapping.*))
  }
  case unbox(box) {
    var box_type = box.type()
    var ptr = box.map(mapping.*)
    var inner_type = box_type.plum().box.unwrap()
    if inner_type.num_inhabitants() <= NumInhabitants.one then
      builder.construct_inhabitant(inner_type)
    else {
      var inner = builder.object_load(
        ptr, inner_type.desugar_boxes_arrays_lambdas()
      )
      builder.desugared_dup(inner, inner_type)
      builder.desugared_drop(ptr, box_type, mapper.funs)
      inner
    }
  }
  case array(array) {
    if array.items.len == 0 then
      return builder.struct_(map(
        "buffer" -> builder.null_ptr(),
        "start" -> builder.int(0),
        "end" -> builder.int(0),
      ))

    | Special case byte arrays.
    | TODO: do this later in the compilation
    var all_bytes = true
    for item in array.items do
      if not(item.resolve() is byte) then all_bytes = false
    if all_bytes then {
      var buffer = builder.new_buffer(type_byte, builder.int(array.items.len))
      var bytes = list[Byte]()
      for byte in array.items do bytes.&.push(byte.resolve().byte.unwrap())
      builder.store_buffer_bytes(buffer, bytes.to_slice())
      return builder.struct_(map(
        "buffer" -> buffer,
        "start" -> builder.int(0),
        "end" -> builder.int(array.items.len),
      ))
    }

    var item_type = id.type().plum().array.unwrap()
    var buffer = builder.new_buffer(
      item_type.desugar_boxes_arrays_lambdas(), builder.int(array.items.len)
    )
    for item in array.items.iter().enumerate() do
      builder.store_buffer_item(
        buffer,
        item.item.type().desugar_boxes_arrays_lambdas(),
        builder.int(item.index),
        item.item.map(mapping.*),
      )
    builder.struct_(map(
      "buffer" -> buffer,
      "start" -> builder.int(0),
      "end" -> builder.int(array.items.len),
    ))
  }
  case unchecked_generate_non_empty_array(gen) {
    var length = gen.length.map(mapping.*)
    var generator = gen.generator
    var item_type = generator.returns.type()
    var buffer = builder.new_buffer(
      item_type.desugar_boxes_arrays_lambdas(), length
    )
    builder.loop_(list(builder.int(0)).to_slice(), {
      var builder = egg_body_builder().&
      var cursor = builder.param(type_int)
      builder.finish(
        builder.switch_on_ordering(
          builder.compare(cursor, length),
          {
            var builder = egg_body_builder().&
            mapping.put(generator.params.get(0), cursor)
            for child in generator.children do
              mapping.put(child, child.map(mapper, builder, mapping))
            var item = generator.returns.map(mapping.*)
            builder.store_buffer_item(
              buffer, item_type.desugar_boxes_arrays_lambdas(), cursor, item
            )
            builder.finish(
              builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                type_nothing,
              )
            )
          },
          egg_body_builder().finish_with_nothing(),
          egg_body_builder().finish_with_unreachable(type_nothing),
        )
      )
    })
    builder.struct_(map(
      "buffer" -> buffer, "start" -> builder.int(0), "end" -> length
    ))
  }
  case array_len(array) {
    var array_type = array.type()
    var array = array.map(mapping.*)
    var length = builder.subtract(
      builder.member(array, "end"), builder.member(array, "start")
    )
    builder.desugared_drop(array, array_type, mapper.funs)
    return length
  }
  case unchecked_array_get(args) {
    var array_type = args.array.type()
    var item_type = array_type.plum().array.unwrap()
    var array = args.array.map(mapping.*)
    var index = args.index.map(mapping.*)
    var item = builder.load_buffer_item(
      builder.member(array, "buffer"),
      item_type.desugar_boxes_arrays_lambdas(),
      builder.add(builder.member(array, "start"), index),
    )
    builder.desugared_dup(item, item_type)
    builder.desugared_drop(array, array_type, mapper.funs)
    item
  }
  case unchecked_array_set(args) {
    var array_type = args.array.type()
    var item_type = array_type.plum().array.unwrap()
    var array = args.array.map(mapping.*)
    var index = args.index.map(mapping.*)
    var item = args.item.map(mapping.*)
    var buffer = builder.member(array, "buffer")
    var start = builder.member(array, "start")
    var end = builder.member(array, "end")

    | If the buffer's reference count is 1, we have exclusive ownership and can
    | mutate the buffer in place. Otherwise, we copy the part of the buffer that
    | this array points to, and then we set the item in that copy.
    var owned_array = builder.switch_on_ordering(
      builder.compare(builder.get_refcount(buffer), builder.int(1)),
      egg_body_builder().finish_with_unreachable(array_type),
      egg_body_builder().finish(array),
      {
        var builder = egg_body_builder().&
        var length = builder.subtract(end, start)
        var copy = builder.new_buffer(
          item_type.desugar_boxes_arrays_lambdas(), length
        )
        builder.decrement_refcount(buffer)
        builder.loop_(list(builder.int(0)).to_slice(), {
          var builder = egg_body_builder().&
          var cursor = builder.param(type_int)
          builder.finish(builder.switch_on_ordering(
            builder.compare(cursor, length),
            {
              var builder = egg_body_builder().&
              var item = builder.load_buffer_item(
                buffer,
                item_type.desugar_boxes_arrays_lambdas(),
                builder.add(start, cursor),
              )
              builder.store_buffer_item(
                copy, item_type.desugar_boxes_arrays_lambdas(), cursor, item
              )
              builder.finish(builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(), type_ptr
              ))
            },
            egg_body_builder().finish(copy),
            egg_body_builder().finish_with_unreachable(type_ptr),
          ))
        })
        builder.finish(builder.struct_(map(
          "buffer" -> copy, "start" -> builder.int(0), "length" -> length
        )))
      },
    )

    var offset = builder.add(start, index)
    var previous = builder.load_buffer_item(
      buffer, item_type.desugar_boxes_arrays_lambdas(), offset
    )
    builder.desugared_drop(previous, item_type, mapper.funs)
    builder.store_buffer_item(
      buffer, item_type.desugar_boxes_arrays_lambdas(), offset, item
    )
    owned_array
  }
  case array_slice(args) {
    var array = args.array.map(mapping.*)
    var start = args.start.map(mapping.*)
    var end = args.end.map(mapping.*)
    var old_start = builder.member(array, "start")
    builder.struct_(map(
      "buffer" -> builder.member(array, "buffer"),
      "start" -> builder.add(old_start, start),
      "end" -> builder.add(old_start, end),
    ))
  }
  case raw_lambda(lambda) {
    builder.struct_(map(
      "closure" -> lambda.closure.map(mapping.*),
      "body" -> builder.function_ptr(lambda.fun_),
      "free" -> builder.function_ptr(
        free_box_fun(lambda.closure.type().plum().box.unwrap(), mapper.funs)
      ),
    ))
  }
  case call_fun(call)
    builder.call(
      call.fun_,
      call.args.map(mapping.*),
      call.return_type.desugar_boxes_arrays_lambdas(),
    )
  case call_lambda(call) {
    var lambda = call.lambda.map(mapping.*)
    builder.call_indirect(
      builder.member(lambda, "body"),
      {
        call.args.map(mapping.*).to_list()
          + list(builder.member(lambda, "closure"))
      }.to_slice(),
      call.lambda.type().plum().lambda.unwrap().return_type
        .desugar_boxes_arrays_lambdas(),
    )
  }
  case crash(crash)
    builder.crash(
      crash.message.map(mapping.*), crash.type.desugar_boxes_arrays_lambdas()
    )
  case unreachable(type)
    builder.unreachable(type.desugar_boxes_arrays_lambdas())
  case halt(type)
    builder.halt(type.desugar_boxes_arrays_lambdas())
  case continue_(continue_)
    builder.continue_(
      continue_.next.map(mapping.*), continue_.type.desugar_boxes_arrays_lambdas()
    )
  default builder.push(id.map_children(mapper, mapping))
}

fun desugar_boxes_arrays_lambdas(type: EggType): EggType {
  switch type.internal_kind()
  case variable unreachable()
  case never type_never
  case byte type_byte
  case int type_int
  case type type_type
  case box(inner) type_ptr
  case array(item)
    type_struct(map(
      "buffer" -> type_ptr, "start" -> type_int, "end" -> type_int
    ))
  case struct_(struct_) {
    var fields = map[String, EggType]()
    for field in struct_ do
      fields.&.put(field.key, field.value.desugar_boxes_arrays_lambdas())
    type_struct(fields)
  }
  case enum_(enum_) {
    var variants = map[String, EggType]()
    for variant in enum_ do
      variants.&.put(variant.key, variant.value.desugar_boxes_arrays_lambdas())
    type_enum(variants)
  }
  case lambda(lambda)
    type_struct(map(
      "closure" -> type_ptr, "body" -> type_ptr, "free" -> type_ptr
    ))
  case recursive(level) type_recursive(level)
  case ptr type_ptr
  case bytes unreachable()
}


| Traverses the value and dups all inner values. If it reaches a pointer, it
| just increments that pointer's reference count instead of traversing further.
fun desugared_dup(builder: &EggBodyBuilder, value: EggId, type: EggType) {
  | eprintln("dup {type}")
  if not(type.contains_ptr()) then return {}

  switch type.plum()
  case variable unreachable()
  case byte {}
  case int {}
  case type {}
  case box(inner_type)
    if inner_type.num_inhabitants() > NumInhabitants.one then
      builder.increment_refcount(value).ignore()
  case array {
    var buffer = builder.member(value, "buffer")
    builder.if_not_null_ptr(buffer, {
      var builder = egg_body_builder().&
      builder.finish(builder.increment_refcount(buffer))
    })
  }
  case never builder.unreachable(type_nothing).ignore()
  case struct_
    for field in type.plum().struct_.unwrap() do
      builder.desugared_dup(builder.member(value, field.key), field.value)
  case enum_ {
    var cases = map[String, EggBody]()
    for variant in type.plum().enum_.unwrap() do {
      var builder = egg_body_builder().&
      var payload = builder.case_param(value, variant.key)
      builder.desugared_dup(payload, variant.value)
      cases.&.put(variant.key, builder.finish_with_nothing())
    }
    builder.switch_(value, cases).ignore()
  }
  case lambda
    | TODO: handle null ptr
    builder.increment_refcount(builder.member(value, "closure")).ignore()
}

| Traverses the value and drops all inner values. If it reaches a pointer, it
| just decrements pointer's reference count instead of traversing further. If
| the reference count reaches zero, it drops the pointed-to value and frees the
| allocation.
fun desugared_drop(
  builder: &EggBodyBuilder, value: EggId, type: EggType,
  funs: &Map[String, EggFun],
) {
  if not(type.contains_ptr()) then return {}

  switch type.plum()
  case variable unreachable()
  case byte {}
  case int {}
  case type {}
  case box(inner_type)
    if inner_type.num_inhabitants() > NumInhabitants.one then
      builder.if_refcount_zero(builder.decrement_refcount(value), {
        var builder = egg_body_builder().&
        builder.call(
          free_box_fun(inner_type, funs), list(value).to_slice(), type_nothing
        )
        builder.finish_with_nothing()
      })
  case array(item_type) {
    var buffer = builder.member(value, "buffer")
    builder.if_not_null_ptr(buffer, {
      var builder = egg_body_builder().&
      var new_refcount = builder.decrement_refcount(buffer)
      builder.if_refcount_zero(new_refcount, {
        var builder = egg_body_builder().&
        builder.call(
          free_buffer_fun(item_type, funs),
          list(buffer).to_slice(),
          type_nothing,
        )
        builder.finish_with_nothing()
      })
      builder.finish_with_nothing()
    })
  }
  case never {}
  case struct_
    for field in type.plum().struct_.unwrap() do
      builder.desugared_drop(
        builder.member(value, field.key), field.value, funs
      )
  case enum_(variant_types) {
    var cases = map[String, EggBody]()
    for variant in variant_types do {
      var builder = egg_body_builder().&
      var payload = builder.case_param(value, variant.key)
      builder.desugared_drop(payload, variant.value, funs)
      cases.&.put(variant.key, builder.finish_with_nothing())
    }
    builder.switch_(value, cases).ignore()
  }
  case lambda {
    | TODO: handle null ptr
    var closure_ptr = builder.member(value, "closure")
    var new_refcount = builder.decrement_refcount(closure_ptr)
    builder.if_refcount_zero(new_refcount, {
      var builder = egg_body_builder().&
      var free_fun_ptr = builder.member(value, "free")
      builder.call_indirect(
        free_fun_ptr, list(closure_ptr).to_slice(), type_nothing
      )
      builder.finish_with_nothing()
    })
  }
}

| Expects a box with refcount 0. Drops the inner value and frees the allocation.
fun free_box_fun(inner_type: EggType, funs: &Map[String, EggFun]): String {
  var signature = "free (Box {inner_type})"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*)
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var box = builder.param(type_ptr)
      if inner_type.num_inhabitants() <= NumInhabitants.one then {
        | This function will never be called, as the box is always a null ptr.
        | We may still need to construct the free function as part of the ABI.
        | For example, if code returns a lambda, that lambda needs to have a
        | closure pointer, body pointer, and closure free pointer. If the lambda
        | doesn't capture any variables, the closure is empty and we save the
        | heap allocation, storing a null ptr instead. When you drop the lambda,
        | you have to check for null pointers. The function for freeing the
        | closure should never be called.
        builder.finish_with_unreachable(type_nothing)
      } else {
        var inner = builder.object_load(
          box, inner_type.desugar_boxes_arrays_lambdas()
        )
        builder.desugared_drop(inner, inner_type, funs)
        builder.object_free(box, inner_type.desugar_boxes_arrays_lambdas())
        builder.finish_with_nothing()
      }
    }
  })
  signature
}

| Expects an array with refcount 0. Drops the inner values and frees the
| allocation.
fun free_buffer_fun(item_type: EggType, funs: &Map[String, EggFun]): String {
  var signature = "drop (Buffer {item_type})"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*)
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var buffer = builder.param(type_ptr)
      var len = builder.get_buffer_length(buffer)

      builder.loop_(list(builder.int(0)).to_slice(), {
        var builder = egg_body_builder().&
        var cursor = builder.param(type_int)
        var cmp = builder.compare(cursor, len)
        builder.switch_on_ordering(
          cmp,
          egg_body_builder().finish_with_unreachable(type_nothing),
          egg_body_builder().finish_with_nothing(),
          {
            var builder = egg_body_builder().&
            var item = builder.load_buffer_item(
              buffer, item_type.desugar_boxes_arrays_lambdas(), cursor
            )
            builder.desugared_drop(item, item_type, funs)
            builder.finish(
              builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                type_nothing,
              )
            )
          },
        ).ignore()
        builder.finish_with_nothing()
      })

      builder.free_buffer(buffer, item_type.desugar_boxes_arrays_lambdas())
      builder.finish_with_nothing()
    }
  })
  signature
}

fun contains_ptr(type: EggType): Bool {
  switch type.pesto()
  case never false
  case byte false
  case int false
  case struct_(fields) {
    for field in fields do if field.value.contains_ptr() then return true
    false
  }
  case enum_(variants) {
    for variant in variants do if variant.value.contains_ptr() then return true
    false
  }
  case ptr true
}
