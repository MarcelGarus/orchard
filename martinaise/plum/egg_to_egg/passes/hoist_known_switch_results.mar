import mod.mar

fun hoist_known_switch_results(id: EggId, builder: &EggBodyBuilder): EggId {
  var switch_ = id.resolve().switch_ or return id

  | If all cases are either the same value that doesn't depend on parameters
  | or unreachable, replace the switch with that value.
  |
  | a = ...
  | ---------------------------------
  | switch a             |  int 3
  |   true b:            |
  |     c = unreachable  |
  |     c                |
  |   false d:           |
  |     e = int 3        |
  |     e                |
  var reachable_cases = list[MapEntry[String, EggBody]]()
  for case_ in switch_.cases do
    if not(case_.value.is_unreachable()) then reachable_cases.&.push(case_)
  if reachable_cases.is_empty() then return builder.unreachable(id.type())
  else if not(reachable_cases.get(0).value.uses_params()) then {
    var common = reachable_cases.get(0).value.without_params()
    | eprintln("common: {common.debug()}")
    var inline = true
    for case_ in reachable_cases do
      if case_.value.without_params() != common then {
        inline = false
        break
      }
    | eprintln("filling common? {inline}")
    if inline then return common.fill(empty_slice[EggId](), builder)
  }

  | If all non-diverging cases are the same and don't depend on parameters,
  | pull them out of the switch, leaving the switch to evaluate to Nothing.
  | This then leaves simpler, more constant-foldable ingredients for later
  | expressions.
  |
  | a = ...
  | ---------------------------------
  | switch a       |  b =
  |   true b:      |    switch a
  |     c = crash  |      true c:
  |     c          |        d = crash
  |   false d:     |        d
  |     e = int 3  |      false e:
  |     e          |        f = &
  |                |        f
  |                |  int 3
  var non_diverging_cases = list[MapEntry[String, EggBody]]()
  for case_ in switch_.cases do
    if not(case_.value.definitely_diverges_biased()) then
      non_diverging_cases.&.push(case_)
  if non_diverging_cases.is_not_empty()
    and not(non_diverging_cases.get(0).value.uses_params())
  then {
    var common = non_diverging_cases.get(0).value.without_params()
    var nothing = egg_body_builder().&.nothing()
    var is_body_just_returning_nothing =
      common.returns == nothing and {
        common.children.is_empty() or
          common.children.len == 1 and common.children.get(0) == nothing
      }
    var inline = not(is_body_just_returning_nothing)
    for case_ in non_diverging_cases do {
      if not(inline) then break
      if case_.value.without_params() != common then inline = false
    }
    if inline then {
      builder.switch_(switch_.condition, {
        var new_cases = map[String, EggBody]()
        for case_ in switch_.cases do
          new_cases.&.put(
            case_.key,
            if case_.value.without_params() == common
            then {
              var builder = egg_body_builder().&
              for param in case_.value.params do builder.params.&.push(param)
              builder.finish_with_nothing()
            } else {
              var builder = egg_body_builder().&
              for param in case_.value.params do builder.params.&.push(param)
              for child in case_.value.children do
                builder.children.&.push(child)
              builder.finish_with_nothing()
            }
          )
        new_cases
      })
      return common.fill(empty_slice[EggId](), builder)
    }
  }

  id
}
