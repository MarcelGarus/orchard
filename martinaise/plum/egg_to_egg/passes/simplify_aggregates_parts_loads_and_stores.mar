import mod.mar

fun simplify_aggregates_parts_loads_and_stores(id: EggId, builder: &EggBodyBuilder): EggId {
  switch id.resolve()
  case aggregate(parts) {
    if parts.len == 1 then return parts.get(0)

    | Remove zero-sized parts.
    var new_parts = list[EggId]()
    for part in parts do
      if part.type().memory_layout().size > 0 then
        new_parts.&.push(part)
    if new_parts.len < parts.len then
      return builder.aggregate(new_parts.to_slice())
  }
  case part(part) {
    | If parts just access an entire other expression, return the original one.
    if part.offset == 0 and part.layout.size == part.of.type().memory_layout().size
    then
      return part.of

    | If a part accesses an aggregate, create an aggregate of only the relevant
    | expressions. For example, for bytes a, b, c, d, if we construct an
    | aggregate [ a, b, c, d ] and then access a part at offset 2, size 2, we
    | just want that to become [ c, d ].
    if part.of.resolve() is aggregate(aggregate) then {
      | Calculate the offsets of each part of the aggregate.
      var offsets = uninitialized_slice[Int](aggregate.len + 1)
      var size = 0
      for p in aggregate.iter().enumerate() do {
        offsets.&.set(p.index, size)
        size = size + p.item.type().memory_layout().size
      }
      offsets.&.set(aggregate.len, size)

      | Find out which parts of the aggregate are relevant.
      var start = aggregate.len
      loop {
        start = start - 1
        if offsets.get(start) <= part.offset then break
      }
      var end = 0
      loop {
        end = end + 1
        if offsets.get(end) >= {part.offset + part.layout.size} then break
      }

      if end - start < aggregate.len then {
        return builder.part(
          builder.aggregate(aggregate.subslice(start..end)),
          part.offset - offsets.get(start),
          part.layout,
        )
      }
    }

    | If a part accesses another part, instead access the original expression
    | directly.
    if part.of.resolve() is part(inner) then
      return builder.part(inner.of, inner.offset + part.offset, part.layout)

    | If a part access a load, instead load only the relevant part directly.
    if part.of.resolve() is load(load) then {
      return builder.load(
        builder.add(load.ptr, builder.int(part.offset)),
        part.layout,
      )
    }
  }
  default {}

  id
}
