import mod.mar

fun lower_casts(
  id: EggId, funs: &Map[String, EggFun], builder: &EggBodyBuilder
): EggId {
  var cast = id.resolve().cast or return id
  builder.desugared_cast(cast.what, cast.type, funs)
}

fun desugared_cast(
  builder: &EggBodyBuilder, what: EggId, type: EggType,
  funs: &Map[String, EggFun],
): EggId {
  builder.call(
    compile_cast_fun(what.type(), type, funs),
    no_substitutions,
    list(what).to_slice(),
    type,
  )
}

fun compile_cast_fun(
  from: EggType, to: EggType, funs: &Map[String, EggFun]
): String {
  var signature = "cast {from} to {to}"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*) | placeholder
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var value = builder.param(from)
      builder.finish(
        if from.plum() is never then builder.unreachable(to)
        else if from == to then value | This cast is the identity fun!
        else
          switch to.plum()
          case type unreachable()
          case byte unreachable()
          case int unreachable()
          case array(to_item_type)
            builder.generate_array(builder.array_len(value), {
              var builder = egg_body_builder().&
              var index = builder.param(type_int)
              builder.finish(
                builder.desugared_cast(
                  builder.array_get(value, index), to_item_type, funs
                ),
              )
            })
          case struct_(to_field_types)
            builder.struct_({
              var to_fields = map[String, EggId]()
              for field in to_field_types do
                to_fields.&.put(
                  field.key,
                  builder.desugared_cast(
                    builder.member(value, field.key), field.value, funs
                  ),
                )
              to_fields
            })
          case enum_(to_variant_types)
            builder.switch_(value, {
              var cases = map[String, EggBody]()
              for variant in from.plum().enum_.unwrap() do
                cases.&.put(variant.key, {
                  var builder = egg_body_builder().&
                  var payload = builder.case_param(value, variant.key)
                  builder.finish(
                    builder.enum_(
                      to,
                      variant.key,
                      builder.desugared_cast(
                        payload, to_variant_types.get(variant.key), funs
                      ),
                    )
                  )
                })
              cases
            })
          case lambda(to_lambda_type) {
            var from_lambda_type = from.plum().lambda.unwrap()
            builder.inline_lambda({
              var builder = egg_body_builder().&
              var outer_params = list[EggId]()
              for param in to_lambda_type.args do
                outer_params.&.push(builder.param(param))
              var inner_params = list[EggId]()
              for param
              in zip(outer_params.iter(), from_lambda_type.args.iter())
              do
                inner_params.&.push(
                  builder.desugared_cast(param.a, param.b, funs)
                )
              builder.finish(
                builder.desugared_cast(
                  builder.call(value, inner_params.to_slice()),
                  from_lambda_type.return_type,
                  funs,
                ),
              )
            })
          }
          default panic("casting {from} to {to} is not supported")
      )
    }
  })
  signature
}
