| Adding Dup and Drop Instructions  
|
| This conversion introduces a form of ownership. After this transformation,
| every value in the Egg has one or multiple owners and stores a reference count
| of the the number of owners. Every value in the Egg is reference counted.
| Later on, some of the reference counting operations are simplified (for
| example, if a type doesn't require any heap allocations, no reference counting
| occurs because it is always copied).
| You can only use an expression if you own it. All operations take ownership
| of the input values and give you ownership of the returned values. For
| example, constructing a struct takes ownership of the individual fields and
| gives you ownership of the struct. Calling a function passes ownership of the
| arguments to the function and gives you ownership of the return value.
| The dup expression increments the reference count and allows you to use an
| expression more than once. The drop expression decrements the reference count
| and frees the value's memory if the reference count reaches zero.

import mod.mar

fun lower_ownership(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do funs.&.put(fun_.key, fun_.value.lower_ownership())
  Egg { entry_point = egg.entry_point, funs }
}

fun lower_ownership(fun_: EggFun): EggFun {
  var mapping = map[EggId, EggId]()
  fun_.body.visit(ReserveIds { mapping = mapping.& })
  var body = fun_.body.lower_ownership(set[EggId]().&, mapping)
  EggFun { signature = fun_.signature, body }
}
struct ReserveIds { mapping: &Map[EggId, EggId] }
fun visit(body: EggBody, reserve: ReserveIds) {
  for param in body.params do param.visit(reserve)
  for child in body.children do child.visit(reserve)
}
fun visit(id: EggId, reserve: ReserveIds) {
  if not(reserve.mapping.contains(id)) then
    reserve.mapping.put(
      id,
      create_with_new_identity(EggExpr.param(
        if {id.resolve() is dup} or {id.resolve() is drop} then
          type_nothing
        else
          id.type()
      )),
    )
  id.visit_children(reserve)
}

fun lower_ownership(
  body: EggBody,
  needed_later_on: &Set[EggId], mapping: Map[EggId, EggId],
): EggBody {
  var rev_body = list[EggId]()

  rev_body.&.require(body.returns.map(mapping), needed_later_on)

  for id in body.children.rev_iter() do
    id.lower_ownership(rev_body.&, needed_later_on, mapping)

  var params = list[EggId]()
  for param in body.params do {
    var type = param.type()
    var param = param.map(mapping)
    if not(needed_later_on.contains(param)) then
      rev_body.&.push(EggExpr.drop(EggDrop { id = param, type }).create())
    else
      needed_later_on.remove(param)
    params.&.push(update(param, EggExpr.param(type)))
  }
  var params = params.to_slice()

  var exprs = list[EggId]()
  for id in rev_body.to_slice().rev_iter() do exprs.&.push(id)
  var exprs = exprs.to_slice()

  EggBody { params, children = exprs, returns = body.returns.map(mapping) }
}

fun require(
  rev_body: &List[EggId], id: EggId, needed_later_on: &Set[EggId]
) {
  if needed_later_on.contains(id) then
    rev_body.push(EggExpr.dup(EggDup { id, type = id.type() }).create())
  else
    needed_later_on.put(id)
}

fun lower_ownership(
  id: EggId,
  rev_body: &List[EggId], needed_later_on: &Set[EggId],
  mapping: Map[EggId, EggId],
) {
  var expr = id.resolve()
  var id = id.map(mapping)

  if not(needed_later_on.contains(id)) then
    rev_body.&.push(EggExpr.drop(EggDrop { id, type = id.type() }).create())
  else
    needed_later_on.remove(id)

  switch expr
  case byte(byte) rev_body.push(update(id, EggExpr.byte(byte)))
  case lower_byte(int) {
    var int = int.map(mapping)
    rev_body.push(update(id, EggExpr.lower_byte(int)))
    rev_body.require(int, needed_later_on)
  }
  case byte_to_int(byte) {
    var byte = byte.map(mapping)
    rev_body.push(update(id, EggExpr.byte_to_int(byte)))
    rev_body.require(byte, needed_later_on)
  }
  case int(int) rev_body.push(update(id, EggExpr.int(int)))
  case add(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.add(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case subtract(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.subtract(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case multiply(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.multiply(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case unchecked_divide(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.unchecked_divide(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case unchecked_modulo(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.unchecked_modulo(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case shift_left(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.shift_left(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case shift_right(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.shift_right(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case and_(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.and_(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case or_(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.or_(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case xor(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.xor(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case compare(args) {
    var args = args.map(mapping)
    rev_body.push(update(id, EggExpr.compare(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case struct_(struct_) {
    var fields = map[String, EggId]()
    for field in struct_ do fields.&.put(field.key, field.value.map(mapping))
    rev_body.push(update(id, EggExpr.struct_(fields)))
    for field in fields do rev_body.require(field.value, needed_later_on)
  }
  case member(member) {
    var of = member.of.map(mapping)
    rev_body.push(update(
      id, EggExpr.member(EggMember { of, name = member.name })
    ))
    rev_body.require(of, needed_later_on)
  }
  case enum_(enum_) {
    var payload = enum_.payload.map(mapping)
    rev_body.push(update(
      id,
      EggExpr.enum_(EggEnum {
        variant = enum_.variant, payload, type = enum_.type
      }),
    ))
    rev_body.require(payload, needed_later_on)
  }
  case switch_(switch_) {
    var condition = switch_.condition.map(mapping)

    | Lower the individual cases.
    var cases = map[String, EggBody]()
    var needed_by_branches = map[String, Set[EggId]]()
    for case_ in switch_.cases do {
      var needed_by_this_branch = set[EggId]()
      for id in needed_later_on do needed_by_this_branch.&.put(id)
      cases.&.put(
        case_.key,
        case_.value.lower_ownership(needed_by_this_branch.&, mapping),
      )
      needed_by_branches.&.put(case_.key, needed_by_this_branch)
    }

    | Figure out the IDs that all branches need.
    for entry in needed_by_branches do
      for id in entry.value do needed_later_on.&.put(id)

    | If a branch doesn't use IDs that other branches use, drop those at the
    | start of the branch body.
    for case_ in cases do {
      var needed_by_this_branch = needed_by_branches.get(case_.key)
      var diff_to_other_branches = set[EggId]()
      for id in needed_later_on do
        if not(needed_by_this_branch.contains(id)) then
          diff_to_other_branches.&.put(id)

      var drops = list[EggId]()
      for id in diff_to_other_branches do
        drops.&.push(EggExpr.drop(EggDrop { id, type = id.type() }).create())

      cases.&.put(case_.key, EggBody {
        params = case_.value.params,
        children = {drops + case_.value.children.to_list()}.to_slice(),
        returns = case_.value.returns,
      })
    }
    rev_body.push(update(
      id, EggExpr.switch_(EggSwitch { condition, cases })
    ))
    rev_body.require(condition, needed_later_on)
  }
  case raw_lambda(lambda) {
    var closure = lambda.closure.map(mapping)
    rev_body.push(update(
      id,
      EggExpr.raw_lambda(EggRawLambda {
        fun_ = lambda.fun_, closure, type = lambda.type
      }),
    ))
    rev_body.require(closure, needed_later_on)
  }
  case call_fun(call) {
    var args = call.args.map(mapping)
    rev_body.push(update(
      id,
      EggExpr.call_fun(EggCallFun {
        fun_ = call.fun_, args, return_type = call.return_type
      }),
    ))
    for arg in args do rev_body.require(arg, needed_later_on)
  }
  case call_lambda(call) {
    var lambda = call.lambda.map(mapping)
    var args = call.args.map(mapping)
    rev_body.push(update(
      id, EggExpr.call_lambda(EggCallLambda { lambda, args })
    ))
    for arg in args do rev_body.require(arg, needed_later_on)
    rev_body.require(lambda, needed_later_on)
  }
  case box(inner) {
    var inner = inner.map(mapping)
    rev_body.push(update(id, EggExpr.box(inner)))
    rev_body.require(inner, needed_later_on)
  }
  case unbox(box) {
    var box = box.map(mapping)
    rev_body.push(update(id, EggExpr.unbox(box)))
    rev_body.require(box, needed_later_on)
  }
  case array(array) {
    var items = array.items.map(mapping)
    rev_body.push(update(
      id, EggExpr.array(EggArray { items, item_type = array.item_type })
    ))
    for item in items do rev_body.require(item, needed_later_on)
  }
  case unchecked_generate_non_empty_array(gen) {
    var length = gen.length.map(mapping)
    var last_used_in_generator = {
      var ids = list[EggId]()
      for id in gen.generator.captured() do {
        var id = id.map(mapping)
        if not(needed_later_on.contains(id)) then ids.&.push(id)
      }
      ids.to_slice()
    }
    for id in last_used_in_generator do {
      needed_later_on.put(id)
      rev_body.push(EggExpr.drop(EggDrop { id, type = id.type() }).create())
    }
    var generator = gen.generator.lower_ownership(needed_later_on, mapping)
    rev_body.push(update(
      id,
      EggExpr.unchecked_generate_non_empty_array(EggGenerateArray {
        length, generator
      }),
    ))
    rev_body.require(length, needed_later_on)
  }
  case array_len(array) {
    var array = array.map(mapping)
    rev_body.push(update(id, EggExpr.array_len(array)))
    rev_body.require(array, needed_later_on)
  }
  case unchecked_array_get(args) {
    var array = args.array.map(mapping)
    var index = args.index.map(mapping)
    rev_body.push(update(id, EggExpr.unchecked_array_get(EggArrayGet { array, index })))
    rev_body.require(index, needed_later_on)
    rev_body.require(array, needed_later_on)
  }
  case unchecked_array_set(args) {
    var array = args.array.map(mapping)
    var index = args.index.map(mapping)
    var item = args.item.map(mapping)
    rev_body.push(update(
      id, EggExpr.unchecked_array_set(EggArraySet { array, index, item })
    ))
    rev_body.require(item, needed_later_on)
    rev_body.require(index, needed_later_on)
    rev_body.require(array, needed_later_on)
  }
  case unchecked_array_slice(args) {
    var array = args.array.map(mapping)
    var start = args.start.map(mapping)
    var end = args.end.map(mapping)
    rev_body.push(update(
      id, EggExpr.unchecked_array_slice(EggArraySlice { array, start, end })
    ))
    rev_body.require(end, needed_later_on)
    rev_body.require(start, needed_later_on)
    rev_body.require(array, needed_later_on)
  }
  case type(ty) rev_body.push(update(id, EggExpr.type(ty)))
  case crash(crash) {
    var message = crash.message.map(mapping)
    rev_body.push(update(
      id, EggExpr.crash(EggCrash { message, type = crash.type })
    ))
    rev_body.require(message, needed_later_on)
  }
  case unreachable(type) rev_body.push(update(id, EggExpr.unreachable(type)))
  case loop_(loop_) {
    | Loop bodies execute multiple times, so naively consuming captured
    | variables on first use would leave subsequent iterations without access.
    | Instead, we ensure all captured variables are available throughout all
    | iterations by adding them to needed_later_on (causing dups on use) and
    | dropping them only after the entire loop completes.

    var initial = loop_.initial.map(mapping)
    
    var captured = set[EggId]()
    for id in loop_.body.captured() do {
      var mapped = id.map(mapping)
      captured.&.put(mapped)
      needed_later_on.put(mapped)
    }
    
    var body = loop_.body.lower_ownership(needed_later_on, mapping)
    rev_body.push(update(
      id, EggExpr.loop_(EggLoop { initial, body })
    ))
    
    for id in captured do
      rev_body.push(EggExpr.drop(EggDrop { id, type = id.type() }).create())
    
    for arg in initial do rev_body.require(arg, needed_later_on)
  }
  case continue_(continue_) {
    var next = continue_.next.map(mapping)
    rev_body.push(update(
      id, EggExpr.continue_(EggContinue { next, type = continue_.type })
    ))
    for arg in next do rev_body.require(arg, needed_later_on)
  }
  default unreachable("{expr.debug()} should not occur")
}
