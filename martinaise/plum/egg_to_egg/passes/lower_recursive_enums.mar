import mod.mar

fun lower_recursive_enums(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(LowerRecursiveEnums {}))
  Egg { entry_point = egg.entry_point, funs }
}

struct LowerRecursiveEnums {  }

fun map(
  body: EggBody, mapper: LowerRecursiveEnums, mapping: &Map[EggId, EggId]
): EggBody {
  var builder = egg_body_builder().&
  for param in body.params do
    mapping.put(
      param,
      switch param.resolve()
      case param(type) builder.param(type.box_recursive_variants())
      case case_param(param)
        builder.case_param(param.switch_on.map(mapping.*), param.variant)
      default unreachable()
    )
  for child in body.children do {
    var mapped = child.map(mapper, builder, mapping)
    mapping.put(child, mapped)
  }
  builder.finish(body.returns.map(mapping.*))
}

fun map(
  id: EggId, mapper: LowerRecursiveEnums,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  switch id.resolve()
  case enum_(enum_) {
    eprintln("constructing enum of type {enum_.type.box_recursive_variants()}")
    var payload = enum_.payload.map(mapping.*)
    if enum_.type.requires_boxing(enum_.variant) then
      payload = builder.box(payload)
    builder.enum_(enum_.type.box_recursive_variants(), enum_.variant, payload)
  }
  case switch_(switch_) {
    var condition = switch_.condition.map(mapping.*)
    var cases = map[String, EggBody]()
    for case_ in switch_.cases do {
      var variant = case_.key
      var case_ = case_.value
      var builder = egg_body_builder().&
      var payload = builder.push(case_.params.get(0))
      if switch_.condition.type().requires_boxing(variant) then
        payload = builder.unbox(payload)
      var body = builder.finish(case_.fill(payload, builder)).map(mapper, mapping)
      cases.&.put(variant, body)
    }
    builder.switch_(condition, cases)
  }
  case raw_lambda(lambda)
    builder.raw_lambda(
      lambda.fun_,
      lambda.closure.map(mapping.*),
      lambda.type.box_recursive_variants(),
    )
  case call_fun(call)
    builder.call(
      call.fun_,
      no_substitutions,
      call.args.map(mapping.*),
      call.return_type.box_recursive_variants(),
    )
  case call_builtin unreachable()
  case array(array)
    builder.array(
      array.items.map(mapping.*), array.item_type.box_recursive_variants()
    )
  case crash(crash)
    builder.crash(
      crash.message.map(mapping.*), crash.type.box_recursive_variants()
    )
  case unreachable(type) builder.unreachable(type.box_recursive_variants())
  case halt(type) builder.halt(type.box_recursive_variants())
  case continue_(continue_)
    builder.continue_(
      continue_.next.map(mapping.*), continue_.type.box_recursive_variants()
    )
  default builder.push(id.map_children(mapper, mapping))
}

fun requires_boxing(enum_: EggType, variant: String): Bool {
  enum_.plum_not_extended().enum_.unwrap().get(variant).is_unboxed_recursive(1)
}
fun is_unboxed_recursive(type: EggType, depth: Int): Bool {
  switch type.plum_not_extended()
  case variable unreachable()
  case never false
  case byte false
  case int false
  case type false
  case box false
  case array false
  case struct_(struct_) {
    for field in struct_ do
      if field.value.is_unboxed_recursive(depth + 1) then return true
    false
  }
  case enum_(enum_) {
    for variant in enum_ do
      if variant.value.is_unboxed_recursive(depth + 1) then return true
    false
  }
  case lambda false
  case recursive(level) level == depth
}

| TODO: this is gonna bite me in the ass
fun box_recursive_variants(type: EggType): EggType {
  type.box_recursive_variants(0, list[Int]())
}
fun box_recursive_variants(
  type: EggType, depth: Int, added_boxes: List[Int]
): EggType {
  switch type.plum_not_extended()
  case variable unreachable()
  case never type_never
  case byte type_byte
  case int type_int
  case type type_type
  case box(inner) type_box(inner.box_recursive_variants(depth + 1, added_boxes))
  case array(item)
    type_array(item.box_recursive_variants(depth + 1, added_boxes))
  case struct_(struct_) {
    var fields = map[String, EggType]()
    for field in struct_ do
      fields.&.put(
        field.key, field.value.box_recursive_variants(depth + 1, added_boxes)
      )
    type_struct(fields)
  }
  case enum_(enum_) {
    var variants = map[String, EggType]()
    for variant in enum_ do
      variants.&.put(
        variant.key,
        if type.requires_boxing(variant.key) then
          type_box(
            variant.value.box_recursive_variants(
              depth + 1, added_boxes + list(depth)
            )
          )
        else
          variant.value.box_recursive_variants(depth + 1, added_boxes),
      )
    type_enum(variants)
  }
  case lambda(lambda) {
    var args = list[EggType]()
    for arg in lambda.args do
      args.&.push(arg.box_recursive_variants(depth + 1, added_boxes))
    var return_type =
      lambda.return_type.box_recursive_variants(depth + 1, added_boxes)
    type_lambda(args.to_slice(), return_type)
  }
  case recursive(level) {
    var target_depth = depth - level
    var extra_levels = 0
    for added in added_boxes do
      if {target_depth..depth}.contains(added) then
        extra_levels = extra_levels + 1
    type_recursive(level + extra_levels)
  }
}
