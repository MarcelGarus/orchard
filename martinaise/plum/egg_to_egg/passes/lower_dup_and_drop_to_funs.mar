import mod.mar

fun lower_dup_and_drop_to_funs(
  id: EggId,
  funs: &Map[String, EggFun],
  builder: &EggBodyBuilder,
): EggId {
  | eprintln("lowering mem layout of")
  | stderr.write(id, namespace().&, no_indentation)
  | stderr."\n"
  switch id.resolve()
  case dup(dup) {
    builder.desugared_dup(dup.id, dup.type)
    builder.nothing()
  }
  case drop(drop) {
    builder.desugared_drop(drop.id, drop.type, funs)
    builder.nothing()
  }
  default id
}

| Traverses the value and dups all inner values. If it reaches a pointer, it
| just increments that pointer's reference count instead of traversing further.
fun desugared_dup(builder: &EggBodyBuilder, value: EggId, type: EggType) {
  if not(type.contains_ptr()) then return {}

  switch type.plum()
  case variable unreachable()
  case byte {}
  case int {}
  case type {}
  case box(inner_type)
    if inner_type.num_inhabitants() > NumInhabitants.one then
      builder.increment_refcount(value).ignore()
  case array {
    var buffer = builder.member(value, "buffer")
    builder.if_not_null_ptr(buffer, {
      var builder = egg_body_builder().&
      builder.finish(builder.increment_refcount(buffer))
    })
  }
  case never builder.unreachable(type_nothing).ignore()
  case struct_
    for field in type.plum().struct_.unwrap() do
      builder.desugared_dup(builder.member(value, field.key), field.value)
  case enum_ {
    var cases = map[String, EggBody]()
    for variant in type.plum().enum_.unwrap() do {
      var builder = egg_body_builder().&
      var payload_type = value.type().plum().enum_.unwrap().get(variant.key)
      var payload = builder.param(payload_type)
      if type.requires_boxing(variant.key) then
        builder.increment_refcount(payload).ignore()
      else
        builder.desugared_dup(payload, variant.value)
      cases.&.put(variant.key, builder.finish_with_nothing())
    }
    builder.switch_(value, cases).ignore()
  }
  case lambda
    builder.increment_refcount(builder.member(value, "closure")).ignore()
}

| Traverses the value and drops all inner values. If it reaches a pointer, it
| just decrements pointer's reference count instead of traversing further. If
| the reference count reaches zero, it drops the pointed-to value and frees the
| allocation.
fun desugared_drop(
  builder: &EggBodyBuilder, value: EggId, type: EggType,
  funs: &Map[String, EggFun],
) {
  eprintln("desugared drop of {type}")
  if not(type.contains_ptr()) then return {}

  switch type.plum()
  case variable unreachable()
  case byte {}
  case int {}
  case type {}
  case box(inner_type)
    if inner_type.num_inhabitants() > NumInhabitants.one then
      builder.if_refcount_zero(builder.decrement_refcount(value), {
        var builder = egg_body_builder().&
        builder.call(
          free_box_fun(inner_type, funs),
          no_substitutions,
          list(value).to_slice(),
          type_nothing,
        )
        builder.finish_with_nothing()
      })
  case array(item_type) {
    var buffer = builder.member(value, "buffer")
    builder.if_not_null_ptr(buffer, {
      var builder = egg_body_builder().&
      var new_refcount = builder.decrement_refcount(buffer)
      builder.if_refcount_zero(new_refcount, {
        var builder = egg_body_builder().&
        builder.call(
          free_buffer_fun(item_type, funs),
          no_substitutions,
          list(buffer).to_slice(),
          type_nothing,
        )
        builder.finish_with_nothing()
      })
      builder.finish_with_nothing()
    })
  }
  case never {}
  case struct_
    for field in type.plum().struct_.unwrap() do
      builder.desugared_drop(
        builder.member(value, field.key), field.value, funs
      )
  case enum_(variant_types) {
    var cases = map[String, EggBody]()
    for variant in variant_types do {
      var payload_type = variant.value
      var builder = egg_body_builder().&
      var payload = builder.param(payload_type)
      if type.requires_boxing(variant.key) then
        builder.if_refcount_zero(builder.decrement_refcount(payload), {
          var builder = egg_body_builder().&
          builder.call(
            free_box_fun(payload_type, funs),
            no_substitutions,
            list(payload).to_slice(),
            type_nothing,
          )
          builder.finish_with_nothing()
        })
      else
        builder.desugared_drop(payload, payload_type, funs)

      cases.&.put(variant.key, builder.finish_with_nothing())
    }
    builder.switch_(value, cases).ignore()
  }
  case lambda {
    var closure_ptr = builder.member(value, "closure")
    var new_refcount = builder.decrement_refcount(closure_ptr)
    builder.if_refcount_zero(new_refcount, {
      var builder = egg_body_builder().&
      var free_fun_ptr = builder.member(value, "free")
      builder.call_indirect(
        free_fun_ptr, list(closure_ptr).to_slice(), type_nothing
      )
      builder.finish_with_nothing()
    })
  }
}

| Expects a box with refcount 0. Drops the inner value and frees the allocation.
fun free_box_fun(inner_type: EggType, funs: &Map[String, EggFun]): String {
  var signature = "free (Box {inner_type})"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*)
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var box = builder.param(type_ptr)
      if inner_type.num_inhabitants() <= NumInhabitants.one then {
        | This function will never be called, as the box is always a null ptr.
        | We may still need to construct the free function as part of the ABI.
        | For example, if code returns a lambda, that lambda needs to have a
        | closure pointer, body pointer, and closure free pointer. If the lambda
        | doesn't capture any variables, the closure is empty and we save the
        | heap allocation, storing a null ptr instead. When you drop the lambda,
        | you have to check for null pointers. The function for freeing the
        | closure should never be called.
        builder.finish_with_unreachable(type_nothing)
      } else {
        var inner = builder.object_load(box, inner_type)
        builder.desugared_drop(inner, inner_type, funs)
        builder.object_free(box, inner_type)
        builder.finish_with_nothing()
      }
    }
  })
  signature
}

| Expects an array with refcount 0. Drops the inner values and frees the
| allocation.
fun free_buffer_fun(item_type: EggType, funs: &Map[String, EggFun]): String {
  var signature = "drop (Buffer {item_type})"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[EggFun]().*)
  funs.put(signature, EggFun {
    body = {
      var builder = egg_body_builder().&
      var buffer = builder.param(type_ptr)
      var len = builder.get_buffer_length(buffer)

      builder.loop_(list(builder.int(0)).to_slice(), {
        var builder = egg_body_builder().&
        var cursor = builder.param(type_int)
        var cmp = builder.compare(cursor, len)
        builder.switch_on_ordering(
          cmp,
          egg_body_builder().finish_with_unreachable(type_nothing),
          egg_body_builder().finish_with_nothing(),
          {
            var builder = egg_body_builder().&
            var item = builder.load_buffer_item(buffer, item_type, cursor)
            builder.desugared_drop(item, item_type, funs)
            builder.finish(
              builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                type_nothing,
              )
            )
          },
        ).ignore()
        builder.finish_with_nothing()
      })

      builder.free_buffer(buffer, item_type)
      builder.finish_with_nothing()
    }
  })
  signature
}

fun contains_ptr(type: EggType): Bool {
  switch type.pesto()
  case never false
  case byte false
  case int false
  case struct_(fields) {
    for field in fields do if field.value.contains_ptr() then return true
    false
  }
  case enum_(variants) {
    for variant in variants do if variant.value.contains_ptr() then return true
    false
  }
  case ptr true
}
