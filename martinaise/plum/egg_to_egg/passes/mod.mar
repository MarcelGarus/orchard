| Welcome to the Egg optimizer! This file contains lots of code, so I'll point
| out some general themes going on here. The code here is used to turn a Egg
| into a more optimized Egg.
|
| This is achieved by constant folding operations, inlining function calls,
| analyzing fixpoints of recursive expressions, and pulling impure operations
| out of the tree.

import ../mod.mar
import choose_order.mar
import deduplicate.mar
import factor_out_loop_fixpoints.mar
import hoist_helper.mar
import hoist_known_switch_results.mar
import hoist_out_of_generators.mar
import hoist_out_of_loops.mar
import inline_functions.mar
import lower_bounds_checks.mar
import lower_builtin_calls.mar
import lower_casts.mar
import lower_divide_and_modulo_checks.mar
import lower_dynamics.mar
import lower_generics.mar
import lower_memory_layouts_1.mar
import lower_memory_layouts_2.mar
import lower_lambdas_to_funs.mar
import lower_loads_and_stores.mar
import lower_ownership.mar
import lower_recursive_enums.mar
import lower_strings.mar
import lower_type_infos.mar
import lower_types_to_nothing.mar
import make_switches_branchless.mar
import simplify_aggregates_parts_loads_and_stores.mar
import simplify_arithmetics.mar
import simplify_arrays.mar
import simplify_bitwise.mar
import simplify_casts.mar
import simplify.mar
import simplify_compare_to_enum.mar
import sink_continues.mar
import tree_shake.mar
import unroll_small_arrays.mar
import use_enum_flows.mar

enum LoweringPass {
  lower_generics,
  lower_strings,
  lower_builtin_calls,
  lower_casts,
  lower_type_infos,
  lower_dynamics,
  lower_lambdas_to_funs,
  lower_bounds_checks,
  lower_divide_and_modulo_checks,
  lower_recursive_enums,
  lower_ownership,
  lower_memory_layouts_1,
  lower_memory_layouts_2,
}

enum OptPass {
  deduplicate,
  factor_out_loop_fixpoints,
  hoist_known_switch_results,
  hoist_out_of_generators,
  hoist_out_of_loops,
  inline_functions,
  make_switches_branchless,
  simplify_aggregates_parts_loads_and_stores,
  simplify_arithmetics,
  simplify_arrays,
  simplify_bitwise,
  simplify_casts,
  simplify_compare_to_enum,
  sink_continues,
  tree_shake,
  unroll_small_arrays,
  use_enum_flows,
  | TODO: more optimizations? see https://llvm.org/docs/Passes.html
  | sink_allocations
  | run_functions_at_comptime,
  | dead_argment_elimination
  | canonicalize_comparisons,
  | delete_dead_finite_pure_loops,
  | unroll_loops,
  | unroll_and_jam,
  | sink_trivial_into_lambdas: int constants, etc.
  | unswitch_loops: loop (if a then b else c; d) = if a then loop(b; d) else loop (c; d)
}

fun ==(a: OptPass, b: OptPass): Bool { a.debug().format() == b.debug().format() }
fun hash[H](hasher: H, pass: OptPass) { hasher.hash(pass.debug().format()) }

fun apply(egg: Egg, pass: LoweringPass): Egg {
  switch pass
  case lower_generics egg.lower_generics()
  case lower_recursive_enums egg.lower_recursive_enums()
  case lower_ownership egg.lower_ownership()
  case lower_memory_layouts_1 egg.lower_memory_layouts_1()
  case lower_memory_layouts_2 egg.lower_memory_layouts_2()
  default egg.apply_to_ids(pass)
}
fun apply_to_ids(egg: Egg, pass: LoweringPass): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(
      fun_.key, fun_.value.map(ApplyLoweringPassToIds { pass, funs = funs.& })
    )
  Egg { funs, entry_point = egg.entry_point }
}
struct ApplyLoweringPassToIds { pass: LoweringPass, funs: &Map[String, EggFun] }
fun map(
  id: EggId, mapper: ApplyLoweringPassToIds,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var id = id.map_children(mapper, mapping).create()
  var mapped = id.apply(mapper.pass, builder, mapper.funs)
  if mapped == id then builder.push(mapped).ignore()
  mapped
}
fun apply(
  id: EggId, pass: LoweringPass,
  builder: &EggBodyBuilder, funs: &Map[String, EggFun],
): EggId {
  switch pass
  case lower_strings id.lower_strings(builder)
  case lower_builtin_calls id.lower_builtin_calls(builder)
  case lower_casts id.lower_casts(funs, builder)
  case lower_type_infos id.lower_type_infos(builder)
  case lower_dynamics id.lower_dynamics(funs, builder)
  case lower_lambdas_to_funs id.lower_lambdas_to_funs(funs, builder)
  case lower_bounds_checks id.lower_bounds_checks(builder)
  case lower_divide_and_modulo_checks id.lower_divide_and_modulo_checks(builder)
  default unreachable()
}

| Passes can be applied to an entire Egg, a body, or an individual ID. Some
| passes might be applicable at multiple abstraction levels.

fun apply(egg: Egg, pass: OptPass): Egg {
  switch pass
  case tree_shake egg.tree_shake()
  default egg
}

fun apply(body: EggBody, pass: OptPass): EggBody {
  switch pass
  case deduplicate body.deduplicate()
  case tree_shake body.tree_shake()
  case use_enum_flows body.use_enum_flows()
  default body
}

| Note: If this returns the input ID, then the ID has not yet been added to the
| builder!
fun apply(
  id: EggId, pass: OptPass, funs: &Map[String, EggFun], builder: &EggBodyBuilder
): EggId {
  | eprintln("apply {pass.debug()} to {id.id} {id.resolve().debug()}")
  switch pass
  | case lower_loads_and_stores id.lower_loads_and_stores(builder)
  case make_switches_branchless id.make_switches_branchless(builder)
  case simplify_aggregates_parts_loads_and_stores
    id.simplify_aggregates_parts_loads_and_stores(builder)
  case factor_out_loop_fixpoints id.factor_out_loop_fixpoints(funs.*, builder)
  case hoist_known_switch_results id.hoist_known_switch_results(builder)
  case hoist_out_of_generators id.hoist_out_of_generators(builder)
  case hoist_out_of_loops id.hoist_out_of_loops(builder)
  case inline_functions id.inline_functions(funs.*, builder)
  case simplify_arithmetics id.simplify_arithmetics(builder)
  case simplify_arrays id.simplify_arrays(builder)
  case simplify_bitwise id.simplify_bitwise(builder)
  case simplify_casts id.simplify_casts(builder)
  case sink_continues id.sink_continues(builder)
  case unroll_small_arrays id.unroll_small_arrays(builder)
  default id
}

| Applies multiple passes one after the other.

fun apply(egg: Egg, passes: Slice[OptPass]): Egg {
  for pass in passes do egg = egg.apply(pass)
  egg
}

fun apply(body: EggBody, passes: Slice[OptPass]): EggBody {
  for pass in passes do body = body.apply(pass)
  body
}

fun apply(
  id: EggId,
  passes: Slice[OptPass],
  funs: &Map[String, EggFun],
  builder: &EggBodyBuilder,
): EggId {
  var original = id
  for pass in passes do id = id.apply(pass, funs, builder)
  if id == original then builder.push(id).ignore()
  id
}

| Some passes take a while to stabilize. For example, optimizations might
| enable each other: Constant folding might cause one switch case to be
| eliminated, which restricts the enum variants that flow through the code,
| which in turn enables other optimizations.

fun apply_until_stable(egg: Egg, passes: Slice[OptPass]): Egg {
  | var hash_before = egg.hash()
  | loop {
  |   var funs = map[String, EggFun]()
  |   for signature in egg.choose_optimization_order() do {
  |     var mapped = egg.funs.get(signature)
  |       .map(ApplyUntilStable { passes, processed_funs = funs.& })
  |     eprintln("Mapping {pretty_signature(signature)}")
  |     stderr.write(signature, mapped)
  |     stderr."\n"
  |     mapped.verify()
  |     funs.&.put(signature, mapped)
  |   }
  |   var new_egg = Egg { funs, entry_point = egg.entry_point }.apply(passes)
  |   var hash_after = new_egg.hash()
  |   eprintln("{hash_before} -> {hash_after}")
  |   if hash_before == hash_after then break
  |   hash_before = hash_after
  | }
  | egg

  var funs = map[String, EggFun]()
  for signature in egg.choose_optimization_order() do {
    var mapped = egg.funs.get(signature).map(ApplyUntilStable {
      passes, cache = cache_for_passes(passes), processed_funs = funs.&
    })
    | eprintln("Mapped {pretty_signature(signature)}")
    | stderr.write(signature, mapped)
    | stderr."\n"
    mapped.verify()
    funs.&.put(signature, mapped)
  }
  Egg { funs, entry_point = egg.entry_point }
}

| Used by loop fixpoint analysis.
fun apply_until_stable(body: EggBody, passes: Slice[OptPass]): EggBody {
  body.map(
    ApplyUntilStable {
      passes,
      cache = cache_for_passes(passes),
      processed_funs = map[String, EggFun]().&,
    },
    map[EggId, EggId]().&,
  )
}

fun cache_for_passes(passes: Slice[OptPass]): &Map[EggId, EggBody] {
  if apply_until_stable_caches.get_maybe(passes)
  is some(cache_for_these_passes)
  then
    cache_for_these_passes
  else {
    var cache = map[EggId, EggBody]().put_on_heap()
    apply_until_stable_caches.put(passes, cache)
    cache
  }
}

| Maps a set of optimization passes to a cache that we can use. If the same
| optimization passes are applied to the same expression again, we don't need to
| re-do the work.
var apply_until_stable_caches =
  map[Slice[OptPass], &Map[EggId, EggBody]]().put_on_heap()

struct ApplyUntilStable {
  passes: Slice[OptPass],
  cache: &Map[EggId, EggBody],
  processed_funs: &Map[String, EggFun],
}

fun map(
  body: EggBody, mapper: ApplyUntilStable, mapping: &Map[EggId, EggId]
): EggBody {
  var iteration = 0
  loop {
    iteration = iteration + 1
    | Explicitly do not map the params. As params are compared using their
    | identity, mapping them would make them eternally unstable and cause
    | infinite recursion.
    var builder = egg_body_builder().&
    for param in body.params do
      mapping.put(
        param,
        switch param.resolve()
        case param builder.push(param)
        case case_param(param)
          builder.case_param(param.switch_on.map(mapping.*), param.variant)
        default unreachable(),
      )
    for child in body.children do
      mapping.put(child, child.map(mapper, builder, mapping))
    var new_body = builder.finish(body.returns.map(mapping.*))

    new_body = new_body.apply(mapper.passes)

    if body.hash() == new_body.hash() then break(body)
    if iteration > 50 then {
      eprintln("Warning: Body failed to stabilize after {iteration} iterations!")
      eprintln("Body before iteration {iteration}:")
      stderr.write(body, namespace().&, indentation(1))
      stderr."\n"
      eprintln("Body after iteration {iteration}:")
      stderr.write(new_body, namespace().&, indentation(1))
      stderr."\n"
      break(new_body)
    }
    body = new_body
  }
}

fun map(
  old: EggId,
  mapper: ApplyUntilStable,
  builder: &EggBodyBuilder,
  mapping: &Map[EggId, EggId],
): EggId {
  | eprintln("Mapping {old.debug()} {old.resolve().debug()}")
  | stderr.write(old, namespace().&, indentation(1))
  | stderr."\n"

  switch old.resolve()
  case param panic("should not be mapped")
  case case_param panic("should not be mapped")
  default {}

  | TODO: cache from passes to optimized?
  if mapper.cache.get_maybe(old) is some(new) then {
    for child in new.children do builder.push(child)
    return new.returns
  }

  | A version of the expression with mapped children. For example, if the
  | current expression is a switch, this will create the same switch but with
  | mapped bodies.
  var children_mapped = old.map_children(mapper, mapping).create()

  | eprintln("Children optimized: {children_mapped.debug()} {children_mapped.resolve().debug()}")
  | stderr."\n"
  | stderr.write(children_mapped, namespace().&, indentation(1))
  | stderr."\n"

  | A body that contains:
  | - unmapped expressions that resulted from mapping the current expression
  | - the current mapped expression
  var self_mapped = {
    var builder = egg_body_builder().&
    builder.finish(
      children_mapped.apply(mapper.passes, mapper.processed_funs, builder)
    )
  }

  | A body that contains:
  | - fully mapped expressions that resulted from mapping the current expression
  | - the current fully mapped expression
  var stable =
    if self_mapped.returns == children_mapped then {
      | The current expression could not be further optimized apart from
      | optimizing its children.
      self_mapped
    } else {
      | The current expression was broken down into some smaller expressions.
      | Optimize those recursively.
      var builder = egg_body_builder().&
      for child in self_mapped.children do
        mapping.put(child, child.map(mapper, builder, mapping))
      builder.finish(self_mapped.returns.map(mapping.*))
    }

  | eprintln("full:     {stable.debug()}")

  for child in stable.children do builder.push(child)

  mapping.put(old, stable.returns)
  mapper.cache.put(old, stable)
  stable.returns
}


fun children(id: EggId): Slice[EggId] {
  var children = list[EggId]()
  id.visit_children(GatherChildren { children = children.& })
  children.to_slice()
}
struct GatherChildren { children: &List[EggId] }
fun visit(id: EggId, gather: GatherChildren) { gather.children.push(id) }
| The number of expressions inside this expression.
fun num_exprs(body: EggBody): Int {
  var count = 0
  body.visit(CountExprs { count = count.& })
  count
}
struct CountExprs { count: &Int }
fun visit(id: EggId, counter: CountExprs) {
  counter.count += 1
  id.visit_children(counter)
}
| Converts calls to the given function into continue expressions.
fun call_to_continue_(body: EggBody, fun_: String, return_type: EggType): EggBody {
  body.map(CallToContinue { called = fun_, return_type }, map[EggId, EggId]().&)
}
struct CallToContinue { called: String, return_type: EggType }
fun map(
  id: EggId, mapper: CallToContinue,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mapper, mapping)
  if expr is call_fun(call) then
    if call.fun_ == mapper.called then
      return builder.continue_(call.args, mapper.return_type)
  builder.push(expr)
}

| Fills the body with concrete arguments for its parameters.
fun fill(body: EggBody, args: Slice[EggId], builder: &EggBodyBuilder): EggId {
  | eprintln("Filling\n")
  | stderr.write(body, namespace().&, indentation(1))
  | stderr."\nwith {args.debug()}\n"
  var mapping = map[EggId, EggId]().&
  for both in zip(body.params.iter(), args.iter()) do
    mapping.put(both.a, both.b)
  for old in body.children do {
    var new = old.map(Fill {}, builder, mapping)
    mapping.put(old, new)
  }
  body.returns.map(mapping.*)
}

fun fill(body: EggBody, arg: EggId, builder: &EggBodyBuilder): EggId {
  body.fill(list(arg).to_slice(), builder)
}
fun fill(body: EggBody, mapping: Map[EggId, EggId]): EggBody {
  var mapping = mapping.copy()
  body.map(Fill {}, mapping.&)
}
struct Fill {}
fun map(
  expr: EggId, fill: Fill, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]
): EggId {
  builder.push(expr.map_children(fill, mapping))
}
fun without_params(body: EggBody): EggBody {
  EggBody {
    params = empty_slice[EggId](),
    children = body.children,
    returns = body.returns,
  }
}
| fun replace_recurses_with_lambda(body: EggBody, params: Slice[EggId]): EggBody {
|   body.map(ReplaceRecursesWithLambda { params }, map[EggId, EggId]().&)
| }
| struct ReplaceRecursesWithLambda { params: Slice[EggId] }
| fun map(id: EggId, mapper: ReplaceRecursesWithLambda, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]): EggId {
|   var expr = id.map_children(mapper, mapping)
|   if expr is recurse(rec) then
|     builder.lambda({
|       var builder = egg_body_builder().&
|       for param in mapper.params do builder.params.&.push(param)
|       builder.finish(builder.recurse({
|         var args = list[EggId]()
|         for arg in rec.next do args.&.push(arg)
|         for param in mapper.params do args.&.push(param)
|         args.to_slice()
|       }, rec.type.plum().lambda.unwrap().return_type))
|     })
|   else
|     builder.push(expr)
| }
