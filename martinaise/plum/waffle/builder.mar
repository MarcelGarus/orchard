import mod.mar

struct WaffleBodyBuilder { locals: List[WaffleId], alignment: Int }
fun waffle_body_builder(): WaffleBodyBuilder {
  WaffleBodyBuilder { locals = list[WaffleId](), alignment = 1 }
}
fun local(builder: &WaffleBodyBuilder, expr: WaffleExpr): WaffleExpr {
  var id = create(expr)
  builder.locals.&.push(id)
  waffle_local(id)
}
fun finish(builder: WaffleBodyBuilder, returns: WaffleExpr): WaffleBody {
  WaffleBody { locals = builder.locals.to_slice(), returns }
}

fun is_byte(expr: WaffleExpr): Bool { expr.size() == 1 and expr.alignment() == 1 }
fun is_int(expr: WaffleExpr): Bool { expr.size() == 8 } |and expr.alignment() == 8 }
fun is_ptr(expr: WaffleExpr): Bool { expr.size() == 8 } |and expr.alignment() == 8 }


fun waffle_param(size: Int, alignment: Int): WaffleExpr {
  WaffleExpr.param(MemoryLayout { size, alignment })
}

fun waffle_padding(amount: Int): WaffleExpr { WaffleExpr.padding(amount) }

fun waffle_byte(byte: Byte): WaffleExpr { WaffleExpr.byte(byte) }

fun waffle_int(int: Int): WaffleExpr { WaffleExpr.int(int) }

fun waffle_local(id: WaffleId): WaffleExpr { WaffleExpr.local(id) }

fun waffle_aggregate(fields: Slice[WaffleExpr]): WaffleExpr {
  var size = 0
  for field in fields do {
    size.is_multiple_of(field.alignment()) or
      panic("badly aligned field in aggregate")
    size = size + field.size()
  }
  WaffleExpr.aggregate(fields)
}

fun waffle_part(
  of: WaffleExpr, offset: Int, size: Int, alignment: Int
): WaffleExpr {
  offset >= 0 or panic("negative offset")
  offset + size <= of.size() or
    panic("offset too big: {offset} + {size} > {of.size()}")
  WaffleExpr.part(WafflePart { of = of.put_on_heap(), offset, layout = size })
}

fun waffle_switch(byte: WaffleExpr, cases: Slice[WaffleBody]): WaffleExpr {
  byte.is_byte() or panic("invalid switch condition byte")
  cases.is_not_empty() or panic("switch with no cases")
  | Make sure all branches return the same size.
  var sizes = list[Int]()
  for case_ in cases do
    if not(case_.returns.definitely_diverges()) then
      sizes.&.push(case_.returns.size())
  if sizes.len > 0 then {
    var common = sizes.get(0)
    for size in sizes do
      if size != common then
        panic("switch cases have different sizes: {sizes.debug()}")
  }
  WaffleExpr.switch_(WaffleSwitch { condition = byte.put_on_heap(), cases })
}

| The size and alignment are of the returned value, not the arguments.
fun waffle_call(
  function: String, args: WaffleExpr, size: Int, alignment: Int
): WaffleExpr {
  WaffleExpr.call(WaffleCall {
    function, args = args.put_on_heap(), layout = MemoryLayout { size, alignment }
  })
}

| The size and alignment are of the returned value, not the arguments.
fun waffle_call_indirect(
  function_ptr: WaffleExpr, args: WaffleExpr, size: Int, alignment: Int
): WaffleExpr {
  WaffleExpr.call_indirect(WaffleCallIndirect {
    fun_and_args = waffle_aggregate(list(function_ptr, args).to_slice()).put_on_heap(),
    layout = MemoryLayout { size, alignment },
  })
}

fun waffle_call_indirect(
  fun_and_args: WaffleExpr, size: Int, alignment: Int
): WaffleExpr {
  WaffleExpr.call_indirect(WaffleCallIndirect {
    fun_and_args = fun_and_args.put_on_heap(),
    layout = MemoryLayout { size, alignment },
  })
}

fun waffle_function_ptr(signature: String): WaffleExpr {
  WaffleExpr.function_ptr(signature)
}

fun waffle_lower_byte(int: WaffleExpr): WaffleExpr {
  int.is_int() or panic("not an int ({int.size()} bytes)")
  WaffleExpr.lower_byte(int.put_on_heap())
}

fun waffle_byte_to_int(byte: WaffleExpr): WaffleExpr {
  byte.is_byte() or panic("not an byte ({byte.size()} bytes)")
  WaffleExpr.byte_to_int(byte.put_on_heap())
}

fun waffle_int_operands(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  left.is_int() or panic("left is not an int ({left.size()} bytes)")
  right.is_int() or panic("right is not an int ({right.size()} bytes)")
  waffle_aggregate(list(left, right).to_slice())
}

fun waffle_add(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_add(waffle_int_operands(left, right))
}
fun waffle_add(args: WaffleExpr): WaffleExpr {
  WaffleExpr.add(args.put_on_heap())
}

fun waffle_subtract(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_subtract(waffle_int_operands(left, right))
}
fun waffle_subtract(args: WaffleExpr): WaffleExpr {
  WaffleExpr.subtract(args.put_on_heap())
}

fun waffle_multiply(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_multiply(waffle_int_operands(left, right))
}
fun waffle_multiply(args: WaffleExpr): WaffleExpr {
  WaffleExpr.multiply(args.put_on_heap())
}

fun waffle_divide(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_divide(waffle_int_operands(left, right))
}
fun waffle_divide(args: WaffleExpr): WaffleExpr {
  WaffleExpr.divide(args.put_on_heap())
}

fun waffle_modulo(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_modulo(waffle_int_operands(left, right))
}
fun waffle_modulo(args: WaffleExpr): WaffleExpr {
  WaffleExpr.modulo(args.put_on_heap())
}

fun waffle_shift_left(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_shift_left(waffle_int_operands(left, right))
}
fun waffle_shift_left(args: WaffleExpr): WaffleExpr {
  WaffleExpr.shift_left(args.put_on_heap())
}

fun waffle_shift_right(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_shift_right(waffle_int_operands(left, right))
}
fun waffle_shift_right(args: WaffleExpr): WaffleExpr {
  WaffleExpr.shift_right(args.put_on_heap())
}

fun waffle_compare_zero(int: WaffleExpr): WaffleExpr {
  int.is_int() or panic("expected int")
  WaffleExpr.compare_zero(int.put_on_heap())
}

fun waffle_and(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_and(waffle_int_operands(left, right))
}
fun waffle_and(args: WaffleExpr): WaffleExpr {
  WaffleExpr.and_(args.put_on_heap())
}

fun waffle_or(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_or(waffle_int_operands(left, right))
}
fun waffle_or(args: WaffleExpr): WaffleExpr {
  WaffleExpr.or_(args.put_on_heap())
}

fun waffle_xor(left: WaffleExpr, right: WaffleExpr): WaffleExpr {
  waffle_xor(waffle_int_operands(left, right))
}
fun waffle_xor(args: WaffleExpr): WaffleExpr {
  WaffleExpr.xor(args.put_on_heap())
}

fun waffle_malloc(size: WaffleExpr): WaffleExpr {
  size.is_ptr() or panic("expected pointer")
  WaffleExpr.malloc(size.put_on_heap())
}

fun waffle_free(ptr: WaffleExpr, size: WaffleExpr): WaffleExpr {
  ptr.is_ptr() or panic("expected pointer")
  size.is_ptr() or panic("expected size")
  waffle_free(waffle_aggregate(list(ptr, size).to_slice()))
}
fun waffle_free(args: WaffleExpr): WaffleExpr {
  WaffleExpr.free(args.put_on_heap())
}

fun waffle_load_word(ptr: WaffleExpr): WaffleExpr {
  ptr.is_ptr() or panic("expected pointer")
  WaffleExpr.load_word(ptr.put_on_heap())
}

fun waffle_load_byte(ptr: WaffleExpr): WaffleExpr {
  ptr.is_ptr() or panic("expected pointer")
  WaffleExpr.load_byte(ptr.put_on_heap())
}

fun waffle_store_word(ptr: WaffleExpr, value: WaffleExpr): WaffleExpr {
  ptr.is_ptr() or panic("expected pointer")
  waffle_store_word(waffle_aggregate(list(ptr, value).to_slice()))
}

fun waffle_store_byte(ptr: WaffleExpr, value: WaffleExpr): WaffleExpr {
  ptr.is_ptr() or panic("expected pointer")
  waffle_store_byte(waffle_aggregate(list(ptr, value).to_slice()))
}

fun waffle_store_word(args: WaffleExpr): WaffleExpr {
  WaffleExpr.store_word(args.put_on_heap())
}

fun waffle_store_byte(args: WaffleExpr): WaffleExpr {
  WaffleExpr.store_byte(args.put_on_heap())
}

fun waffle_store_bytes(ptr: WaffleExpr, bytes: Slice[Byte]): WaffleExpr {
  ptr.is_ptr() or panic("expected pointer")
  WaffleExpr.store_bytes(WaffleStoreBytes { ptr = ptr.put_on_heap(), bytes })
}

fun waffle_crash(message: WaffleExpr): WaffleExpr {
  message.size() == 16 or panic("crash, but message is not a buffer ptr + len")
  WaffleExpr.crash(message.put_on_heap())
}

var waffle_unreachable = WaffleExpr.unreachable

var waffle_halt = WaffleExpr.halt

fun waffle_loop(
  param: WaffleId, initial: WaffleExpr, body: WaffleBody
): WaffleExpr {
  WaffleExpr.loop_(WaffleLoop {
    param, initial = initial.put_on_heap(), body = body.put_on_heap()
  })
}

fun waffle_continue(next: WaffleExpr, size: Int, alignment: Int): WaffleExpr {
  WaffleExpr.continue_(WaffleContinue {
    next = next.put_on_heap(), layout = MemoryLayout { size, alignment }
  })
}
