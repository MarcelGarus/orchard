| Well-Aligned Form of Fixed-Layout Expressions  
|
| This compiler stage is a preparation before lowering to stack-based byte code.
| Unlike the Egg, it supports actual nesting of expressions as trees rather than
| a general ID-based traversal (it still supports IDs additionally to nesting).
|
| The tree structure is very amenable to generating stack-based byte code: By
| post-order traversing the Waffle, we can create nice tight byte code.
|
| Example of what the Waffle looks like:
|
| some_fun a =
|   malloc
|     add
|       aggregate
|         16
|         shift_right
|           aggregate
|             a
|             2
|
| When converting to byte code, locals become stack-allocated, the tree-based
| expressions are only temporarily on the stack, consumed by outer expressions.
| Also note that the function parameter is in the body as a "param" expression.
| This seems weird, but allows us to nest it into the first expression,
| resulting in even tinier byte code.

import ../plum.mar
import builder.mar
import dag.mar
import format.mar
import properties.mar
import run.mar

struct Waffle { entry_point: String, funs: Map[String, WaffleFun] }

struct WaffleFun { param: WaffleId, body: WaffleBody }
struct WaffleBody { locals: Slice[WaffleId], returns: WaffleExpr }

struct WaffleId { id: Id }

fun ==(a: WaffleId, b: WaffleId): Bool { a.id == b.id }
fun hash[H](hasher: &H, id: WaffleId) { hasher.hash(id.id) }

enum WaffleExpr {
  param: MemoryLayout,
  padding: Int, | amount
  local: WaffleId,

  | byte stuff
  byte: Byte, | 8 bits
  lower_byte: &WaffleExpr,
  byte_to_int: &WaffleExpr,

  | int stuff
  int: Int,  | 64 bits
  add: &WaffleExpr,
  subtract: &WaffleExpr,
  multiply: &WaffleExpr,
  divide: &WaffleExpr,
  modulo: &WaffleExpr,
  shift_left: &WaffleExpr,
  shift_right: &WaffleExpr,
  and_: &WaffleExpr,
  or_: &WaffleExpr,
  xor: &WaffleExpr,
  compare_zero: &WaffleExpr,

  | struct stuff
  aggregate: Slice[WaffleExpr],
  part: WafflePart,

  | enum stuff
  switch_: WaffleSwitch,

  | calls
  call: WaffleCall,
  call_indirect: WaffleCallIndirect,
  fun_ptr: String,

  | memory stuff
  malloc: &WaffleExpr,
  free: &WaffleExpr,
  load_word: &WaffleExpr,
  load_byte: &WaffleExpr,
  store_word: &WaffleExpr,
  store_byte: &WaffleExpr,
  store_bytes: WaffleStoreBytes,

  | diverging stuff
  crash: &WaffleExpr,
  unreachable,
  halt,

  | loopy stuff
  loop_: WaffleLoop,
  continue_: WaffleContinue,
}
struct WafflePart { of: &WaffleExpr, offset: Int, layout: MemoryLayout }
struct WaffleSwitch { condition: &WaffleExpr, cases: Slice[WaffleBody] }
struct WaffleCall {
  function: String, args: &WaffleExpr, return_layout: MemoryLayout
}
struct WaffleCallIndirect {
  args_and_fun: &WaffleExpr,
  padding_before_fun_ptr: Int,
  return_layout: MemoryLayout,
}
struct WaffleStoreBytes { ptr: &WaffleExpr, bytes: Slice[Byte] }
struct WaffleLoop { param: WaffleId, initial: &WaffleExpr, body: &WaffleBody }
struct WaffleContinue { next: &WaffleExpr, return_layout: MemoryLayout } | TODO: layout needed?
