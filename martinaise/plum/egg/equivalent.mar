
import mod.mar

fun ==(a: EggExpr, b: EggExpr): Bool {
  switch a
  case param(a)             false
  case case_param(a)        if b is case_param(b)        then a == b else false
  case type(a)              if b is type(b)              then a == b else false
  case int(a)               if b is int(b)               then a == b else false
  case string(a)            if b is string(b)            then a == b else false
  case struct_(a)           if b is struct_(b)           then a == b else false
  case enum_(a)             if b is enum_(b)             then a == b else false
  case inline_lambda(a)     if b is inline_lambda(b)     then a == b else false
  case raw_lambda(a)        if b is raw_lambda(b)        then a == b else false
  case member(a)            if b is member(b)            then a == b else false
  case switch_(a)           if b is switch_(b)           then a == b else false
  case call_generic_fun(a)  if b is call_generic_fun(b)  then a == b else false
  case call_fun(a)          if b is call_fun(b)          then a == b else false
  case call_lambda(a)       if b is call_lambda(b)       then a == b else false
  case call_builtin(a)      if b is call_builtin(b)      then a == b else false
  case cast(a)              if b is cast(b)              then a == b else false
  case byte(a)              if b is byte(b)              then a == b else false
  case lower_byte(a)        if b is lower_byte(b)        then a == b else false
  case byte_to_int(a)       if b is byte_to_int(b)       then a == b else false
  case add(a)               if b is add(b)               then a == b else false
  case subtract(a)          if b is subtract(b)          then a == b else false
  case multiply(a)          if b is multiply(b)          then a == b else false
  case divide(a)            if b is divide(b)            then a == b else false
  case modulo(a)            if b is modulo(b)            then a == b else false
  case compare(a)           if b is compare(b)           then a == b else false
  case compare_zero(a)      if b is compare_zero(b)      then a == b else false
  case and_(a)              if b is and_(b)              then a == b else false
  case or_(a)               if b is or_(b)               then a == b else false
  case xor(a)               if b is xor(b)               then a == b else false
  case shift_left(a)        if b is shift_left(b)        then a == b else false
  case shift_right(a)       if b is shift_right(b)       then a == b else false
  case unchecked_divide(a)  if b is unchecked_divide(b)  then a == b else false
  case unchecked_modulo(a)  if b is unchecked_modulo(b)  then a == b else false
  case box(a)               if b is box(b)               then a == b else false
  case unbox(a)             if b is unbox(b)             then a == b else false
  case array(a)             if b is array(b)             then a == b else false
  case generate_array(a)    if b is generate_array(b)    then a == b else false
  case array_get(a)         if b is array_get(b)         then a == b else false
  case array_set(a)         if b is array_set(b)         then a == b else false
  case array_slice(a)       if b is array_slice(b)       then a == b else false
  case array_len(a)         if b is array_len(b)         then a == b else false
  case unchecked_generate_non_empty_array(a) if b is unchecked_generate_non_empty_array(b) then a == b else false
  case unchecked_array_get(a) if b is unchecked_array_get(b) then a == b else false
  case unchecked_array_set(a) if b is unchecked_array_set(b) then a == b else false
  case unchecked_array_slice(a) if b is unchecked_array_slice(b) then a == b else false
  case type_info(a)         if b is type_info(b)         then a == b else false
  case static_to_dynamic(a) if b is static_to_dynamic(b) then a == b else false
  case dynamic_to_static(a) if b is dynamic_to_static(b) then a == b else false
  case crash(a)             if b is crash(b)             then a == b else false
  case unreachable(a)       if b is unreachable(b)       then a == b else false
  case halt(a)              if b is halt(b)              then a == b else false
  case loop_(a)             if b is loop_(b)             then a == b else false
  case continue_(a)         if b is continue_(b)         then a == b else false
  case dup(a)               if b is dup(b)               then a == b else false
  case drop(a)              if b is drop(b)              then a == b else false
  case function_ptr(a)      if b is function_ptr(b)      then a == b else false
  case call_indirect(a)     if b is call_indirect(b)     then a == b else false
  case null_ptr(a)          if b is null_ptr(b)          then a == b else false
  case object_new(a)        if b is object_new(b)        then a == b else false
  case object_load(a)       if b is object_load(b)       then a == b else false
  case object_free(a)       if b is object_free(b)       then a == b else false
  case get_refcount(a)      if b is get_refcount(b)      then a == b else false
  case set_refcount(a)      if b is set_refcount(b)      then a == b else false
  case new_buffer(a)        if b is new_buffer(b)        then a == b else false
  case get_buffer_length(a) if b is get_buffer_length(b) then a == b else false
  case load_buffer_item(a)  if b is load_buffer_item(b)  then a == b else false
  case store_buffer_item(a) if b is store_buffer_item(b) then a == b else false
  case store_buffer_bytes(a) if b is store_buffer_bytes(b) then a == b else false
  case free_buffer(a)       if b is free_buffer(b)       then a == b else false
  case padding(a)           if b is padding(b)           then a == b else false
  case aggregate(a)         if b is aggregate(b)         then a == b else false
  case part(a)              if b is part(b)              then a == b else false
  case switch_on_byte(a)    if b is switch_on_byte(b)    then a == b else false
  case malloc(a)            if b is malloc(b)            then a == b else false
  case free(a)              if b is free(b)              then a == b else false
  case load(a)              if b is load(b)              then a == b else false
  case store(a)             if b is store(b)             then a == b else false
  case load_word(a)         if b is load_word(b)         then a == b else false
  case load_byte(a)         if b is load_byte(b)         then a == b else false
  case store_word(a)        if b is store_word(b)        then a == b else false
  case store_byte(a)        if b is store_byte(b)        then a == b else false
  case store_bytes(a)       if b is store_bytes(b)       then a == b else false
}
fun ==(a: EggBody, b: EggBody): Bool {
  a.params == b.params and a.children == b.children and a.returns == b.returns
}
fun ==(a: EggCaseParam, b: EggCaseParam): Bool {
  a.switch_on == b.switch_on and a.variant == b.variant
}
fun ==(a: EggEnum, b: EggEnum): Bool {
  a.type == b.type and a.variant == b.variant and a.payload == b.payload
}
fun ==(a: EggMember, b: EggMember): Bool { a.of == b.of and a.name == b.name }
fun ==(a: EggSwitch, b: EggSwitch): Bool {
  a.condition == b.condition and a.cases == b.cases
}
fun ==(a: EggCallGenericFun, b: EggCallGenericFun): Bool {
  a.fun_ == b.fun_ and a.substitutions == b.substitutions and a.args == b.args
    and a.return_type == b.return_type
}
fun ==(a: EggCallFun, b: EggCallFun): Bool {
  a.fun_ == b.fun_ and a.args == b.args and a.return_type == b.return_type
}
fun ==(a: Substitutions, b: Substitutions): Bool {
  a.substitutions == b.substitutions
}
fun ==(a: EggRawLambda, b: EggRawLambda): Bool {
  a.fun_ == b.fun_ and a.closure == b.closure and a.type == b.type
}
fun ==(a: EggCallLambda, b: EggCallLambda): Bool {
  a.lambda == b.lambda and a.args == b.args
}
fun ==(a: EggCallBuiltin, b: EggCallBuiltin): Bool {
  a.builtin == b.builtin and a.substitutions == b.substitutions
    and a.args == b.args
}
fun ==(a: EggBuiltin, b: EggBuiltin): Bool {
  a.debug().format() == b.debug().format()
}
fun ==(a: EggCast, b: EggCast): Bool { a.what == b.what and a.type == b.type }
fun ==(a: EggArray, b: EggArray): Bool {
  a.items == b.items and a.item_type == b.item_type
}
fun ==(a: EggGenerateArray, b: EggGenerateArray): Bool {
  a.length == b.length and a.generator == b.generator
}
fun ==(a: EggArrayGet, b: EggArrayGet): Bool {
  a.array == b.array and a.index == b.index
}
fun ==(a: EggArraySet, b: EggArraySet): Bool {
  a.array == b.array and a.index == b.index and a.item == b.item
}
fun ==(a: EggArraySlice, b: EggArraySlice): Bool {
  a.array == b.array and a.start == b.start and a.end == b.end
}
fun ==(a: EggDynamicToStatic, b: EggDynamicToStatic): Bool {
  a.dynamic == b.dynamic and a.static == b.static
}
fun ==(a: EggCrash, b: EggCrash): Bool {
  a.message == b.message and a.type == b.type
}
fun ==(a: EggLoop, b: EggLoop): Bool {
  a.initial == b.initial and a.body == b.body
}
fun ==(a: EggContinue, b: EggContinue): Bool {
  a.next == b.next and a.type == b.type
}
fun ==(a: EggDup, b: EggDup): Bool { a.id == b.id and a.type == b.type }
fun ==(a: EggDrop, b: EggDrop): Bool { a.id == b.id and a.type == b.type }
fun ==(a: EggCallIndirect, b: EggCallIndirect): Bool {
  a.function_ptr == b.function_ptr and a.args == b.args
    and a.return_type == b.return_type
}
fun ==(a: EggObjectLoad, b: EggObjectLoad): Bool { a.ptr == b.ptr and a.type == b.type }
fun ==(a: EggObjectFree, b: EggObjectFree): Bool { a.ptr == b.ptr and a.type == b.type }
fun ==(a: EggGetRefcount, b: EggGetRefcount): Bool { a.ptr == b.ptr }
fun ==(a: EggSetRefcount, b: EggSetRefcount): Bool {
  a.ptr == b.ptr and a.refcount == b.refcount
}
fun ==(a: EggNewBuffer, b: EggNewBuffer): Bool {
  a.item_type == b.item_type and a.length == b.length
}
fun ==(a: EggLoadBufferItem, b: EggLoadBufferItem): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type and a.index == b.index
}
fun ==(a: EggStoreBufferItem, b: EggStoreBufferItem): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type and a.index == b.index
    and a.item == b.item
}
fun ==(a: EggStoreBufferBytes, b: EggStoreBufferBytes): Bool {
  a.buffer == b.buffer and a.bytes == b.bytes
}
fun ==(a: EggFreeBuffer, b: EggFreeBuffer): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type
}
fun ==(a: EggPart, b: EggPart): Bool {
  a.of == b.of and a.offset == b.offset and a.size == b.size
}
fun ==(a: EggSwitchOnByte, b: EggSwitchOnByte): Bool {
  a.condition == b.condition and a.cases == b.cases
}
fun ==(a: EggFree, b: EggFree): Bool { a.ptr == b.ptr and a.size == b.size }
fun ==(a: EggLoad, b: EggLoad): Bool { a.ptr == b.ptr and a.size == b.size }
fun ==(a: EggStore, b: EggStore): Bool { a.ptr == b.ptr and a.value == b.value }
fun ==(a: EggSmolLoad, b: EggSmolLoad): Bool { a.ptr == b.ptr }
fun ==(a: EggSmolStore, b: EggSmolStore): Bool {
  a.ptr == b.ptr and a.value == b.value
}
fun ==(a: EggStoreBytes, b: EggStoreBytes): Bool {
  a.ptr == b.ptr and a.bytes == b.bytes
}

fun hash[H](hasher: H, egg: Egg) { for fun_ in egg.funs do hasher.hash(fun_) }
fun hash[H](hasher: H, fun_: EggFun) { hasher.hash(fun_.body.returns) }
fun hash[H](hasher: H, body: EggBody) {
  for param in body.params do hasher.hash(param)
  for child in body.children do hasher.hash(child)
  hasher.hash(body.returns)
}
fun hash[H](hasher: H, expr: EggExpr) {
  switch expr
  case param(type)       { hasher.hash("param")       hasher.hash(type) }
  case case_param(param) { hasher.hash("case_param")  hasher.hash(param) }
  case type(type)        { hasher.hash("type")        hasher.hash(type) }
  case int(int)          { hasher.hash("int")         hasher.hash(int) }
  case string(string)            { hasher.hash("string")            hasher.hash(string) }
  case struct_(struct_)          { hasher.hash("struct_")           hasher.hash(struct_) }
  case member(member)            { hasher.hash("member")            hasher.hash(member) }
  case enum_(enum_)              { hasher.hash("enum_")             hasher.hash(enum_) }
  case switch_(switch_)          { hasher.hash("switch_")           hasher.hash(switch_) }
  case inline_lambda(body)       { hasher.hash("inline_lambda")     hasher.hash(body) }
  case raw_lambda(lambda)        { hasher.hash("raw_lambda")        hasher.hash(lambda) }
  case call_generic_fun(call)    { hasher.hash("call_generic_fun")  hasher.hash(call) }
  case call_fun(call)            { hasher.hash("call_fun")          hasher.hash(call) }
  case call_lambda(call)         { hasher.hash("call_lambda")       hasher.hash(call) }
  case call_builtin(call)        { hasher.hash("call_builtin")      hasher.hash(call) }
  case cast(cast)                { hasher.hash("cast")              hasher.hash(cast) }
  case byte(byte)                { hasher.hash("byte")              hasher.hash(byte) }
  case lower_byte(arg)           { hasher.hash("lower_byte")        hasher.hash(arg) }
  case byte_to_int(arg)          { hasher.hash("byte_to_int")       hasher.hash(arg) }
  case add(args)                 { hasher.hash("add")               hasher.hash(args.a)  hasher.hash(args.b) }
  case subtract(args)            { hasher.hash("subtract")          hasher.hash(args.a)  hasher.hash(args.b) }
  case multiply(args)            { hasher.hash("multiply")          hasher.hash(args.a)  hasher.hash(args.b) }
  case divide(args)              { hasher.hash("divide")            hasher.hash(args.a)  hasher.hash(args.b) }
  case modulo(args)              { hasher.hash("modulo")            hasher.hash(args.a)  hasher.hash(args.b) }
  case compare(args)             { hasher.hash("compare")           hasher.hash(args.a)  hasher.hash(args.b) }
  case compare_zero(arg)         { hasher.hash("compare_zero")      hasher.hash(arg) }
  case and_(args)                { hasher.hash("and_")              hasher.hash(args.a)  hasher.hash(args.b) }
  case or_(args)                 { hasher.hash("or_")               hasher.hash(args.a)  hasher.hash(args.b) }
  case xor(args)                 { hasher.hash("xor")               hasher.hash(args.a)  hasher.hash(args.b) }
  case shift_left(args)          { hasher.hash("shift_left")        hasher.hash(args.a)  hasher.hash(args.b) }
  case shift_right(args)         { hasher.hash("shift_right")       hasher.hash(args.a)  hasher.hash(args.b) }
  case unchecked_divide(args)    { hasher.hash("unchecked_divide")  hasher.hash(args.a)  hasher.hash(args.b) }
  case unchecked_modulo(args)    { hasher.hash("unchecked_modulo")  hasher.hash(args.a)  hasher.hash(args.b) }
  case box(arg)                  { hasher.hash("box")               hasher.hash(arg) }
  case unbox(arg)                { hasher.hash("unbox")             hasher.hash(arg) }
  case array(array)              { hasher.hash("array")             hasher.hash(array) }
  case generate_array(args)      { hasher.hash("generate_array")    hasher.hash(args) }
  case array_get(args)           { hasher.hash("array_get")         hasher.hash(args) }
  case array_set(args)           { hasher.hash("array_set")         hasher.hash(args) }
  case array_slice(args)         { hasher.hash("array_slice")       hasher.hash(args) }
  case array_len(arg)            { hasher.hash("array_len")         hasher.hash(arg) }
  case unchecked_generate_non_empty_array(args) { hasher.hash("unchecked_generate_non_empty_array")  hasher.hash(args) }
  case unchecked_array_get(args) { hasher.hash("unchecked_array_get")  hasher.hash(args) }
  case unchecked_array_set(args) { hasher.hash("unchecked_array_set")  hasher.hash(args) }
  case unchecked_array_slice(args) { hasher.hash("unchecked_array_slice")  hasher.hash(args) }
  case type_info(arg)            { hasher.hash("type_info")         hasher.hash(arg) }
  case static_to_dynamic(arg)    { hasher.hash("static_to_dynamic") hasher.hash(arg) }
  case dynamic_to_static(convert) { hasher.hash("dynamic_to_static") hasher.hash(convert) }
  case crash(crash)              { hasher.hash("crash")             hasher.hash(crash) }
  case unreachable(type)         { hasher.hash("unreachable")       hasher.hash(type) }
  case halt(type)                { hasher.hash("halt")              hasher.hash(type) }
  case loop_(loop_)              { hasher.hash("loop_")             hasher.hash(loop_) }
  case continue_(continue_)      { hasher.hash("continue_")         hasher.hash(continue_) }
  case dup(dup)                  { hasher.hash("dup")               hasher.hash(dup) }
  case drop(drop)                { hasher.hash("drop")              hasher.hash(drop) }
  case function_ptr(signature)   { hasher.hash("function_ptr")      hasher.hash(signature) }
  case call_indirect(call)       { hasher.hash("call_indirect")     hasher.hash(call) }
  case null_ptr                  { hasher.hash("null_ptr") }
  case object_new(id)            { hasher.hash("object_new")        hasher.hash(id) }
  case object_load(load)         { hasher.hash("object_load")       hasher.hash(load) }
  case object_free(free)         { hasher.hash("object_free")       hasher.hash(free) }
  case get_refcount(get)         { hasher.hash("get_refcount")      hasher.hash(get) }
  case set_refcount(set)         { hasher.hash("set_refcount")      hasher.hash(set) }
  case new_buffer(new_buffer)    { hasher.hash("new_buffer")        hasher.hash(new_buffer) }
  case get_buffer_length(arg)    { hasher.hash("get_buffer_length") hasher.hash(arg) }
  case load_buffer_item(load)    { hasher.hash("load_buffer_item")  hasher.hash(load) }
  case store_buffer_item(store)  { hasher.hash("store_buffer_item") hasher.hash(store) }
  case store_buffer_bytes(store) { hasher.hash("store_buffer_bytes") hasher.hash(store) }
  case free_buffer(free)         { hasher.hash("free_buffer")       hasher.hash(free) }
  case malloc(id)                { hasher.hash("malloc")            hasher.hash(id) }
  case padding(amount)           { hasher.hash("padding")           hasher.hash(amount) }
  case aggregate(parts)          { hasher.hash("aggregate")         hasher.hash(parts) }
  case part(part)                { hasher.hash("part")              hasher.hash(part) }
  case switch_on_byte(switch_)   { hasher.hash("switch_on_byte")    hasher.hash(switch_) }
  case free(free)                { hasher.hash("free")              hasher.hash(free) }
  case load(load)                { hasher.hash("load")              hasher.hash(load) }
  case store(store)              { hasher.hash("store")             hasher.hash(store) }
  case load_word(load)           { hasher.hash("load_word")         hasher.hash(load) }
  case load_byte(load)           { hasher.hash("load_byte")         hasher.hash(load) }
  case store_word(store)         { hasher.hash("store_word")        hasher.hash(store) }
  case store_byte(store)         { hasher.hash("store_byte")        hasher.hash(store) }
  case store_bytes(store)        { hasher.hash("store_bytes")       hasher.hash(store) }
}
fun hash[H](hasher: H, enum_: EggEnum) {
  hasher.hash(enum_.type)
  hasher.hash(enum_.variant)
  hasher.hash(enum_.payload)
}
fun hash[H](hasher: H, case_param: EggCaseParam) {
  hasher.hash(case_param.switch_on)
  hasher.hash(case_param.variant)
}
fun hash[H](hasher: H, member: EggMember) {
  hasher.hash(member.of)
  hasher.hash(member.name)
}
fun hash[H](hasher: H, switch_: EggSwitch) {
  hasher.hash(switch_.condition)
  hasher.hash(switch_.cases)
}
fun hash[H](hasher: H, lambda: EggRawLambda) {
  hasher.hash(lambda.fun_)
  hasher.hash(lambda.closure)
  hasher.hash(lambda.type)
}
fun hash[H](hasher: H, call: EggCallGenericFun) {
  hasher.hash(call.fun_)
  hasher.hash(call.substitutions)
  for arg in call.args do hasher.hash(arg)
  hasher.hash(call.return_type)
}
fun hash[H](hasher: H, call: EggCallFun) {
  hasher.hash(call.fun_)
  for arg in call.args do hasher.hash(arg)
  hasher.hash(call.return_type)
}
fun hash[H](hasher: H, call: EggCallLambda) {
  hasher.hash(call.lambda)
  for arg in call.args do hasher.hash(arg)
}
fun hash[H](hasher: H, call: EggCallBuiltin) {
  hasher.hash(call.builtin)
  hasher.hash(call.substitutions)
  for arg in call.args do hasher.hash(arg)
}
fun hash[H](hasher: H, builtin: EggBuiltin) {
  hasher.hash(builtin.format())
}
fun hash[H](hasher: H, substitutions: Substitutions) {
  hasher.hash(substitutions.substitutions)
}
fun hash[H](hasher: H, cast: EggCast) {
  hasher.hash(cast.what)
  hasher.hash(cast.type)
}
fun hash[H](hasher: H, array: EggArray) {
  for item in array.items do hasher.hash(item)
  hasher.hash(array.item_type)
}
fun hash[H](hasher: H, gen: EggGenerateArray) {
  hasher.hash(gen.length)
  hasher.hash(gen.generator)
}
fun hash[H](hasher: H, get: EggArrayGet) {
  hasher.hash(get.array)
  hasher.hash(get.index)
}
fun hash[H](hasher: H, set: EggArraySet) {
  hasher.hash(set.array)
  hasher.hash(set.index)
  hasher.hash(set.item)
}
fun hash[H](hasher: H, slice: EggArraySlice) {
  hasher.hash(slice.array)
  hasher.hash(slice.start)
  hasher.hash(slice.end)
}
fun hash[H](hasher: H, convert: EggDynamicToStatic) {
  hasher.hash(convert.dynamic)
  hasher.hash(convert.static)
}
fun hash[H](hasher: H, crash: EggCrash) {
  hasher.hash(crash.message)
  hasher.hash(crash.type)
}
fun hash[H](hasher: H, loop_: EggLoop) {
  hasher.hash(loop_.initial)
  hasher.hash(loop_.body)
}
fun hash[H](hasher: H, continue_: EggContinue) {
  hasher.hash(continue_.next)
  hasher.hash(continue_.type)
}
fun hash[H](hasher: H, dup: EggDup) {
  hasher.hash(dup.id)
  hasher.hash(dup.type)
}
fun hash[H](hasher: H, drop: EggDrop) {
  hasher.hash(drop.id)
  hasher.hash(drop.type)
}
fun hash[H](hasher: H, call: EggCallIndirect) {
  hasher.hash(call.function_ptr)
  for arg in call.args do hasher.hash(arg)
  hasher.hash(call.return_type)
}
fun hash[H](hasher: H, load: EggObjectLoad) {
  hasher.hash(load.ptr)
  hasher.hash(load.type)
}
fun hash[H](hasher: H, free: EggObjectFree) {
  hasher.hash(free.ptr)
  hasher.hash(free.type)
}
fun hash[H](hasher: H, get: EggGetRefcount) {
  hasher.hash(get.ptr)
}
fun hash[H](hasher: H, set: EggSetRefcount) {
  hasher.hash(set.ptr)
  hasher.hash(set.refcount)
}
fun hash[H](hasher: H, new_buffer: EggNewBuffer) {
  hasher.hash(new_buffer.item_type)
  hasher.hash(new_buffer.length)
}
fun hash[H](hasher: H, load: EggLoadBufferItem) {
  hasher.hash(load.buffer)
  hasher.hash(load.item_type)
  hasher.hash(load.index)
}
fun hash[H](hasher: H, store: EggStoreBufferItem) {
  hasher.hash(store.buffer)
  hasher.hash(store.item_type)
  hasher.hash(store.index)
  hasher.hash(store.item)
}
fun hash[H](hasher: H, store: EggStoreBufferBytes) {
  hasher.hash(store.buffer)
  hasher.hash(store.bytes)
}
fun hash[H](hasher: H, free: EggFreeBuffer) {
  hasher.hash(free.buffer)
  hasher.hash(free.item_type)
}
fun hash[H](hasher: H, part: EggPart) {
  hasher.hash(part.of)
  hasher.hash(part.offset)
  hasher.hash(part.size)
}
fun hash[H](hasher: H, switch_: EggSwitchOnByte) {
  hasher.hash(switch_.condition)
  hasher.hash(switch_.cases)
}
fun hash[H](hasher: H, free: EggFree) {
  hasher.hash(free.ptr)
  hasher.hash(free.size)
}
fun hash[H](hasher: H, load: EggLoad) {
  hasher.hash(load.ptr)
  hasher.hash(load.size)
}
fun hash[H](hasher: H, store: EggStore) {
  hasher.hash(store.ptr)
  hasher.hash(store.value)
}
fun hash[H](hasher: H, load: EggSmolLoad) {
  hasher.hash(load.ptr)
}
fun hash[H](hasher: H, store: EggSmolStore) {
  hasher.hash(store.ptr)
  hasher.hash(store.value)
}
fun hash[H](hasher: H, store: EggStoreBytes) {
  hasher.hash(store.ptr)
  hasher.hash(store.bytes)
}
