
import mod.mar

fun ==(a: EggExpr, b: EggExpr): Bool {
  switch a
  case param(a)             false
  case case_param(a)        if b is case_param(b)        then a == b else false
  case type(a)              if b is type(b)              then a == b else false
  case int(a)               if b is int(b)               then a == b else false
  case string(a)            if b is string(b)            then a == b else false
  case struct_(a)           if b is struct_(b)           then a == b else false
  case enum_(a)             if b is enum_(b)             then a == b else false
  case inline_lambda(a)     if b is inline_lambda(b)     then a == b else false
  case raw_lambda(a)        if b is raw_lambda(b)        then a == b else false
  case member(a)            if b is member(b)            then a == b else false
  case switch_(a)           if b is switch_(b)           then a == b else false
  case call_fun(a)          if b is call_fun(b)          then a == b else false
  case call_lambda(a)       if b is call_lambda(b)       then a == b else false
  case call_builtin(a)      if b is call_builtin(b)      then a == b else false
  case cast(a)              if b is cast(b)              then a == b else false
  case byte(a)              if b is byte(b)              then a == b else false
  case lower_byte(a)        if b is lower_byte(b)        then a == b else false
  case byte_to_int(a)       if b is byte_to_int(b)       then a == b else false
  case add(a)               if b is add(b)               then a == b else false
  case subtract(a)          if b is subtract(b)          then a == b else false
  case multiply(a)          if b is multiply(b)          then a == b else false
  case divide(a)            if b is divide(b)            then a == b else false
  case modulo(a)            if b is modulo(b)            then a == b else false
  case compare(a)           if b is compare(b)           then a == b else false
  case and_(a)              if b is and_(b)              then a == b else false
  case or_(a)               if b is or_(b)               then a == b else false
  case xor(a)               if b is xor(b)               then a == b else false
  case shift_left(a)        if b is shift_left(b)        then a == b else false
  case shift_right(a)       if b is shift_right(b)       then a == b else false
  case unchecked_divide(a)  if b is unchecked_divide(b)  then a == b else false
  case unchecked_modulo(a)  if b is unchecked_modulo(b)  then a == b else false
  case box(a)               if b is box(b)               then a == b else false
  case unbox(a)             if b is unbox(b)             then a == b else false
  case array(a)             if b is array(b)             then a == b else false
  case generate_array(a)    if b is generate_array(b)    then a == b else false
  case array_get(a)         if b is array_get(b)         then a == b else false
  case array_set(a)         if b is array_set(b)         then a == b else false
  case array_slice(a)       if b is array_slice(b)       then a == b else false
  case array_len(a)         if b is array_len(b)         then a == b else false
  case unchecked_generate_non_empty_array(a) if b is unchecked_generate_non_empty_array(b) then a == b else false
  case unchecked_array_get(a) if b is unchecked_array_get(b) then a == b else false
  case unchecked_array_set(a) if b is unchecked_array_set(b) then a == b else false
  case unchecked_array_slice(a) if b is unchecked_array_slice(b) then a == b else false
  case type_info(a)         if b is type_info(b)         then a == b else false
  case static_to_dynamic(a) if b is static_to_dynamic(b) then a == b else false
  case dynamic_to_static(a) if b is dynamic_to_static(b) then a == b else false
  case crash(a)             if b is crash(b)             then a == b else false
  case unreachable(a)       if b is unreachable(b)       then a == b else false
  case halt(a)              if b is halt(b)              then a == b else false
  case loop_(a)             if b is loop_(b)             then a == b else false
  case continue_(a)         if b is continue_(b)         then a == b else false
  case dup(a)               if b is dup(b)               then a == b else false
  case drop(a)              if b is drop(b)              then a == b else false
  case function_ptr(a)      if b is function_ptr(b)      then a == b else false
  case call_indirect(a)     if b is call_indirect(b)     then a == b else false
  case null_ptr(a)          if b is null_ptr(b)          then a == b else false
  case object_new(a)        if b is object_new(b)        then a == b else false
  case object_load(a)       if b is object_load(b)       then a == b else false
  case object_free(a)       if b is object_free(b)       then a == b else false
  case get_refcount(a)      if b is get_refcount(b)      then a == b else false
  case set_refcount(a)      if b is set_refcount(b)      then a == b else false
  case new_buffer(a)        if b is new_buffer(b)        then a == b else false
  case get_buffer_length(a) if b is get_buffer_length(b) then a == b else false
  case load_buffer_item(a)  if b is load_buffer_item(b)  then a == b else false
  case store_buffer_item(a) if b is store_buffer_item(b) then a == b else false
  case store_buffer_bytes(a) if b is store_buffer_bytes(b) then a == b else false
  case free_buffer(a)       if b is free_buffer(b)       then a == b else false
  case padding(a)           if b is padding(b)           then a == b else false
  case aggregate(a)         if b is aggregate(b)         then a == b else false
  case part(a)              if b is part(b)              then a == b else false
  case switch_on_byte(a)    if b is switch_on_byte(b)    then a == b else false
  case malloc(a)            if b is malloc(b)            then a == b else false
  case free(a)              if b is free(b)              then a == b else false
  case load(a)              if b is load(b)              then a == b else false
  case store(a)             if b is store(b)             then a == b else false
  case load_word(a)         if b is load_word(b)         then a == b else false
  case load_byte(a)         if b is load_byte(b)         then a == b else false
  case store_word(a)        if b is store_word(b)        then a == b else false
  case store_byte(a)        if b is store_byte(b)        then a == b else false
  case store_bytes(a)       if b is store_bytes(b)       then a == b else false
}
fun ==(a: EggBody, b: EggBody): Bool {
  a.params == b.params and a.children == b.children and a.returns == b.returns
}
fun ==(a: EggCaseParam, b: EggCaseParam): Bool {
  a.switch_on == b.switch_on and a.variant == b.variant
}
fun ==(a: EggEnum, b: EggEnum): Bool {
  a.type == b.type and a.variant == b.variant and a.payload == b.payload
}
fun ==(a: EggMember, b: EggMember): Bool { a.of == b.of and a.name == b.name }
fun ==(a: EggSwitch, b: EggSwitch): Bool {
  a.condition == b.condition and a.cases == b.cases
}
fun ==(a: EggCallFun, b: EggCallFun): Bool {
  a.fun_ == b.fun_ and a.substitutions == b.substitutions and a.args == b.args
    and a.return_type == b.return_type
}
fun ==(a: Substitutions, b: Substitutions): Bool {
  a.substitutions == b.substitutions
}
fun ==(a: EggRawLambda, b: EggRawLambda): Bool {
  a.fun_ == b.fun_ and a.closure == b.closure and a.type == b.type
}
fun ==(a: EggCallLambda, b: EggCallLambda): Bool {
  a.lambda == b.lambda and a.args == b.args
}
fun ==(a: EggCallBuiltin, b: EggCallBuiltin): Bool {
  a.builtin == b.builtin and a.substitutions == b.substitutions
    and a.args == b.args
}
fun ==(a: EggBuiltin, b: EggBuiltin): Bool {
  a.debug().format() == b.debug().format()
}
fun ==(a: EggCast, b: EggCast): Bool { a.what == b.what and a.type == b.type }
fun ==(a: EggArray, b: EggArray): Bool {
  a.items == b.items and a.item_type == b.item_type
}
fun ==(a: EggGenerateArray, b: EggGenerateArray): Bool {
  a.length == b.length and a.generator == b.generator
}
fun ==(a: EggArrayGet, b: EggArrayGet): Bool {
  a.array == b.array and a.index == b.index
}
fun ==(a: EggArraySet, b: EggArraySet): Bool {
  a.array == b.array and a.index == b.index and a.item == b.item
}
fun ==(a: EggArraySlice, b: EggArraySlice): Bool {
  a.array == b.array and a.start == b.start and a.end == b.end
}
fun ==(a: EggDynamicToStatic, b: EggDynamicToStatic): Bool {
  a.dynamic == b.dynamic and a.static == b.static
}
fun ==(a: EggCrash, b: EggCrash): Bool {
  a.message == b.message and a.type == b.type
}
fun ==(a: EggLoop, b: EggLoop): Bool {
  a.initial == b.initial and a.body == b.body
}
fun ==(a: EggContinue, b: EggContinue): Bool {
  a.next == b.next and a.type == b.type
}
fun ==(a: EggDup, b: EggDup): Bool { a.id == b.id and a.type == b.type }
fun ==(a: EggDrop, b: EggDrop): Bool { a.id == b.id and a.type == b.type }
fun ==(a: EggCallIndirect, b: EggCallIndirect): Bool {
  a.function_ptr == b.function_ptr and a.args == b.args
    and a.return_type == b.return_type
}
fun ==(a: EggObjectLoad, b: EggObjectLoad): Bool { a.ptr == b.ptr and a.type == b.type }
fun ==(a: EggObjectFree, b: EggObjectFree): Bool { a.ptr == b.ptr and a.type == b.type }
fun ==(a: EggGetRefcount, b: EggGetRefcount): Bool { a.ptr == b.ptr }
fun ==(a: EggSetRefcount, b: EggSetRefcount): Bool {
  a.ptr == b.ptr and a.refcount == b.refcount
}
fun ==(a: EggNewBuffer, b: EggNewBuffer): Bool {
  a.item_type == b.item_type and a.length == b.length
}
fun ==(a: EggLoadBufferItem, b: EggLoadBufferItem): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type and a.index == b.index
}
fun ==(a: EggStoreBufferItem, b: EggStoreBufferItem): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type and a.index == b.index
    and a.item == b.item
}
fun ==(a: EggStoreBufferBytes, b: EggStoreBufferBytes): Bool {
  a.buffer == b.buffer and a.bytes == b.bytes
}
fun ==(a: EggFreeBuffer, b: EggFreeBuffer): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type
}
fun ==(a: EggPart, b: EggPart): Bool {
  a.of == b.of and a.offset == b.offset and a.size == b.size
}
fun ==(a: EggSwitchOnByte, b: EggSwitchOnByte): Bool {
  a.condition == b.condition and a.cases == b.cases
}
fun ==(a: EggFree, b: EggFree): Bool { a.ptr == b.ptr and a.size == b.size }
fun ==(a: EggLoad, b: EggLoad): Bool { a.ptr == b.ptr and a.size == b.size }
fun ==(a: EggStore, b: EggStore): Bool { a.ptr == b.ptr and a.value == b.value }
fun ==(a: EggSmolLoad, b: EggSmolLoad): Bool { a.ptr == b.ptr }
fun ==(a: EggSmolStore, b: EggSmolStore): Bool {
  a.ptr == b.ptr and a.value == b.value
}
fun ==(a: EggStoreBytes, b: EggStoreBytes): Bool {
  a.ptr == b.ptr and a.bytes == b.bytes
}

fun hash[H](hasher: H, egg: Egg) { for fun_ in egg.funs do hasher.hash(fun_) }
fun hash[H](hasher: H, fun_: EggFun) { hasher.hash(fun_.body.returns) }
fun hash[H](hasher: H, body: EggBody) {
  for param in body.params do hasher.hash(param)
  for child in body.children do hasher.hash(child)
  hasher.hash(body.returns)
}
fun hash[H](hasher: H, expr: EggExpr) { hasher.hash(expr.debug().format()) }
fun hash[H](hasher: H, enum_: EggEnum) {
  hasher.hash(enum_.type)
  hasher.hash(enum_.variant)
  hasher.hash(enum_.payload)
}
