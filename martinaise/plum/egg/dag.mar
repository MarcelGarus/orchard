import mod.mar

struct EggId { index: Int }

fun ==(a: EggId, b: EggId): Bool { a.index == b.index }
fun hash[H](hasher: H, id: EggId) { hasher.hash(id.index) }

fun write[W](writer: W, id: EggId) {
  writer."{"{id.index}".styled(style_of_id)}"
}

var egg_exprs = list[EggExpr]().put_on_heap()
var egg_expr_to_id = map[EggExpr, EggId]().put_on_heap()

fun create(expr: EggExpr): EggId {
  | if egg_expr_to_id.get_maybe(expr) is some(id) then return id
  var id = EggId { index = egg_exprs.len }
  egg_exprs.push(expr)
  | egg_expr_to_id.put(expr, id)
  id
}
fun resolve(id: EggId): EggExpr { egg_exprs.get(id.index) }
fun update(id: EggId, expr: EggExpr): EggId {
  egg_exprs.set(id.index, expr)
  id
}

var next_identity = 0.put_on_heap()
struct Identity { value: Int }
fun new_identity(): Identity {
  var identity = Identity { value = next_identity.* }
  next_identity += 1
  identity
}
fun ==(a: Identity, b: Identity): Bool { a.value == b.value }
fun hash(hasher: &Hasher, identity: Identity) { hasher.hash(identity.value) }
