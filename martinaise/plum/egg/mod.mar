| Expression-Guided Graph  
|
| A representation of code where we have used names to establish the connections
| between types, expressions, and functions.
| 
| Every Egg expression has a type. Function calls are resolved to specific
| functions based on the parameter types (aka function overloading) and we have
| figured out how types need to be substituted for things to work out.
| Speaking of types: Types no longer contain user-given names. Instead, we have
| inlined type definitions so that types are completely structural. For example,
| rather than (LinkedList Int), the Egg uses this type:
|
| (| empty: (&) more: (& item: (Int) rest: (^2)))

import ../plum.mar
import builder.mar
import builtins.mar
import dag.mar
import equivalent.mar
import format.mar
| import run.mar
import types.mar

| All EggExprs are allocated and managed by the DAG in dag.mar. This allows
| using EggIds everywhere instead of having to use references.

struct Egg { entry_point: String, funs: Map[String, EggFun] }
struct EggFun { body: EggBody }
struct EggBody { params: Slice[EggId], children: Slice[EggId], returns: EggId }
enum EggExpr {
  param: EggType,
  case_param: EggCaseParam,

  | byte stuff
  byte: Byte,
  lower_byte: EggId,
  byte_to_int: EggId,

  | int stuff
  int: Int,
  add: Tuple2[EggId, EggId],
  subtract: Tuple2[EggId, EggId],
  multiply: Tuple2[EggId, EggId],
  divide: Tuple2[EggId, EggId],
  modulo: Tuple2[EggId, EggId],
  and_: Tuple2[EggId, EggId],
  or_: Tuple2[EggId, EggId],
  xor: Tuple2[EggId, EggId],
  compare: Tuple2[EggId, EggId],
  unchecked_divide: Tuple2[EggId, EggId],
  unchecked_modulo: Tuple2[EggId, EggId],

  | struct stuff
  struct_: Map[String, EggId],
  member: EggMember,

  | enum stuff
  enum_: EggEnum,
  switch_: EggSwitch,

  | function and lambda stuff
  inline_lambda: EggBody,
  raw_lambda: EggRawLambda,
  call_fun: EggCallFun,
  call_builtin: EggCallBuiltin,
  call_lambda: EggCallLambda,

  | box stuff
  box: EggId,
  unbox: EggId,

  | array stuff
  array: EggArray,
  generate_array: EggGenerateArray,
  array_get: EggArrayGet,
  array_set: EggArraySet,
  array_slice: EggArraySlice,
  array_len: EggId,
  unchecked_generate_non_empty_array: EggGenerateArray,
  unchecked_array_get: EggArrayGet,
  unchecked_array_set: EggArraySet,
  unchecked_array_slice: EggArraySlice,

  | string stuff
  string: String,

  | type stuff
  type: EggType,
  cast: EggCast,
  type_info: EggId,
  static_to_dynamic: EggId,
  dynamic_to_static: EggDynamicToStatic,

  | diverging stuff
  crash: EggCrash,
  unreachable: EggType,
  | TODO: add halt

  | loop stuff
  loop_: EggLoop,
  continue_: EggContinue,

  | ownership stuff
  dup: EggDup,
  drop: EggDrop,

  | heap stuff
  function_ptr: String,
  call_indirect: EggCallIndirect,
  new: EggId,
  load: EggLoad,
  free: EggFree,
  get_refcount: EggGetRefcount,
  set_refcount: EggSetRefcount,
  new_buffer: EggNewBuffer,
  get_buffer_length: EggId,
  load_buffer_item: EggLoadBufferItem,
  store_buffer_item: EggStoreBufferItem,
  store_buffer_bytes: EggStoreBufferBytes,
  free_buffer: EggFreeBuffer,
}
struct EggCaseParam { switch_on: EggId, variant: String }
struct EggMember { of: EggId, name: String }
struct EggEnum { type: EggType, variant: String, payload: EggId }
struct EggSwitch { condition: EggId, cases: Map[String, EggBody] }
struct EggRawLambda { fun_: String, closure: EggId, type: EggType }
| TODO: have generic_call with substitutions
struct EggCallFun {
  fun_: String,
  substitutions: Substitutions,
  args: Slice[EggId],
  return_type: EggType,
}
struct EggCallBuiltin {
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[EggId]
}
struct EggCallLambda { lambda: EggId, args: Slice[EggId] }
struct EggArray { items: Slice[EggId], item_type: EggType }
struct EggGenerateArray { length: EggId, generator: EggBody }
struct EggArrayGet { array: EggId, index: EggId }
struct EggArraySet { array: EggId, index: EggId, item: EggId }
struct EggArraySlice { array: EggId, start: EggId, end: EggId }
struct EggDynamicToStatic { dynamic: EggId, static: EggType }
struct EggCast { what: EggId, type: EggType }
struct EggCrash { message: EggId, type: EggType }
struct EggLoop { initial: Slice[EggId], body: EggBody }
struct EggContinue { next: Slice[EggId], type: EggType }
struct EggDup { id: EggId, type: EggType }
struct EggDrop { id: EggId, type: EggType }
struct EggCallIndirect {
  function_ptr: EggId, args: Slice[EggId], return_type: EggType
}
struct EggLoad { ptr: EggId, type: EggType }
struct EggFree { ptr: EggId, type: EggType }
struct EggGetRefcount { ptr: EggId }
struct EggSetRefcount { ptr: EggId, refcount: EggId }
struct EggNewBuffer { item_type: EggType, length: EggId }
struct EggLoadBufferItem { buffer: EggId, item_type: EggType, index: EggId }
struct EggStoreBufferItem {
  buffer: EggId, item_type: EggType, index: EggId, item: EggId
}
struct EggStoreBufferBytes { buffer: EggId, bytes: Slice[Byte] }
struct EggFreeBuffer { buffer: EggId, item_type: EggType }

fun signature(module: Module, name: String, params: Slice[EggType]): String {
  var b = string_builder().&
  b."{module}.{name}"
  for param in params do b." {param}"
  b.to_string()
}

fun return_type(fun_: EggFun): EggType { fun_.body.returns.type() }

fun verify(fun_: EggFun) {
  if fun_.body.captured().is_not_empty() then
    panic("function not self contained. it captures {fun_.body.captured().debug()}")
}
