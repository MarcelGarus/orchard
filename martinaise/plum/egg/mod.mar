| Expression-Guided Graph  
|
| A representation of code where we have used names to establish the connections
| between types, expressions, and functions.
| 
| Every Egg expression has a type. Function calls are resolved to specific
| functions based on the parameter types (aka function overloading) and we have
| figured out how types need to be substituted for things to work out.
| Speaking of types: Types no longer contain user-given names. Instead, we have
| inlined type definitions so that types are completely structural. For example,
| rather than (LinkedList Int), the Egg uses this type:
|
| (| empty: (&) more: (& item: (Int) rest: (^2)))

import ../plum.mar
import builder.mar
import builtins.mar
import dag.mar
import equivalent.mar
import format.mar
| import run.mar

| All EggExprs are allocated and managed by the DAG in dag.mar. This allows
| using EggIds everywhere instead of having to use references.

struct Egg { entry_point: String, funs: Map[String, EggFun] }
struct EggFun { body: EggBody }
struct EggBody { params: Slice[EggId], children: Slice[EggId], returns: EggId }
enum EggExpr {
  param: PlumType,
  case_param: EggCaseParam,

  | Byte stuff.
  byte: Byte,
  lower_byte: EggId,
  byte_to_int: EggId,

  | Int stuff.
  int: Int,
  add: Tuple2[EggId, EggId],
  subtract: Tuple2[EggId, EggId],
  multiply: Tuple2[EggId, EggId],
  divide: Tuple2[EggId, EggId],
  modulo: Tuple2[EggId, EggId],
  and_: Tuple2[EggId, EggId],
  or_: Tuple2[EggId, EggId],
  xor: Tuple2[EggId, EggId],
  compare: Tuple2[EggId, EggId],
  unchecked_divide: Tuple2[EggId, EggId],
  unchecked_modulo: Tuple2[EggId, EggId],

  | Struct stuff.
  struct_: Map[String, EggId],
  member: EggMember,

  | Enum stuff.
  enum_: EggEnum,
  switch_: EggSwitch,

  | Function and lambda stuff.
  inline_lambda: EggBody,
  raw_lambda: EggRawLambda,
  call_fun: EggCallFun,
  call_builtin: EggCallBuiltin,
  call_lambda: EggCallLambda,

  | Box stuff.
  box: EggId,
  unbox: EggId,

  | Array stuff.
  array: EggArray,
  generate_array: EggGenerateArray,
  array_get: EggArrayGet,
  array_set: EggArraySet,
  array_slice: EggArraySlice,
  array_len: EggId,
  unchecked_generate_non_empty_array: EggGenerateArray,
  unchecked_array_get: EggArrayGet,
  unchecked_array_set: EggArraySet,
  unchecked_array_slice: EggArraySlice,

  | String stuff.
  string: String,

  | Type stuff.
  type: PlumType,
  cast: EggCast,
  type_info: EggId,
  static_to_dynamic: EggId,
  dynamic_to_static: EggDynamicToStatic,

  | Crashes the VM.
  crash: EggCrash,

  | Marks code as unreachable. Code that definitely reaches this expression can
  | be optimized away. Note that this is different from crashing.
  unreachable: PlumType,

  | Loops.
  loop_: EggLoop,
  continue_: EggContinue,

  | ownership stuff
  dup: EggDup,
  drop: EggDrop,

  | memory stuff
  pesto_param: PestoType,
  function_ptr: String,
  pesto_call_fun: EggPestoCallFun,
  call_indirect: EggCallIndirect,
  new: EggId,
  load: EggLoad,
  free: EggFree,
  get_refcount: EggId,
  set_refcount: EggSetRefcount,
  new_buffer: EggNewBuffer,
  get_buffer_length: EggId,
  load_buffer_item: EggLoadBufferItem,
  store_buffer_item: EggStoreBufferItem,
  store_buffer_bytes: EggStoreBufferBytes,
  free_buffer: EggFreeBuffer,
  pesto_crash: EggPestoCrash,
  pesto_unreachable: PestoType,
  pesto_continue: EggPestoContinue,
}
struct EggCaseParam { switch_on: EggId, variant: String }
struct EggMember { of: EggId, name: String }
struct EggEnum { type: PlumType, variant: String, payload: EggId }
struct EggSwitch { condition: EggId, cases: Map[String, EggBody] }
struct EggRawLambda { fun_: String, closure: EggId, type: PlumType }
struct EggCallFun {
  fun_: String,
  substitutions: Substitutions,
  args: Slice[EggId],
  return_type: PlumType,
}
struct EggCallBuiltin {
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[EggId]
}
struct EggCallLambda { lambda: EggId, args: Slice[EggId] }
struct EggArray { items: Slice[EggId], item_type: PlumType }
struct EggGenerateArray { length: EggId, generator: EggBody }
struct EggArrayGet { array: EggId, index: EggId }
struct EggArraySet { array: EggId, index: EggId, item: EggId }
struct EggArraySlice { array: EggId, start: EggId, end: EggId }
struct EggDynamicToStatic { dynamic: EggId, static: PlumType }
struct EggCast { what: EggId, type: PlumType }
struct EggCrash { message: EggId, type: PlumType }
struct EggLoop { initial: Slice[EggId], body: EggBody }
struct EggContinue { next: Slice[EggId], type: PlumType }
struct EggDup { id: EggId, type: PlumType }
struct EggDrop { id: EggId, type: PlumType }
struct EggLoad { ptr: EggId, type: PestoType }
struct EggFree { ptr: EggId, type: PestoType }
struct EggSetRefcount { ptr: EggId, refcount: EggId }
struct EggNewBuffer { item_type: PestoType, length: EggId }
struct EggLoadBufferItem { buffer: EggId, item_type: PestoType, index: EggId }
struct EggStoreBufferItem {
  buffer: EggId, item_type: PestoType, index: EggId, item: EggId
}
struct EggStoreBufferBytes { buffer: EggId, bytes: Slice[Byte] }
struct EggFreeBuffer { buffer: EggId, item_type: PestoType }
struct EggPestoCallFun {
  fun_: String, args: Slice[EggId], return_type: PestoType
}
struct EggCallIndirect {
  function_ptr: EggId, args: Slice[EggId], return_type: PestoType
}
struct EggPestoCrash { message: EggId, type: PestoType }
struct EggPestoContinue { next: Slice[EggId], type: PestoType }

fun signature(module: Module, name: String, params: Slice[PlumType]): String {
  var b = string_builder().&
  b."{module}.{name}"
  for param in params do b." {param}"
  b.to_string()
}

fun return_type(fun_: EggFun): PlumType { fun_.body.returns.type() }

fun verify(fun_: EggFun) {
  if fun_.body.captured().is_not_empty() then
    panic("function not self contained. it captures {fun_.body.captured().debug()}")
}
