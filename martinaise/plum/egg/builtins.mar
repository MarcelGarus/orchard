import mod.mar

struct EggBuiltinType { name: String, args: Int }

var builtin_types =
  list(
    EggBuiltinType { name = "Never", args = 0 },
    EggBuiltinType { name = "Type", args = 0 },
    EggBuiltinType { name = "Byte", args = 0 },
    EggBuiltinType { name = "Int", args = 0 },
    EggBuiltinType { name = "Box", args = 1 },
    EggBuiltinType { name = "Array", args = 1 },
  ).to_slice()

| Plum code can import these functions from the "builtins" module.
enum EggBuiltinFun {
  | byte operations
  lower_byte,        | Int -> Byte
  byte_to_int,       | Byte -> Int

  | int operations
  | TODO: rename to full words
  | TODO: bitshifts?
  add_ints,          | Int Int -> Int
  sub_ints,          | Int Int -> Int
  mul_ints,          | Int Int -> Int
  div_ints,          | Int Int -> Int. Or crash: "divide by zero"
  mod_ints,          | Int Int -> Int. Or crash: "modulo by zero"
  and_ints,          | Int Int -> Int
  or_ints,           | Int Int -> Int
  xor_ints,          | Int Int -> Int
  compare_ints,      | Int Int -> Ordering

  | box operations
  box,               | t -> (Box t)
  unbox,             | (Box t) -> t

  | array operations
  generate_array,    | Int (\ Int -> t) -> (Array t).  Or crash: "negative length"
  array_get,         | (Array t) Int -> t.             Or crash: "out of bounds"
  array_set,         | (Array t) Int t -> (Array t).   Or crash: "out of bounds"
  array_slice,       | (Array t) Int Int -> (Array t). Or crash: "bad bounds"
  array_len,         | (Array t) -> Int | TODO: rename to full word

  | lambda operations
  call,              | (\ -> t) -> t

  | error stuff
  crash,             | String -> Never. Will crash.

  | type operations
  type_of,           | t -> Type
  type_info,         | Type -> TypeInfo

  | dynamic typing operations
  static_to_dynamic, | t -> Dynamic
  dynamic_to_static, | Dynamic -> t. Or crash: "bad shape"
}

var builtin_funs = | Keep in sync with the builtins above!
  list(
    EggBuiltinFun.lower_byte, EggBuiltinFun.byte_to_int,
    EggBuiltinFun.add_ints, EggBuiltinFun.sub_ints, EggBuiltinFun.mul_ints,
    EggBuiltinFun.div_ints, EggBuiltinFun.mod_ints, EggBuiltinFun.and_ints,
    EggBuiltinFun.or_ints, EggBuiltinFun.xor_ints,
    EggBuiltinFun.compare_ints,
    EggBuiltinFun.box, EggBuiltinFun.unbox,
    EggBuiltinFun.generate_array, EggBuiltinFun.array_get,
    EggBuiltinFun.array_set, EggBuiltinFun.array_slice, EggBuiltinFun.array_len,
    EggBuiltinFun.call,
    EggBuiltinFun.crash,
    EggBuiltinFun.type_of, EggBuiltinFun.type_info,
    EggBuiltinFun.static_to_dynamic, EggBuiltinFun.dynamic_to_static,
  ).to_slice()


struct BuiltinTypeSignature { params: Slice[FunParam], return_type: EggType }
fun type_signature(builtin: EggBuiltinFun): BuiltinTypeSignature {
  var params_and_return_type =
    switch builtin
    case lower_byte tuple(list(param("int", type_int)), type_byte)
    case byte_to_int tuple(list(param("byte", type_byte)), type_int)
    case add_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case sub_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case mul_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case div_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case mod_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case and_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case or_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case xor_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_int)
    case compare_ints
      tuple(list(param("a", type_int), param("b", type_int)), type_ordering)
    case box
      tuple(
        list(param("value", type_variable("a"))), type_box(type_variable("a"))
      )
    case unbox
      tuple(
        list(param("box", type_box(type_variable("a")))), type_variable("a")
      )
    case generate_array
      tuple(
        list(
          param("length", type_int),
          param(
            "generator",
            type_lambda(list(type_int).to_slice(), type_variable("a")),
          ),
        ),
        type_array(type_variable("a")),
      )
    case array_get
      tuple(
        list(
          param("array", type_array(type_variable("a"))),
          param("index", type_int),
        ),
        type_variable("a"),
      )
    case array_set
      tuple(
        list(
          param("array", type_array(type_variable("a"))),
          param("index", type_int),
          param("item", type_variable("a")),
        ),
        type_array(type_variable("a")),
      )
    case array_slice
      tuple(
        list(
          param("array", type_array(type_variable("a"))),
          param("range", type_range(type_int)),
        ),
        type_array(type_variable("a")),
      )
    case array_len
      tuple(list(param("array", type_array(type_variable("a")))), type_int)
    case call
      tuple(
        list(
          param(
            "lamdba", type_lambda(empty_slice[EggType](), type_variable("a"))
          ),
        ),
        type_variable("a"),
      )
    case crash
      tuple(list(param("message", type_string)), type_never)
    case type_of tuple(list(param("value", type_variable("a"))), type_type)
    case type_info tuple(list(param("type", type_type)), type_type_info)
    case static_to_dynamic
      tuple(list(param("value", type_variable("a"))), type_dynamic)
    case dynamic_to_static
      tuple(
        list(param("dynamic", type_dynamic), param("t", type_type)),
        type_variable("t"),
      )

  BuiltinTypeSignature {
    params = params_and_return_type.a.to_slice(),
    return_type = params_and_return_type.b,
  }
}
