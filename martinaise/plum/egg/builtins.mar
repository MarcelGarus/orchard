import mod.mar

struct EggBuiltinType { name: String, args: Int }

var builtin_types =
  list(
    EggBuiltinType { name = "Never", args = 0 },
    EggBuiltinType { name = "Type", args = 0 },
    EggBuiltinType { name = "Byte", args = 0 },
    EggBuiltinType { name = "Int", args = 0 },
    EggBuiltinType { name = "Box", args = 1 },
    EggBuiltinType { name = "Array", args = 1 },
  ).to_slice()

| Plum code can import these functions from the "builtins" module.
enum EggBuiltinFun {
  | byte operations
  lower_byte,        | Int -> Byte
  byte_to_int,       | Byte -> Int

  | int operations
  | TODO: rename to full words
  | TODO: bitshifts?
  add_ints,          | Int Int -> Int
  sub_ints,          | Int Int -> Int
  mul_ints,          | Int Int -> Int
  div_ints,          | Int Int -> Int. Or crash: "divide by zero"
  mod_ints,          | Int Int -> Int. Or crash: "modulo by zero"
  and_ints,          | Int Int -> Int
  or_ints,           | Int Int -> Int
  xor_ints,          | Int Int -> Int
  compare_ints,      | Int Int -> Ordering

  | box operations
  box,               | t -> (Box t)
  unbox,             | (Box t) -> t

  | array operations
  generate_array,    | Int (\ Int -> t) -> (Array t).  Or crash: "negative length"
  array_get,         | (Array t) Int -> t.             Or crash: "out of bounds"
  array_set,         | (Array t) Int t -> (Array t).   Or crash: "out of bounds"
  array_slice,       | (Array t) Int Int -> (Array t). Or crash: "bad bounds"
  array_len,         | (Array t) -> Int | TODO: rename to full word

  | lambda operations
  call,              | (\ -> t) -> t

  | error stuff
  crash,             | String -> Never. Will crash.

  | type operations
  type_of,           | t -> Type
  type_info,         | Type -> TypeInfo

  | dynamic typing operations
  static_to_dynamic, | t -> Dynamic
  dynamic_to_static, | Dynamic -> t. Or crash: "bad shape"
}

var builtin_funs = | Keep in sync with the builtins above!
  list(
    EggBuiltinFun.lower_byte, EggBuiltinFun.byte_to_int,
    EggBuiltinFun.add_ints, EggBuiltinFun.sub_ints, EggBuiltinFun.mul_ints,
    EggBuiltinFun.div_ints, EggBuiltinFun.mod_ints, EggBuiltinFun.and_ints,
    EggBuiltinFun.or_ints, EggBuiltinFun.xor_ints,
    EggBuiltinFun.compare_ints,
    EggBuiltinFun.box, EggBuiltinFun.unbox,
    EggBuiltinFun.generate_array, EggBuiltinFun.array_get,
    EggBuiltinFun.array_set, EggBuiltinFun.array_slice, EggBuiltinFun.array_len,
    EggBuiltinFun.call,
    EggBuiltinFun.crash,
    EggBuiltinFun.type_of, EggBuiltinFun.type_info,
    EggBuiltinFun.static_to_dynamic, EggBuiltinFun.dynamic_to_static,
  ).to_slice()


struct BuiltinTypeSignature { params: Slice[EggType], return_type: EggType }
fun type_signature(builtin: EggBuiltinFun): BuiltinTypeSignature {
  var params_and_return_type =
    switch builtin
    case lower_byte tuple(list(type_int), type_byte)
    case byte_to_int tuple(list(type_byte), type_int)
    case add_ints tuple(list(type_int, type_int), type_int)
    case sub_ints tuple(list(type_int, type_int), type_int)
    case mul_ints tuple(list(type_int, type_int), type_int)
    case div_ints tuple(list(type_int, type_int), type_int)
    case mod_ints tuple(list(type_int, type_int), type_int)
    case and_ints tuple(list(type_int, type_int), type_int)
    case or_ints tuple(list(type_int, type_int), type_int)
    case xor_ints tuple(list(type_int, type_int), type_int)
    case compare_ints tuple(list(type_int, type_int), type_ordering)
    case box tuple(list(type_var_t), type_box(type_var_t))
    case unbox tuple(list(type_box(type_var_t)), type_var_t)
    case generate_array
      tuple(
        list(type_int, type_lambda(list(type_int).to_slice(), type_var_t)),
        type_array(type_var_t),
      )
    case array_get tuple(list(type_array(type_var_t), type_int), type_var_t)
    case array_set
      tuple(
        list(type_array(type_var_t), type_int, type_var_t),
        type_array(type_var_t),
      )
    case array_slice
      tuple(
        list(type_array(type_var_t), type_range(type_int)),
        type_array(type_var_t),
      )
    case array_len tuple(list(type_array(type_var_t)), type_int)
    case call
      tuple(list(type_lambda(empty_slice[EggType](), type_var_t)), type_var_t)
    case crash tuple(list(type_string), type_never)
    case type_of tuple(list(type_var_t), type_type)
    case type_info tuple(list(type_type), type_type_info)
    case static_to_dynamic tuple(list(type_var_t), type_dynamic)
    case dynamic_to_static
      tuple(list(type_dynamic, type_type), type_variable("arg_1"))
  BuiltinTypeSignature {
    params = params_and_return_type.a.to_slice(),
    return_type = params_and_return_type.b,
  }
}
