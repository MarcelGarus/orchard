| The Pear Interpreter  

import ../../martinaise/stdlib.mar

fun exit(status: Int, message: String): Never {
  stderr.write(message)
  exit(status)
}

| Values  
|
| The values that exist in Pear. Some of these don't have a textual
| representation. For example, you just use special words such as @add for
| builtins and expect the environment to swap these out with values before
| executing.

enum Value {
  number: Int,     | 2
  tag: String,     | :foo
  builtin: String, | @add
  struct_: Struct, | (& x 2 y 3)
  lambda: Lambda,  | (\ (a b) (+ a b))
}
struct Struct { fields: Map[String, Value] }
struct Lambda { env: &Env, params: Slice[String], body: &Code }

enum Code {
  value: Value,        | 2, :foo
  word: String,        | foo
  struct_: CodeStruct, | (& x 2 y 3)
  lambda: CodeLambda,  | (\ a b (+ a b))
  let: CodeLet,        | (let a 2 b a (& x a y b))
  if_: CodeIf,         | (if :true 2 3)
  apply: CodeApply,    | (a b c)
}
struct CodeStruct { fields: Map[String, Code] }
struct CodeLambda { params: Slice[String], body: &Code }
struct CodeLet { name: String, value: &Code, body: &Code }
struct CodeIf { condition: &Code, then_: &Code, else_: &Code }
struct CodeApply { what: &Code, args: Slice[Code] }

struct Env { parent: Maybe[&Env], name: String, value: Value }

var ansi_escape = AnsiEscape {}
struct AnsiEscape {}
fun write[W](writer: W, ansi_escape: AnsiEscape) {
  writer.write_byte(27.lower_byte())
}

var style_of_type = "36"
var style_of_black_hole = "40;37"

fun styled[T](content: T, style: String): Styled[T] {
  Styled { content, style }
}
struct Styled[T] { style: String, content: T }
fun write[W, T](writer: W, styled: Styled[T]) {
  writer."{ansi_escape}[{styled.style}m{styled.content}{ansi_escape}[0m"
}


fun write[W](writer: W, value: Value) {
  switch value
  case number(number) writer."{number.styled("32")}"
  case tag(tag) {
    var str = ":{tag}"
    writer."{str.styled("34")}"
  }
  case struct_(struct_) {
    writer."(&"
    for field in struct_.fields do writer." {field.key} {field.value}"
    writer.")"
  }
  case lambda(lambda) {
    writer."(\\"
    for param in lambda.params do writer." {param}"
    writer." {lambda.body})"
  }
  case builtin(builtin) writer."@{builtin}"
}

fun write[W](writer: W, code: Code) {
  switch code
  case value(value) writer."{value}"
  case word(word) writer."{word}"
  case let(let) writer."({"let".styled("35")} {let.name} {let.value} {let.body})"
  case struct_(struct_) {
    writer."(&"
    for field in struct_.fields do writer." {field.key} {field.value}"
    writer.")"
  }
  case lambda(lambda) {
    writer."(\\"
    for param in lambda.params do writer." {param}"
    writer." {lambda.body})"
  }
  case if_(if_) writer."({"if".styled("35")} {if_.condition} {if_.then_} {if_.else_})"
  case apply(apply) {
    writer."({apply.what.*}"
    for arg in apply.args do writer." {arg}"
    writer.")"
  }
}

fun ==(a: Value, b: Value): Bool {
  switch a
  case number(a)  if b is number(b)  then a == b else false
  case tag(a)     if b is tag(b)     then a == b else false
  case builtin(a) if b is builtin(b) then a == b else false
  case struct_(a) if b is struct_(b) then a == b else false
  case lambda(a)  if b is lambda(b)  then a == b else false
}
fun ==(a: Struct, b: Struct): Bool { a.fields == b.fields }
fun ==(a: Lambda, b: Lambda): Bool {
  a.env.to_address() == b.env.to_address()
    and a.params == b.params and a.body.* == b.body.*
}

fun ==(a: Code, b: Code): Bool {
  switch a
  case value(a) if b is value(b) then a == b else false
  case word(a) if b is word(b) then a == b else false
  case struct_(a) if b is struct_(b) then a == b else false
  case lambda(a) if b is lambda(b) then a == b else false
  case let(a) if b is let(b) then a == b else false
  case if_(a) if b is if_(b) then a == b else false
  case apply(a) if b is apply(b) then a == b else false
}
fun ==(a: CodeStruct, b: CodeStruct): Bool { a.fields == b.fields }
fun ==(a: CodeLambda, b: CodeLambda): Bool { a.params == b.params and a.body.* == b.body.* }
fun ==(a: CodeLet, b: CodeLet): Bool { a.name == b.name and a.value.* == b.value.* and a.body.* == b.body.* }
fun ==(a: CodeIf, b: CodeIf): Bool { a.condition.* == b.condition.* and a.then_.* == b.then_.* and a.else_.* == b.else_.* }
fun ==(a: CodeApply, b: CodeApply): Bool { a.what.* == b.what.* and a.args == b.args }

| Parsing  
|
| Turning a string into code.

fun parse(code: String): Code {
  Parser { input = code, cursor = 0 }.&.parse().unwrap()
}

struct Parser { input: String, cursor: Int }

fun is_at_end(parser: Parser): Bool { parser.cursor == parser.input.len }
fun current(parser: Parser): Char { parser.input.get(parser.cursor) }
fun advance(parser: &Parser) { parser.cursor = parser.cursor + 1 }
fun consume_whitespace(parser: &Parser) {
  loop {
    if parser.is_at_end() then break
    if parser.current() == ## then
      loop {
        parser.advance()
        if parser.is_at_end() then break
        if parser.current() == newline then  break
      }
    if parser.is_at_end() then break
    parser.current().is_whitespace() or break
    parser.advance()
  }
}
fun parse_word(parser: &Parser): Maybe[String] {
  var start = parser.cursor
  loop {
    if parser.is_at_end() then break
    if parser.current() == #( or parser.current() == #)
      or parser.current().is_whitespace() or parser.current() == ##
    then break
    parser.advance()
  }
  var end = parser.cursor
  if start == end then none[String]() else some(parser.input.substr(start..end))
}
fun parse(parser: &Parser): Maybe[Code] {
  parser.consume_whitespace()
  if parser.is_at_end() then return none[Code]()
  if parser.current() == #) then return none[Code]()
  | Number
  if parser.current().is_digit() then {
    var num = 0
    loop {
      var digit = "0123456789".iter().&.find(parser.current()) or break
      num = num * 10 + digit
      parser.advance()
      if parser.is_at_end() then break
    }
    return some(Code.value(Value.number(num)))
  }
  | Tag
  if parser.current() == #: then {
    parser.advance()
    var tag = parser.parse_word() or panic("expected tag")
    return some(Code.value(Value.tag(tag)))
  }
  | Builtin
  if parser.current() == #@ then {
    parser.advance()
    var builtin = parser.parse_word() or panic("expected builtin")
    return some(Code.value(Value.builtin(builtin)))
  }
  | Word
  if parser.parse_word() is some(word) then return some(Code.word(word))
  | Stuff with parentheses
  if parser.current() == #( then {
    parser.advance()
    var children = list[Code]()
    loop children.&.push(parser.parse() or break)
    if parser.is_at_end() then panic("list without closing paren")
    parser.current() == #) or panic("expected closing paren")
    parser.advance()
    var children = children.to_slice()
    if children.is_empty() then panic("empty parens")
    var first = children.first()
    var rest = children.without_first()
    | Struct
    if first == Code.word("&") then {
      var fields = map[String, Code]()
      if rest.len % 2 == 1 then panic("invalid struct")
      for i in 0..{rest.len / 2} do
        fields.&.put(rest.get(2 * i).word.unwrap(), rest.get(2 * i))
      return some(Code.struct_(CodeStruct { fields }))
    }
    | Lambda
    if first == Code.word("\\") then {
      var params = list[String]()
      for param in rest.without_last() do params.&.push(param.word.unwrap())
      return some(Code.lambda(CodeLambda {
        params = params.to_slice(), body = children.last().put_on_heap()
      }))
    }
    | Let
    if first == Code.word("let") then {
      if rest.len % 2 == 0 then panic("invalid let")
      var result = rest.last()
      rest = rest.without_last()
      loop {
        if rest.is_empty() then break
        var name = rest.get(rest.len - 2).word.unwrap()
        var value = rest.get(rest.len - 1)
        rest = rest.without_last(2)
        result = Code.let(CodeLet {
          name, value = value.put_on_heap(), body = result.put_on_heap()
        })
      }
      return some(result)
    }
    | If
    if first == Code.word("if") then
      return some(Code.if_(CodeIf {
        condition = rest.get(0).put_on_heap(),
        then_ = rest.get(1).put_on_heap(),
        else_ = rest.get(2).put_on_heap(),
      }))
    | Apply
    return some(Code.apply(CodeApply {
      what = children.first().put_on_heap(), args = children.without_first()
    }))
  }
  none[Code]()
}

fun empty_env(): Env {
  Env { parent = none[&Env](), name = "", value = Value.number(42) }
}
fun bind(env: Env, name: String, value: Value): Env {
  Env { parent = some(env.put_on_heap()), name, value }
}
fun lookup(env: Env, name: String): Value {
  if env.name == name then return env.value
  if env.parent is some(parent) then return parent.lookup(name)
  panic("{name} is not defined")
}

| fun fill(code: Code, name: String, value: Value): Code {
|   switch code
|   case value code
|   case word(word) if word == name then Code.value(value) else code
|   case let(let)
|     if let.name == name then
|       code
|     else
|       Code.let(CodeLet {
|         name = let.name,
|         value = let.value.fill(name, value),
|         body = let.body.fill(name, value),
|       })
|   case struct_(struct_) {
|     var fields = map[String, Code]()
|     for field in struct_ do
|       fields.&.put(field.key, field.value.fill(name, value))
|     Code.struct_(fields)
|   }
|   case lambda(lambda) {
|     for param in lambda.params do if param == name then return code
|     Code.lambda(CodeLambda {
|       params = lambda.params, body = lambda.body.fill(name, value)
|     })
|   }
|   case if_(if_)
|     Code.if_(CodeIf {
|       condition = if_.condition.fill(name, value),
|       then_ = if_.then_.fill(name, value),
|       else_ = if_.else_.fill(name, value),
|     })
|   case apply(apply) {
|     var args = list[Code]()
|     for arg in apply.args do args.&.push(arg.fill(name, value))
|     Code.apply(CodeApply { what = apply.what.fill(name, value), args = args.to_slice() })
|   }
| }

fun eval(code: Code, env: Env): Value {
  switch code
  case value(value) value
  case word(word) env.lookup(word)
  case let(let) let.body.eval(env.bind(let.name, let.value.eval(env)))
  case struct_(struct_) {
    var fields = map[String, Value]()
    for field in struct_.fields do
      fields.&.put(field.key, field.value.eval(env))
    Value.struct_(Struct { fields })
  }
  case lambda(lambda) {
    Value.lambda(Lambda {
      env = env.put_on_heap(), params = lambda.params, body = lambda.body
    })
  }
  case if_(if_) {
    var condition = if_.condition.eval(env).tag.unwrap()
    if condition == "true" then
      if_.then_.eval(env)
    else if condition == "false" then
      if_.else_.eval(env)
    else
      panic("invalid if condition")
  }
  case apply(apply) {
    var what = apply.what.eval(env)
    var args = list[Value]()
    for arg in apply.args do args.&.push(arg.eval(env))
    var args = args.to_slice()

    switch what
    case struct_(struct_) {
      args.len == 1 or panic("apply struct with {args.len} args")
      var field = args.get(0).tag.unwrap()
      struct_.fields.get(field)
    }
    case lambda(lambda) {
      lambda.params.len == args.len
      var body = lambda.body.*
      var env = env
      for both in zip(lambda.params.iter(), args.iter()) do
        env = env.bind(both.a, both.b)
      body.eval(env)
    }
    case builtin(builtin) {
      if builtin == "add" then {
        args.len == 2 or panic("add needs 2 args")
        return Value.number(args.get(0).number.unwrap() + args.get(1).number.unwrap())
      }
      if builtin == "subtract" then {
        args.len == 2 or panic("subtract needs 2 args")
        return Value.number(args.get(0).number.unwrap() - args.get(1).number.unwrap())
      }
      if builtin == "multiply" then {
        args.len == 2 or panic("multiply needs 2 args")
        return Value.number(args.get(0).number.unwrap() * args.get(1).number.unwrap())
      }
      if builtin == "divide" then {
        args.len == 2 or panic("divide needs 2 args")
        return Value.number(args.get(0).number.unwrap() / args.get(1).number.unwrap())
      }
      panic("unknown builtin {builtin}")
    }
    default panic("invalid apply")
  }
}

fun eval_file(path: String): Value {
  var content = read_file(path) or exit(1, "Couldn't read file from {path}")
  var content = content.to_string()
  eprintln("{content.bytes().len} bytes of content")
  var code = content.parse()
  eprintln("code: {code}")
  code.eval(empty_env())
  | todo("eval")
  | code.fill(
  |   "builtins",
  |   Value.struct_(map(
  |     "add" -> Value.builtin(Builtin.add),
  |     "subtract" -> Value.builtin(Builtin.subtract),
  |     "multiply" -> Value.builtin(Builtin.multiply),
  |     "divide" -> Value.builtin(Builtin.divide),
  |   ))
  | ).eval()
}

fun main(): Never {
  eprintln("Welcome to the Pear interpreterssss!")

  var args = get_process_args()
  var path = "pear.pear" | args.get_maybe(1) or exit(1, "You didn't specify a file.\n")
  var result = eval_file(path)
  eprintln("{result}")

  exit(0)
}
