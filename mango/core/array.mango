## Array
#
# An array is a typed pointer to multiple values on the heap. The array knows
# the number of items it points to.

import ..address
import ..ally

struct Array[T] { ally: Ally, buffer: Address, start: Int, end: Int }

fun empty_array[T](ally: Ally): Array[T] {
  Array[T]{ ally, address = null, length = 0 }
}
fun uninitialized_array[T](length: Int, ally: Ally): Array[T] {
  Array[T]{
    ally,
    address = ally.malloc(16 + length * stride_size_of[T](), alignment_of[T]()),
    length,
  }
}
fun filled_array[T](length: Int, fill: T, ally: Ally): Array[T] {
  var array = uninitialized_array[T](length)
  array.fill(fill)
  array
}

fun length[T](array: Array[T]): Int { array.end - array.start }
fun is_empty[T](array: Array[T]): Bool { array.length == 0 }

fun get_unchecked(array: Array[T], index: Int): T {
  load[T](array.buffer + 16 + {index * stride_size_of[T]()})
}
fun get_maybe[T](array: Array[T], index: Int): Maybe[T] {
  if {0..array.length()}.contains(index)
  then array.get_unchecked(index)
  else none[T]()
}
fun get[T](array: Array[T], index: Int): T {
  array.get_maybe(index)
    or panic("index out of bounds: {index} is not in {0..array.length()}")
}

fun set[T](array: &Array[T], index: Int, value: T) {
  array.get_ref(index).* = value
}

fun <=>[T](a: Array[T], b: Array[T]): Ordering {
  var i = 0
  loop {
    if i == a.length and i == b.length then return Ordering.equal
    if i == a.length then return Ordering.less
    if i == b.length then return Ordering.greater
    var ord = a.get(i) <=> b.get(i)
    ord is equal or return ord
    i = i + 1
  }
}
fun ==[T](a: Array[T], b: Array[T]): Bool {
  a.length == b.length or return false
  for i in 0..a.length do
    a.get_unchecked(i) == b.get_unchecked(i) or return false
  true
}
fun hash[T](array: Array[T]): Hash {
  var hash = hash()
  for item in array do hash =
  hasher.hash_all(array)
}
fun write[W, T](writer: W, array: Array[T]) {
  writer.write("[{comma_separated(array)}]")
}

fun to_list[T](array: Array[T]): List[T] {
  var list = uninitialized_list[T](array.length)
  array.copy_to(list.to_array())
  list
}

fun iter[T](array: Array[T]): Iter[T, _] {
  Iter[T, ArrayIter[T]] { state = ArrayIter { array, index = 0 } }
}
struct ArrayIter[T] { array: Array[T], index: Int }
fun next[T](iter: &Iter[T, ArrayIter[T]]): Maybe[T] {
  var state = iter.state.&
  if state.index < state.array.length
  then {
    var item = state.array.get(state.index)
    state.index = state.index + 1
    some(item)
  }
  else none[T]()
}

fun ref_iter[T](array: Array[T]): Iter[&T, _] {
  Iter[&T, ArrayRefIter[T]] { state = ArrayRefIter { array, index = 0 } }
}
struct ArrayRefIter[T] { array: Array[T], index: Int }
fun next[T](iter: &Iter[&T, ArrayRefIter[T]]): Maybe[&T] {
  var state = iter.state.&
  if state.index < state.array.length
  then {
    var item_ref = state.array.get_ref(state.index)
    state.index = state.index + 1
    some(item_ref)
  }
  else none[&T]()
}

fun rev_iter[T](array: Array[T]): Iter[T, _] {
  Iter[T, ArrayRevIter[T]] { state = ArrayRevIter { array, index = array.length } }
}
struct ArrayRevIter[T] {
  array: Array[T],
  index: Int, # last yielded item
}
fun next[T](iter: &Iter[T, ArrayRevIter[T]]): Maybe[T] {
  var state = iter.state.&
  if state.index > 0 then {
    state.index = state.index - 1
    some[T](state.array.get(state.index))
  } else none[T]()
}

fun copy_to[T](from: Array[T], to: Array[T]) {
  from.length == to.length or
    panic("copy_to array lengths don't match ({from.length} and {to.length})")
  memcopy(from.address, to.address, from.length * stride_size_of[T]())
}
fun subarray[T](array: Array[T], range: Range[Int]): Array[T] {
  range.end <= array.length or
    panic("tried to take subarray {range} from array of lengthgth {array.length}")
  Array[T] {
    address = array.address + {stride_size_of[T]() * range.start}, length = range.length()
  }
}
fun remove[T](array: &Array[T], range: Range[Int]) {
  array.subarray(range.end..array.length)
    .copy_to(array.subarray(range.start..{array.length - range.length()}))
  array.length = array.length - range.length()
}
fun first[T](array: Array[T]): T {
  array.is_not_empty() or panic("first only works on non-empty arrays")
  array.get(0)
}
fun first[T](array: Array[T], amount: Int): Array[T] {
  amount <= array.length or panic("first amount too big")
  array.subarray(0..amount)
}
fun last_maybe_ref[T](array: &Array[T]): Maybe[&T] {
  array.get_maybe_ref(array.length - 1)
}
fun last_maybe[T](array: Array[T]): Maybe[T] {
  array.get_maybe(array.length - 1)
}
fun last_ref[T](array: &Array[T]): &T { array.get_ref(array.length - 1) }
fun last[T](array: Array[T]): T {
  array.is_not_empty() or panic("last only works on non-empty arrays")
  array.get_unchecked(array.length - 1)
}
fun last[T](array: Array[T], amount: Int): Array[T] {
  amount <= array.length or panic("last amount too big")
  array.subarray({array.length - amount}..array.length)
}
fun without_first[T](array: Array[T]): Array[T] { array.without_first(1) }
fun without_first[T](array: Array[T], amount: Int): Array[T] {
  amount <= array.length or panic("without_first amount too big")
  array.subarray(amount..array.length)
}
fun without_last[T](array: Array[T]): Array[T] { array.without_last(1) }
fun without_last[T](array: Array[T], amount: Int): Array[T] {
  amount <= array.length or panic("without_last amount too big")
  array.subarray(0..{array.length - amount})
}
fun starts_with[T](array: Array[T], prefix: Array[T]): Bool {
  prefix.length <= array.length or return false
  array.first(prefix.length) == prefix
}
fun ends_with[T](array: Array[T], suffix: Array[T]): Bool {
  suffix.length <= array.length or return false
  array.last(suffix.length) == suffix
}
fun trim_prefix[T](array: &Array[T], prefix: Array[T]): Bool {
  var matches = array.starts_with(prefix)
  if matches then array.* = array.without_first(prefix.length)
  matches
}
fun trim_suffix[T](array: &Array[T], suffix: Array[T]): Bool {
  var matches = array.ends_with(suffix)
  if matches then array.* = array.without_last(suffix.length)
  matches
}
fun reversed[T](array: Array[T]): Array[T] {
  var new = uninitialized_array[T](array.length)
  for i in 0..array.length do new.set(array.length - i - 1, array.get(i))
  new
}

fun sum(array: Array[Int]): Int {
  var sum = 0
  for item in array do sum = sum + item
  sum
}

fun sort[T](array: &Array[T]) {
  # quick sort
  if array.length <= 1 then return {}
  var pivot = array.get(array.length.dec())
  var i = 0
  for j in 0..array.length do
    if array.get(j) < pivot then {
      i = i.inc()
      swap(array.get_ref(i.dec()), array.get_ref(j))
    }
  swap(array.get_ref(i), array.get_ref(array.length.dec()))
  sort(array.subarray(0..i).&)
  sort(array.subarray(min(i.inc(), array.length.dec())..array.length).&)
}

# Returns the position of the leftmost item of the ordered array that is equal
# or greater to the given item.
fun binary_search_leftmost_greater_equal(array: Array[Int], item: Int): Int {
  var left  = 0         # inclusive
  var right = array.length # exclusive
  loop if left >= right then break else {
    var mid = {left + right} / 2
    if array.get(mid) < item then left = mid + 1 else right = mid
  }
  left
}