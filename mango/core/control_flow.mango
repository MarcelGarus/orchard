## And and Or
#
# Martinaise has "and" and "or" keywords, which allow short-circuiting. They are
# keywords because they control the program flow just as much as an if or a
# switch.
#
# Here are cases where the control flow short-circuits and the alternatives
# don't get evaluated:
#
# false and crash() # this is false
# true or crash()   # this is true
# some(2) or 3      # this is 2
# 
# In these cases, the control flow doesn't short-circuit and the alternatives
# are evaluated as well:
#
# false or foo      # this is foo
# true and stuff    # this is stuff
# none[Int]() or 3  # this is 3
#
# The "and" and "or" keywords turn into a call of left.and() or left.or(), which
# returns a ControlFlow. This logic flow determines whether the expression
# short-circuits or not.

import stdlib.mar

enum ControlFlow[T, A] { short_circuit: T, evaluate_alternative: A }
