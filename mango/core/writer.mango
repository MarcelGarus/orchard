import stdlib.mar

struct Writer {

}

fun write_byte(writer: Writer, byte: Byte): Writer {}




# String Building  
# To build strings efficiently, we need some sort of growable buffer where we
# can append more data over time. That's exactly what a StringBuilder is.

struct StringBuilder { bytes: List[Byte] }

fun string_builder(): StringBuilder { StringBuilder { bytes = list[Byte]() } }
fun write_byte(builder: &StringBuilder, byte: Byte) {
  builder.bytes.&.push(byte)
}
fun write_bytes(builder: &StringBuilder, bytes: Slice[Byte]) {
  builder.bytes.&.push_all(bytes)
}
fun len(builder: StringBuilder): Int { builder.bytes.len }
fun truncate_to_len(builder: &StringBuilder, len: Int) {
  len <= builder.bytes.len or panic("new len is too big")
  builder.bytes.len = len
}
fun write[W](writer: W, sb: StringBuilder) {
  writer.write_bytes(sb.bytes.to_slice())
}
fun to_string(builder: StringBuilder): String {
  builder.bytes.to_slice().to_string()
}



# Formatting  
# You should implement a write[Writer](Writer, T) function for types that can be
# printed. Writers are anything that has a write_byte(Writer, Byte) function and
# a write_bytes(Writer, Slice[Byte]) function.

fun format[T](value: T): String { "{value}" }

fun writeln[W](writer: W) { writer.write(newline) }
fun writeln[W, T](writer: W, value: T) { writer.write(value) writer.writeln() }

fun write[W, T](writer: W, value: &T) { writer.write(value.*) }

fun comma_separated[I](iter: I): CommaSeparatedFormat[I] {
  CommaSeparatedFormat { iter }
}
struct CommaSeparatedFormat[I] { iter: I }
fun write[W, T](writer: W, format: CommaSeparatedFormat[T]) {
  var first = true
  for item in format.iter do {
    if first then first = false else writer.write(", ")
    writer.write(item)
  }
}

fun buffered_writer[W](writer: W, capacity: Int): BufferedWriter[W] {
  capacity > 0 or panic("The capacity of a BufferedWriter must be positive.")
  BufferedWriter {
    buffer = filled_slice(capacity, 0.lower_byte()), len = 0, inner = writer
  }
}
struct BufferedWriter[W] { buffer: Slice[Byte], len: Int, inner: W }
fun flush[W](self: &BufferedWriter[W]) {
  self.inner.write_bytes(self.buffer.first(self.len))
  self.len = 0
}
fun amount_free[W](self: BufferedWriter[W]): Int {
  self.buffer.len - self.len
}
fun write_byte[W](self: &BufferedWriter[W], byte: Byte) {
  if self.amount_free() == 0 then self.flush()
  self.buffer.get_ref(self.len).* = byte
  self.len = self.len.inc()
}
fun write_bytes[W](self: &BufferedWriter[W], bytes: Slice[Byte]) {
  if bytes.len <= self.amount_free() then
    for byte in bytes do self.write_byte(byte)
  else {
    self.flush()
    if bytes.len <= self.amount_free()
    then for byte in bytes do self.write_byte(byte)
    else self.inner.write_bytes(bytes)
  }
}

# Debug printing  
# Just like the write function, you can also implement a write_debug function to
# customize how a value is formatted when debugging. If you don't, the compiler
# auto-generates an implementation.

fallback fun write_debug[W, T](writer: W, value: T) { ... }

fun debug[T](value: T): Debug[T] { Debug { value } }
struct Debug[T] { value: T }
fun write[W, T](writer: W, debug: Debug[T]) { writer.write_debug(debug.value) }




struct Print {}
var stdout = Print {}
fun print[T](value: T) { stdout.write(value) }
fun println() { print(newline) }
fun println[T](value: T) { print(value) println() }
fun write_byte(print: Print, byte: Byte) asm {
  moveib a 8 add a sp | byte.&
  moveib b 1
  syscall 1 ret
}
fun write_bytes(print: Print, bytes: Slice[Byte]) asm {
  moveib a 8  add a sp load a a | bytes.data
  moveib b 16 add b sp load b b | bytes.len
  syscall 1 ret
}

struct Log {}
var stderr = Log {}
fun eprint[T](value: T) { stderr.write(value) }
fun eprintln() { eprint(newline) }
fun eprintln[T](value: T) { eprint(value) eprintln() }
fun log[T](value: T) { eprint(value) eprintln() }
fun write_byte(log: Log, byte: Byte) asm {
  moveib a 8 add a sp | byte.&
  moveib b 1
  syscall 2 ret
}
fun write_bytes(log: Log, bytes: Slice[Byte]) asm {
  moveib a 8  add a sp load a a | bytes.data
  moveib b 16 add b sp load b b | bytes.len
  syscall 2 ret
}
