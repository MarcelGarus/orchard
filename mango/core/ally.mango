## The Ally
#
# Sometimes you need to allocate memory where its lifetime is not tied to the
# current stack frame.
#
# Programmers have come up with the heap as a solution: that a good
# 
# Ally is an opinionated arena allocator. If you create an Ally and allocate
# memory through it, it will use the VM's malloc_word_aligned instructions to
# get you memory.

import core.mar

fun malloc(size: Size): Address ground {
  d7                          # malloc_word aligned              (addr)
  c4 00 00 00 00 00 00 00 00  # push_word_from_stack 0           (addr addr)
  f1 03 ^oom ^worked ^worked  # jump_table ^oom ^worked ^worked  (addr)

  @worked  # Allocation worked: Return!
  f5                          # return  (addr)

  @oom  # Allocation didn't work: Try to allocate 3 bytes for the string "oom".
  d0 03 00 00 00 00 00 00 00  # push_word 3                (3)
  d7                          # malloc_byte_aligned        (addr)
  c4 00 00 00 00 00 00 00 00  # push_word_from_stack 0     (addr addr)
  a5                          # compare_zero               (addr ord)
  f1 03 ^ugh ^meh ^meh        # jump_table ^ugh ^meh ^meh  (addr)

  @meh # We could at least allocate 3 bytes for "oom".
  c4 00 00 00 00 00 00 00 00           # push_word_from_stack 0  (addr addr)
  d6 03 00 00 00 00 00 00 00 6f 6f 6d  # store_bytes "oom"       (addr)
  d0 03 00 00 00 00 00 00 00           # push_word 3             (addr 3)
  e0                                   # crash

  @ugh  # Not even allocating 3 bytes for "oom" worked.
  d0 00 00 00 00 00 00 00 00  # push_word 0  (addr 0)
  d0 00 00 00 00 00 00 00 00  # push_word 0  (addr 0 0)
  e0                          # crash
}

fun free(address: Address, size: Size) ground {
  d1  # free_word_aligned
  f5  # return
}

# Ally tries to avoid using the (typically expensive) malloc_word_aligned
# instruction for small allocations. Instead, it groups many small allocations
# into few actual allocations.
# 
# To be able to free all memory at the end, Ally maintains a list of actual
# allocations, called "pages". There are two types of pages:
# 
# - Arena pages house the memory of small allocations. Ally always has a current
#   arena page that it can append small allocations to. Once the page fills up,
#   it allocates a new arena page.
# - Blob pages house the memory of big allocations that don't fit into an arena
#   page (all arena pages have a fixed size configured during Ally creation).
# 
# Here are the memory layouts of the two types of pages:
# 
# ┌──────────┐  ┌──────────┐
# │ previous │  │ previous │
# │ size     │  │ size     │
# │ used     │  │ ...      │
# │ ...      │  │          │
# └──────────┘  └──────────┘
#  arena page    blob page
# 
# You might notice that both kinds of pages have a somewhat compatible memory
# layout. That's because the pages form an intrusive linked list, where the
# `previous` Address points to the previous page, or null if there is no
# previous one. The size is the size of the current page in bytes, including the
# header (with the previous pointer etc.). The used amount in the arena pages is
# the number of bytes of the page that are used. It starts at 24 because the
# header takes up the first 24 bytes.

struct Ally { arena: Box[Address] }
struct PageHeader { previous: Address, size: Int }
struct ArenaHeader { previous: Address, size: Int, used: Int }
enum Alignment { byte, word }

fun ally(arena_size: Int): Ally {
  assert(arena_size >= 32)
  arena = malloc(arena_size)
  arena.store(ArenaHeader{ previous = null, size = arena_size, used = 24 })
  Ally{ arena }
}

fun malloc(ally: Ally, size: Int, alignment: Alignment): Address {
  current_arena = ally.arena.unbox()
  header = current_arena.load[ArenaHeader]()
  previous = header.previous
  arena_size = header.arena_size
  used = header.used

  if 24 + size > arena_size then {
    # This allocation doesn't even fit into an empty arena page. Allocate a blob
    # page for it and insert it before the current arena.
    # Before: previous <- arena
    # After:  previous <- blob <- arena
    blob = malloc(16 + size)
    blob.store(PageHeader{ previous, size = 16 + size })
    address = blob + 16
    current_arena.store(ArenaHeader{ previous = blob, size = arena_size, used })
    return address
  }

  used =
    switch alignment case byte used case word used.round_up_to_multiple_of(8)
  available = arena_size - used
  
  if size <= available then current_arena else {
    # This allocation doesn't fit into the current arena. Allocate a new arena.
    new_arena = malloc(arena_size)
    address = new_arena + 24
    new_arena.store(ArenaHeader {
      previous = current_arena, size = arena_size, used = 24 + size
    })
    ally.arena.set(new_arena)
    address
  } else {
    # This allocation fits in the current arena!
    address = current_arena + used
    current_arena.store(ArenaHeader {
      previous, size = arena_size, used = used + size
    })
    address
  }
}

fun free(ally: Ally) {
  loop page as ally.arena.unbox() do
    if page == null then break {} else {
      header = page.load[PageHeader]()
      free(page, header.size)
      continue header.previous
    }
}
