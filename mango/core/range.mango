## Range
#
# Ranges have an inclusive start and exclusive end value.

import ..bool

struct Range[T] { start: T, end: T }

fun is_valid[T](range: Range[T]): Bool { range.start <= range.end }

fun ..[T](start: T, end: T): Range[T] { Range{ start, end } }
fun ..=[T](start: T, end: T): Range[T] { Range{ start, end = end.inc() } }
fun ..+[T, D](start: T, length: D): Range[T] {
  Range{ start, end = start + length }
}
fun ..+=[T, D](start: T, length: D): Range[T] {
  Range{ start, end = start + length.inc() }
}
fun +-[T](mid: T, distance: T): Range[T] { # thanks to @antoniusnaumann
  Range{ start = mid - distance, end = {mid + distance}.inc() }
}

fun ==[T](a: Range[T], b: Range[T]): Bool {
  a.start == b.start and a.end == b.end
}

fun length[T](range: Range[T]): Int { range.end - range.start }
fun is_empty[T](range: Range[T]): Bool { range.start >= range.end }

fun contains[T](range: Range[T], value: T): Bool {
  value >= range.start and value < range.end
}
fun write[W, T](writer: W, range: Range[T]) {
  writer."{range.start}..{range.end}"
}

fun iter[T](range: Range[T]): Iter[T, _] {
  Iter[T, RangeIter[T]] { state = RangeIter { rest = range } }
}
struct RangeIter[T] { rest: Range[T] }
fun next[T](iter: &Iter[T, RangeIter[T]]): Maybe[T] {
  var state = iter.state.&
  if state.rest.is_empty() then none[T]() else {
    var current = state.rest.start
    state.rest.start = current.inc()
    some(current)
  }
}

## To Infinity and Beyond
#
# Open ended ranges can be created using 4..infinity syntax.

struct Infinity {}
var infinity = Infinity {}

struct OpenRange[T] { start: T }

fun ..[T](start: T, end: Infinity): OpenRange[T] { OpenRange { start } }

fun contains[T](range: OpenRange[T], value: T): Bool {
  value >= range.start
}
fun write[W, T](writer: W, range: OpenRange[T]) {
  writer."{range.start}..infinity"
}

fun iter[T](range: OpenRange[T]): Iter[T, _] {
  Iter[T, OpenRangeIter[T]] { state = OpenRangeIter { rest = range } }
}
struct OpenRangeIter[T] { rest: OpenRange[T] }
fun next[T](iter: &Iter[T, OpenRangeIter[T]]): Maybe[T] {
  var state = iter.state.&
  var current = state.rest.start
  state.rest.start = current.inc()
  some(current)
}
