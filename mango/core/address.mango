## Address
#
# An untyped pointer to somewhere in memory.
#
# ┌─────┐       ┌─────────┐
# │ Int │ <───> │ Address │ <───> ...
# └─────┘       └─────────┘
#
# If you want to calculate with addresses, you can convert them to ints. If you
# want to be able to get one or multiple value from an address, you can turn
# them into boxes or arrays.

opaque Address = 8 bytes big, 8 bytes aligned

fun to_int(address: Address): Int ground { f5 }
fun to_address(number: Int): Address ground { f5 }

fun load[T](address: Address): T { ... }
fun store[T](address: Address, value: T) { ... }

var null = 0.to_address() # Million dollar mistake?

fun ==(a: Address, b: Address): Bool { a.to_int() == b.to_int() }
fun +(a: Address, offset: Int): Address { {a.to_int() + offset}.to_address() }

fun or(address: Address): ControlFlow[Address, Nothing] {
  if address == null
  then ControlFlow[Address, Nothing].evaluate_alternative
  else ControlFlow[Address, Nothing].short_circuit(address)
}

fun memcopy(from: Address, to: Address, amount: Int) ground {
  # The from and to address ranges may partially overlap. Depending on the way
  # they overlap, we need to copy the content from left-to-right or
  # right-to-left.
  c4 10 00 00 00 00 00 00 00  # push_word_from_stack 16       (from to amount from)
  c4 10 00 00 00 00 00 00 00  # push_word_from_stack 16       (from to amount from to)
  a1                          # subtract      (from to amount diff)
  a5                          # compare_zero  (from to amount ord)
  f1 03 ^same ^ltr ^rtl       # jump_table

  @same
  c5 18  # pop 24  ()
  f5     # return

  @ltr
  @ltr_loop
  

  @rtl
  @rtl_loop

  .left_to_right: ..loop:
  move st c isequal cjump .done
  loadb d a storeb b d
  add a e add b e sub c e
  jump ..loop
  .right_to_left:
  add a c add b c sub a e sub b e # make a and b point to the last byte
  ..loop:
  move st c isequal cjump .done
  loadb d a storeb b d
  sub a e sub b e sub c e
  jump ..loop
  .done: ret
}

fun memcompare(left: Address, right: Address, amount: Int): Ordering ground {
  @loop                       #                         (l r a)
  c4 00 00 00 00 00 00 00 00  # push_word_from_stack 0  (l r a a)
  a5                          # compare_zero            (l r a done)
  f1 03 ^equal ^more ^more    # jump_table

  @more                          #                         (l r a)
  c4 10 00 00 00 00 00 00 00     # push_word_from_stack 8  (l r a l)
  d4                             # load_byte               (l r a l)
  b6                             # byte_to_word            (l r a l)
  c4 10 00 00 00 00 00 00 00     # push_word_from_stack 8  (l r a l r)
  d4                             # load_byte               (l r a l r)
  b6                             # byte_to_word            (l r a l r)
  a1                             # subtract                (l r a diff)
  f1 03 ^advance ^greater ^less  # jump_table

  @advance                       #                          (l r a)
  c4 10 00 00 00 00 00 00 00     # push_word_from_stack 16  (l r a l)
  c2 01 00 00 00 00 00 00 00     # push_word 1              (l r a l 1)
  a0                             # add                      (l r a l')
  c4 10 00 00 00 00 00 00 00     # push_word_from_stack 16  (l r a l' r)
  c2 01 00 00 00 00 00 00 00     # push_word 1              (l r a l' r 1)
  a0                             # add                      (l r a l' r')
  c4 10 00 00 00 00 00 00 00     # push_word_from_stack 16  (l r a l' r' a)
  c2 01 00 00 00 00 00 00 00     # push_word 1              (l r a l' r' a 1)
  a1                             # subtract                 (l r a l' r' a')
  c6 18 00 00 00 00 00 00 00 18  # pop_below_top 24 24      (l' r' a')
  f0 ^loop

  @equal    c5 18  c1 00  f5  # pop 24  push_byte 0  return  (0)
  @greater  c5 18  c1 01  f5  # pop 24  push_byte 1  return  (1)
  @less     c5 18  c1 02  f5  # pop 24  push_byte 2  return  (2)
}

fun memhash(address: Address, amount: Int): Int ground {
  TODO
  moveib a 8  add a sp load a a # address
  moveib b 16 add b sp load b b # amount
  movei c 5381                  # hasher state
  moveib e 33 moveib f 1        # constants
  .loop:
  move st b isequal cjump .done # if amount == 0, we're done
  loadb d a mul c e add c d     # state = 33 * state + address[i]
  sub b f add a f jump .loop
  .done:
  mul c e
  load a sp store a c ret
}

fun write(writer: Writer, address: Address): Writer {
  address = address.to_int()
  # max Int is 18_446_744_073_709_551_615, so start with 16 ^ something
  loop tuple init tuple(writer.write("0x"), 1_152_921_504_606_846_976) do {
    writer = tuple.a
    divisor = tuple.b
    writer = writer.write({address / divisor % 16}.lower_byte().digit_to_char())
    if divisor == 1 then
      break writer
    else
      continue tuple(writer, divisor / 16)
  }
}
