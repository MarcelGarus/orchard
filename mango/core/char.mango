## Chars  
#
# A Char (short for Character) is a wrapper around a Byte. When you write
# something like 'a in your code, that gets turned into a Char. Don't confuse
# the Char with a Unicode code point, grapheme cluster, or anything like that.
# This is as much a "character" as the C char. But who are we to judge?
# Character is a heavily overloaded term anyways.

struct Char { byte: Byte }

var space = ' 
var tab = 9.lower_byte().to_char()
var newline = 10.lower_byte().to_char()
var carriage_return = 13.lower_byte().to_char()
var visible_ascii = 32.lower_byte().to_char()..127.lower_byte().to_char()

var lowercase_chars = 'a..='z
var uppercase_chars = 'A..='Z
var digit_chars = '0..='9

fun to_char(byte: Byte): Char { Char { byte } }

fun is_lower(char: Char): Bool { lowercase_chars.contains(char) }
fun is_upper(char: Char): Bool { uppercase_chars.contains(char) }
fun is_letter(char: Char): Bool { char.is_lower() or char.is_upper() }
fun is_digit(char: Char): Bool { digit_chars.contains(char) }
fun is_alphanumeric(char: Char): Bool { char.is_letter() or char.is_digit() }
fun is_whitespace(char: Char): Bool {
  char == space or char == newline or char == tab
}

fun parse_digit(char: Char): Byte {
  if char.is_digit() then return char.byte - '0.byte
  if char.is_lower() then return char.byte - 'a.byte + 16.lower_byte()
  if char.is_upper() then return char.byte - 'A.byte + 16.lower_byte()
  panic("not a digit")
}
fun <=>(a: Char, b: Char): Ordering { a.byte <=> b.byte }
fun ==(a: Char, b: Char): Bool { a.byte == b.byte }
fun hash(hasher: &Hasher, char: Char) { hasher.hash(char.byte) }
fun write[W](writer: W, char: Char) { writer.write_byte(char.byte) }
fun write_debug[W](writer: W, char: Char) { writer."#{char}" }
fun inc(char: Char): Char { Char { byte = char.byte.inc() } }
fun dec(char: Char): Char { Char { byte = char.byte.dec() } }
fun +(char: Char, delta: Byte): Char { Char { byte = char.byte + delta } }
fun -(char: Char, delta: Byte): Char { Char { byte = char.byte - delta } }
fun -(char: Char, other: Char): Byte { char.byte - other.byte }
