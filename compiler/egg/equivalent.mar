
import mod.mar

fun ==(a: EggExpr, b: EggExpr): Bool {
  switch a
  case param(a)             false
  case case_param(a)        if b is case_param(b)        then a == b else false
  case type(a)              if b is type(b)              then a == b else false
  case int(a)               if b is int(b)               then a == b else false
  case string(a)            if b is string(b)            then a == b else false
  case struct_(a)           if b is struct_(b)           then a == b else false
  case enum_(a)             if b is enum_(b)             then a == b else false
  case inline_lambda(a)     if b is inline_lambda(b)     then a == b else false
  case raw_lambda(a)        if b is raw_lambda(b)        then a == b else false
  case member(a)            if b is member(b)            then a == b else false
  case switch_(a)           if b is switch_(b)           then a == b else false
  case call_fun(a)          if b is call_fun(b)          then a == b else false
  case call_lambda(a)       if b is call_lambda(b)       then a == b else false
  case call_builtin(a)      if b is call_builtin(b)      then a == b else false
  case cast(a)              if b is cast(b)              then a == b else false
  case byte(a)              if b is byte(b)              then a == b else false
  case lower_byte(a)        if b is lower_byte(b)        then a == b else false
  case byte_to_int(a)       if b is byte_to_int(b)       then a == b else false
  case add(a)               if b is add(b)               then a == b else false
  case subtract(a)          if b is subtract(b)          then a == b else false
  case multiply(a)          if b is multiply(b)          then a == b else false
  case divide(a)            if b is divide(b)            then a == b else false
  case modulo(a)            if b is modulo(b)            then a == b else false
  case and_(a)              if b is and_(b)              then a == b else false
  case or_(a)               if b is or_(b)               then a == b else false
  case xor(a)               if b is xor(b)               then a == b else false
  case compare(a)           if b is compare(b)           then a == b else false
  case unchecked_divide(a)  if b is unchecked_divide(b)  then a == b else false
  case unchecked_modulo(a)  if b is unchecked_modulo(b)  then a == b else false
  case box(a)               if b is box(b)               then a == b else false
  case unbox(a)             if b is unbox(b)             then a == b else false
  case array(a)             if b is array(b)             then a == b else false
  case generate_array(a)    if b is generate_array(b)    then a == b else false
  case array_get(a)         if b is array_get(b)         then a == b else false
  case array_set(a)         if b is array_set(b)         then a == b else false
  case array_slice(a)       if b is array_slice(b)       then a == b else false
  case array_len(a)         if b is array_len(b)         then a == b else false
  case unchecked_generate_non_empty_array(a) if b is unchecked_generate_non_empty_array(b) then a == b else false
  case unchecked_array_get(a) if b is unchecked_array_get(b) then a == b else false
  case unchecked_array_set(a) if b is unchecked_array_set(b) then a == b else false
  case unchecked_array_slice(a) if b is unchecked_array_slice(b) then a == b else false
  case type_info(a)         if b is type_info(b)         then a == b else false
  case static_to_dynamic(a) if b is static_to_dynamic(b) then a == b else false
  case dynamic_to_static(a) if b is dynamic_to_static(b) then a == b else false
  case crash(a)             if b is crash(b)             then a == b else false
  case unreachable(a)       if b is unreachable(b)       then a == b else false
  case loop_(a)             if b is loop_(b)             then a == b else false
  case continue_(a)         if b is continue_(b)         then a == b else false
  case dup(a)               if b is dup(b)               then a == b else false
  case drop(a)              if b is drop(b)              then a == b else false
  case function_ptr(a)      if b is function_ptr(b)      then a == b else false
  case call_indirect(a)     if b is call_indirect(b)     then a == b else false
  case new(a)               if b is new(b)               then a == b else false
  case load(a)              if b is load(b)              then a == b else false
  case free(a)              if b is free(b)              then a == b else false
  case get_refcount(a)      if b is get_refcount(b)      then a == b else false
  case set_refcount(a)      if b is set_refcount(b)      then a == b else false
  case new_buffer(a)        if b is new_buffer(b)        then a == b else false
  case get_buffer_length(a) if b is get_buffer_length(b) then a == b else false
  case load_buffer_item(a)  if b is load_buffer_item(b)  then a == b else false
  case store_buffer_item(a) if b is store_buffer_item(b) then a == b else false
  case store_buffer_bytes(a) if b is store_buffer_bytes(b) then a == b else false
  case free_buffer(a)       if b is free_buffer(b)       then a == b else false
}
fun ==(a: EggBody, b: EggBody): Bool {
  a.params == b.params and a.children == b.children and a.returns == b.returns
}
fun ==(a: EggCaseParam, b: EggCaseParam): Bool {
  a.switch_on == b.switch_on and a.variant == b.variant
}
fun ==(a: EggEnum, b: EggEnum): Bool {
  a.type == b.type and a.variant == b.variant and a.payload == b.payload
}
fun ==(a: EggMember, b: EggMember): Bool { a.of == b.of and a.name == b.name }
fun ==(a: EggSwitch, b: EggSwitch): Bool {
  a.condition == b.condition and a.type == b.type and a.cases == b.cases
}
fun ==(a: EggCallFun, b: EggCallFun): Bool {
  a.fun_ == b.fun_ and a.substitutions == b.substitutions and a.args == b.args
    and a.return_type == b.return_type
}
fun ==(a: Substitutions, b: Substitutions): Bool {
  a.substitutions == b.substitutions
}
fun ==(a: EggRawLambda, b: EggRawLambda): Bool {
  a.fun_ == b.fun_ and a.closure == b.closure and a.type == b.type
}
fun ==(a: EggCallLambda, b: EggCallLambda): Bool {
  a.lambda == b.lambda and a.args == b.args
}
fun ==(a: EggCallBuiltin, b: EggCallBuiltin): Bool {
  a.builtin == b.builtin and a.substitutions == b.substitutions
    and a.args == b.args
}
fun ==(a: EggBuiltin, b: EggBuiltin): Bool {
  a.debug().format() == b.debug().format()
}
fun ==(a: EggCast, b: EggCast): Bool { a.what == b.what and a.type == b.type }
fun ==(a: EggArray, b: EggArray): Bool {
  a.items == b.items and a.item_type == b.item_type
}
fun ==(a: EggGenerateArray, b: EggGenerateArray): Bool {
  a.length == b.length and a.generator == b.generator
}
fun ==(a: EggArrayGet, b: EggArrayGet): Bool {
  a.array == b.array and a.index == b.index
}
fun ==(a: EggArraySet, b: EggArraySet): Bool {
  a.array == b.array and a.index == b.index and a.item == b.item
}
fun ==(a: EggArraySlice, b: EggArraySlice): Bool {
  a.array == b.array and a.start == b.start and a.end == b.end
}
fun ==(a: EggDynamicToStatic, b: EggDynamicToStatic): Bool {
  a.dynamic == b.dynamic and a.static == b.static
}
fun ==(a: EggCrash, b: EggCrash): Bool {
  a.message == b.message and a.type == b.type
}
fun ==(a: EggLoop, b: EggLoop): Bool {
  a.initial == b.initial and a.body == b.body
}
fun ==(a: EggContinue, b: EggContinue): Bool {
  a.next == b.next and a.type == b.type
}
fun == (a: EggDup, b: EggDup): Bool { a.id == b.id and a.type == b.type }
fun == (a: EggDrop, b: EggDrop): Bool { a.id == b.id and a.type == b.type }
fun == (a: EggCallIndirect, b: EggCallIndirect): Bool {
  a.function_ptr == b.function_ptr and a.args == b.args
    and a.return_type == b.return_type
}
fun == (a: EggLoad, b: EggLoad): Bool { a.ptr == b.ptr and a.type == b.type }
fun == (a: EggFree, b: EggFree): Bool { a.ptr == b.ptr and a.type == b.type }
fun == (a: EggSetRefcount, b: EggSetRefcount): Bool {
  a.ptr == b.ptr and a.refcount == b.refcount
}
fun == (a: EggNewBuffer, b: EggNewBuffer): Bool {
  a.item_type == b.item_type and a.length == b.length
}
fun == (a: EggLoadBufferItem, b: EggLoadBufferItem): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type and a.index == b.index
}
fun == (a: EggStoreBufferItem, b: EggStoreBufferItem): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type and a.index == b.index
    and a.item == b.item
}
fun == (a: EggStoreBufferBytes, b: EggStoreBufferBytes): Bool {
  a.buffer == b.buffer and a.bytes == b.bytes
}
fun == (a: EggFreeBuffer, b: EggFreeBuffer): Bool {
  a.buffer == b.buffer and a.item_type == b.item_type
}

fun hash[H](hasher: H, expr: EggExpr) {
  hasher.hash(expr.debug().format())
  
  | switch expr
  | case param(a)        { hasher.hash(0)  hasher.hash(a) }
  | case type(a)         { hasher.hash(1)  hasher.hash(a) }
  | case int(a)          { hasher.hash(2)  hasher.hash(a) }
  | case string(a)       { hasher.hash(3)  hasher.hash(a) }
  | case struct_(a)      { hasher.hash(4)  hasher.hash(a) }
  | case enum_(a)        { hasher.hash(5)  hasher.hash(a) }
  | case lambda(a)       { hasher.hash(6)  hasher.hash(a) }
  | case member(a)       { hasher.hash(7)  hasher.hash(a) }
  | case switch_(a)      { hasher.hash(8)  hasher.hash(a) }
  | case call_fun(a)     { hasher.hash(9)  hasher.hash(a) }
  | case call_lambda(a)  { hasher.hash(10)  hasher.hash(a) }
  | case call_builtin(a) { hasher.hash(11)  hasher.hash(a) }
  | case cast(a)         { hasher.hash(12)  hasher.hash(a) }
  | case byte(a)         { hasher.hash(13)  hasher.hash(a) }
  | case lower_byte(a)   { hasher.hash(14)  hasher.hash(a) }
  | case byte_to_int(a)  { hasher.hash(15)  hasher.hash(a) }
  | case add(a)          { hasher.hash(16)  hasher.hash(a) }
  | case subtract(a)     { hasher.hash(17)  hasher.hash(a) }
  | case multiply(a)     { hasher.hash(18)  hasher.hash(a) }
  | case divide(a)       { hasher.hash(19)  hasher.hash(a) }
  | case modulo(a)       { hasher.hash(20)  hasher.hash(a) }
  | case and_(a)         { hasher.hash(21)  hasher.hash(a) }
  | case or_(a)          { hasher.hash(22)  hasher.hash(a) }
  | case xor(a)          { hasher.hash(23)  hasher.hash(a) }
  | case compare(a)      { hasher.hash(24)  hasher.hash(a) }
  | case unchecked_divide(a) { hasher.hash(25)  hasher.hash(a) }
  | case unchecked_modulo(a) { hasher.hash(26)  hasher.hash(a) }
  | case box(a)          { hasher.hash(27)  hasher.hash(a) }
  | case unbox(a)        { hasher.hash(28)  hasher.hash(a) }
  | case array(a)        { hasher.hash(29)  hasher.hash(a) }
  | case generate_array(a) { hasher.hash(30)  hasher.hash(a) }
  | case array_get(a)    { hasher.hash(31)  hasher.hash(a) }
  | case array_set(a)    { hasher.hash(32)  hasher.hash(a) }
  | case array_slice(a)  { hasher.hash(33)  hasher.hash(a) }
  | case array_len(a)    { hasher.hash(34)  hasher.hash(a) }
  | case unchecked_generate_non_empty_array(a) { hasher.hash(35)  hasher.hash(a) }
  | case unchecked_array_get(a) { hasher.hash(36)  hasher.hash(a) }
  | case unchecked_array_set(a) { hasher.hash(37)  hasher.hash(a) }
  | case unchecked_array_slice(a) { hasher.hash(38)  hasher.hash(a) }
  | case type_info(a)    { hasher.hash(39)  hasher.hash(a) }
  | case static_to_dynamic(a) { hasher.hash(40)  hasher.hash(a) }
  | case dynamic_to_static(a) { hasher.hash(41)  hasher.hash(a) }
  | case crash(a)        { hasher.hash(42)  hasher.hash(a) }
  | case unreachable(a)  { hasher.hash(43)  hasher.hash(a) }
  | case recursive(a)    { hasher.hash(44)  hasher.hash(a) }
  | case recurse(a)      { hasher.hash(45)  hasher.hash(a) }
}
fun hash[H](hasher: H, enum_: EggEnum) {
  hasher.hash(enum_.type)
  hasher.hash(enum_.variant)
  hasher.hash(enum_.payload)
}




| fun is_equiv(a: EggId, b: EggId, equiv: &Map[EggId, EggId]): Bool {
|   if a == b then return true
|   if equiv.get_maybe(a) is some(equiv) then if equiv == b then return true
|   a.resolve() =~= b.resolve()
| }
| fun is_equiv(a: EggExpr, b: EggExpr, equiv: &Map[EggId, EggId]): Bool {
|   switch a
|   case param(a)          if b is param(b)          then a == b else false
|   case type(a)           if b is type(b)           then a == b else false
|   case int(a)            if b is int(b)            then a == b else false
|   case string(a)         if b is string(b)         then a == b else false
|   case struct_(a)        if b is struct_(b)        then a =~= b else false
|   case enum_(a)          if b is enum_(b)          then a =~= b else false
|   case lambda(a)         if b is lambda(b)         then a =~= b else false
|   case member(a)         if b is member(b)         then a =~= b else false
|   case switch_(a)        if b is switch_(b)        then a =~= b else false
|   case call_fun(a)       if b is call_fun(b)       then a =~= b else false
|   case call_lambda(a)    if b is call_lambda(b)    then a =~= b else false
|   case call_builtin(a)   if b is call_builtin(b)   then a =~= b else false
|   case cast(a)           if b is cast(b)           then a =~= b else false
|   case byte(a)           if b is byte(b)           then a == b else false
|   case lower_byte(a)     if b is lower_byte(b)     then a =~= b else false
|   case byte_to_int(a)    if b is byte_to_int(b)    then a =~= b else false
|   case add(a)            if b is add(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case subtract(a)       if b is subtract(b)       then a.a =~= b.a and a.b =~= b.b else false
|   case multiply(a)       if b is multiply(b)       then a.a =~= b.a and a.b =~= b.b else false
|   case divide(a)         if b is divide(b)         then a.a =~= b.a and a.b =~= b.b else false
|   case modulo(a)         if b is modulo(b)         then a.a =~= b.a and a.b =~= b.b else false
|   case and_(a)           if b is and_(b)           then a.a =~= b.a and a.b =~= b.b else false
|   case or_(a)            if b is or_(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case xor(a)            if b is xor(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case compare(a)        if b is compare(b)        then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_divide(a) if b is unchecked_divide(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_modulo(a) if b is unchecked_modulo(b) then a.a =~= b.a and a.b =~= b.b else false
|   case box(a)            if b is box(b)            then a =~= b else false
|   case unbox(a)          if b is unbox(b)          then a =~= b else false
|   case array(a)          if b is array(b)          then a =~= b else false
|   case generate_array(a) if b is generate_array(b) then a.a =~= b.a and a.b =~= b.b else false
|   case array_get(a)      if b is array_get(b)      then a.a =~= b.a and a.b =~= b.b else false
|   case array_set(a)      if b is array_set(b)      then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case array_slice(a)    if b is array_slice(b)    then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case array_len(a)      if b is array_len(b)      then a =~= b else false
|   | case unchecked_generate_non_empty_array(a) if b is unchecked_generate_non_empty_array(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_array_get(a) if b is unchecked_array_get(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_array_set(a) if b is unchecked_array_set(b) then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   | case unchecked_array_slice(a) if b is unchecked_array_slice(b) then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case type_info(a)      if b is type_info(b)      then a =~= b else false
|   case static_to_dynamic(a) if b is static_to_dynamic(b) then a =~= b else false
|   case dynamic_to_static(a) if b is dynamic_to_static(b) then a =~= b else false
|   case crash             b is crash
|   case unreachable(a)    b is unreachable
|   case recursive(a)      if b is recursive(b)      then a.a =~= b.a and a.b =~= a.b else false
|   case recurse(a)        if b is recurse(b)        then a =~= b else false
| }
| fun is_equiv[T](a: Slice[T], b: Slice[T]): Bool {
|   for both in zip(a.iter(), b.iter()) do
|     if not(both.a =~= both.b) then return false
|   true
| }
| fun =~=[T](a: Map[String, T], b: Map[String, T]): Bool {
|   a.size == b.size or return false
|   for entry in a do
|     if b.get_maybe(entry.key) is some(b) then
|       if not(entry.value =~= b) then return false
|   true
| }
| fun =~=(a: EggEnum, b: EggEnum): Bool {
|   a.variant == b.variant and a.payload =~= b.payload
| }
| fun =~=(a: EggMember, b: EggMember): Bool {
|   a.of =~= b.of and a.name == b.name
| }
| fun =~=(a: EggSwitch, b: EggSwitch): Bool {
|   a.condition =~= b.condition and a.cases =~= b.cases
| }
| fun =~=(a: EggCallFun, b: EggCallFun): Bool {
|   a.fun_ == b.fun_ and a.args =~= b.args
| }
| fun =~=(a: EggCallLambda, b: EggCallLambda): Bool {
|   a.lambda =~= b.lambda and a.args =~= b.args
| }
| fun =~=(a: EggBody, b: EggBody): Bool {
|   a.params.len == b.params.len or return false
|   var b_called_with_params_of_a = {
|     var builder = egg_body_builder().&
|     var mapping = map[EggId, EggId]()
|     for param in a.params do fillings.&.put(param, builder.param(param.type()))
|     for child in a.children do 

|   }
|   a.expr =~= b.fill(fillings.to_slice())
| }


| fun =~=(a: EggId, b: EggId): Bool {
|   if a == b then return true
|   a.resolve() =~= b.resolve()
| }

| fun is_equiv(a: EggId, b: EggId, equiv: &Map[EggId, EggId]): Bool {
|   if a == b then return true
|   if equiv.get_maybe(a) is some(equiv) then if equiv == b then return true
|   a.resolve() =~= b.resolve()
| }
| fun is_equiv(a: EggExpr, b: EggExpr, equiv: &Map[EggId, EggId]): Bool {
|   switch a
|   case param(a)          if b is param(b)          then a == b else false
|   case type(a)           if b is type(b)           then a == b else false
|   case int(a)            if b is int(b)            then a == b else false
|   case string(a)         if b is string(b)         then a == b else false
|   case struct_(a)        if b is struct_(b)        then a =~= b else false
|   case enum_(a)          if b is enum_(b)          then a =~= b else false
|   case lambda(a)         if b is lambda(b)         then a =~= b else false
|   case member(a)         if b is member(b)         then a =~= b else false
|   case switch_(a)        if b is switch_(b)        then a =~= b else false
|   case call_fun(a)       if b is call_fun(b)       then a =~= b else false
|   case call_lambda(a)    if b is call_lambda(b)    then a =~= b else false
|   case call_builtin(a)   if b is call_builtin(b)   then a =~= b else false
|   case cast(a)           if b is cast(b)           then a =~= b else false
|   case byte(a)           if b is byte(b)           then a == b else false
|   case lower_byte(a)     if b is lower_byte(b)     then a =~= b else false
|   case byte_to_int(a)    if b is byte_to_int(b)    then a =~= b else false
|   case add(a)            if b is add(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case subtract(a)       if b is subtract(b)       then a.a =~= b.a and a.b =~= b.b else false
|   case multiply(a)       if b is multiply(b)       then a.a =~= b.a and a.b =~= b.b else false
|   case divide(a)         if b is divide(b)         then a.a =~= b.a and a.b =~= b.b else false
|   case modulo(a)         if b is modulo(b)         then a.a =~= b.a and a.b =~= b.b else false
|   case and_(a)           if b is and_(b)           then a.a =~= b.a and a.b =~= b.b else false
|   case or_(a)            if b is or_(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case xor(a)            if b is xor(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case compare(a)        if b is compare(b)        then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_divide(a) if b is unchecked_divide(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_modulo(a) if b is unchecked_modulo(b) then a.a =~= b.a and a.b =~= b.b else false
|   case box(a)            if b is box(b)            then a =~= b else false
|   case unbox(a)          if b is unbox(b)          then a =~= b else false
|   case array(a)          if b is array(b)          then a =~= b else false
|   case generate_array(a) if b is generate_array(b) then a.a =~= b.a and a.b =~= b.b else false
|   case array_get(a)      if b is array_get(b)      then a.a =~= b.a and a.b =~= b.b else false
|   case array_set(a)      if b is array_set(b)      then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case array_slice(a)    if b is array_slice(b)    then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case array_len(a)      if b is array_len(b)      then a =~= b else false
|   | case unchecked_generate_non_empty_array(a) if b is unchecked_generate_non_empty_array(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_array_get(a) if b is unchecked_array_get(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_array_set(a) if b is unchecked_array_set(b) then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   | case unchecked_array_slice(a) if b is unchecked_array_slice(b) then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case type_info(a)      if b is type_info(b)      then a =~= b else false
|   case static_to_dynamic(a) if b is static_to_dynamic(b) then a =~= b else false
|   case dynamic_to_static(a) if b is dynamic_to_static(b) then a =~= b else false
|   case crash             b is crash
|   case unreachable(a)    b is unreachable
|   case recursive(a)      if b is recursive(b)      then a.a =~= b.a and a.b =~= a.b else false
|   case recurse(a)        if b is recurse(b)        then a =~= b else false
| }
| fun is_equiv[T](a: Slice[T], b: Slice[T]): Bool {
|   for both in zip(a.iter(), b.iter()) do
|     if not(both.a =~= both.b) then return false
|   true
| }
| fun =~=[T](a: Map[String, T], b: Map[String, T]): Bool {
|   a.size == b.size or return false
|   for entry in a do
|     if b.get_maybe(entry.key) is some(b) then
|       if not(entry.value =~= b) then return false
|   true
| }
| fun =~=(a: EggEnum, b: EggEnum): Bool {
|   a.variant == b.variant and a.payload =~= b.payload
| }
| fun =~=(a: EggMember, b: EggMember): Bool {
|   a.of =~= b.of and a.name == b.name
| }
| fun =~=(a: EggSwitch, b: EggSwitch): Bool {
|   a.condition =~= b.condition and a.cases =~= b.cases
| }
| fun =~=(a: EggCallFun, b: EggCallFun): Bool {
|   a.fun_ == b.fun_ and a.args =~= b.args
| }
| fun =~=(a: EggCallLambda, b: EggCallLambda): Bool {
|   a.lambda =~= b.lambda and a.args =~= b.args
| }
| fun =~=(a: EggBody, b: EggBody): Bool {
|   a.params.len == b.params.len or return false
|   var b_called_with_params_of_a = {
|     var builder = egg_body_builder().&
|     var mapping = map[EggId, EggId]()
|     for param in a.params do fillings.&.put(param, builder.param(param.type()))
|     for child in a.children do 

|   }
|   a.expr =~= b.fill(fillings.to_slice())
| }
