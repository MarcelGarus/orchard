
import mod.mar

| fun =~=(a: EggId, b: EggId): Bool {
|   if a == b then return true
|   a.resolve() =~= b.resolve()
| }

| fun is_equiv(a: EggId, b: EggId, equiv: &Map[EggId, EggId]): Bool {
|   if a == b then return true
|   if equiv.get_maybe(a) is some(equiv) then if equiv == b then return true
|   a.resolve() =~= b.resolve()
| }
| fun is_equiv(a: EggExpr, b: EggExpr, equiv: &Map[EggId, EggId]): Bool {
|   switch a
|   case param(a)          if b is param(b)          then a == b else false
|   case type(a)           if b is type(b)           then a == b else false
|   case int(a)            if b is int(b)            then a == b else false
|   case string(a)         if b is string(b)         then a == b else false
|   case struct_(a)        if b is struct_(b)        then a =~= b else false
|   case enum_(a)          if b is enum_(b)          then a =~= b else false
|   case lambda(a)         if b is lambda(b)         then a =~= b else false
|   case member(a)         if b is member(b)         then a =~= b else false
|   case switch_(a)        if b is switch_(b)        then a =~= b else false
|   case call_fun(a)       if b is call_fun(b)       then a =~= b else false
|   case call_lambda(a)    if b is call_lambda(b)    then a =~= b else false
|   case call_builtin(a)   if b is call_builtin(b)   then a =~= b else false
|   case cast(a)           if b is cast(b)           then a =~= b else false
|   case byte(a)           if b is byte(b)           then a == b else false
|   case lower_byte(a)     if b is lower_byte(b)     then a =~= b else false
|   case byte_to_int(a)    if b is byte_to_int(b)    then a =~= b else false
|   case add(a)            if b is add(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case subtract(a)       if b is subtract(b)       then a.a =~= b.a and a.b =~= b.b else false
|   case multiply(a)       if b is multiply(b)       then a.a =~= b.a and a.b =~= b.b else false
|   case divide(a)         if b is divide(b)         then a.a =~= b.a and a.b =~= b.b else false
|   case modulo(a)         if b is modulo(b)         then a.a =~= b.a and a.b =~= b.b else false
|   case and_(a)           if b is and_(b)           then a.a =~= b.a and a.b =~= b.b else false
|   case or_(a)            if b is or_(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case xor(a)            if b is xor(b)            then a.a =~= b.a and a.b =~= b.b else false
|   case compare(a)        if b is compare(b)        then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_divide(a) if b is unchecked_divide(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_modulo(a) if b is unchecked_modulo(b) then a.a =~= b.a and a.b =~= b.b else false
|   case box(a)            if b is box(b)            then a =~= b else false
|   case unbox(a)          if b is unbox(b)          then a =~= b else false
|   case array(a)          if b is array(b)          then a =~= b else false
|   case generate_array(a) if b is generate_array(b) then a.a =~= b.a and a.b =~= b.b else false
|   case array_get(a)      if b is array_get(b)      then a.a =~= b.a and a.b =~= b.b else false
|   case array_set(a)      if b is array_set(b)      then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case array_slice(a)    if b is array_slice(b)    then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case array_len(a)      if b is array_len(b)      then a =~= b else false
|   | case unchecked_generate_non_empty_array(a) if b is unchecked_generate_non_empty_array(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_array_get(a) if b is unchecked_array_get(b) then a.a =~= b.a and a.b =~= b.b else false
|   | case unchecked_array_set(a) if b is unchecked_array_set(b) then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   | case unchecked_array_slice(a) if b is unchecked_array_slice(b) then a.a =~= b.a and a.b =~= b.b and a.c =~= b.c else false
|   case type_info(a)      if b is type_info(b)      then a =~= b else false
|   case static_to_dynamic(a) if b is static_to_dynamic(b) then a =~= b else false
|   case dynamic_to_static(a) if b is dynamic_to_static(b) then a =~= b else false
|   case crash             b is crash
|   case unreachable(a)    b is unreachable
|   case recursive(a)      if b is recursive(b)      then a.a =~= b.a and a.b =~= a.b else false
|   case recurse(a)        if b is recurse(b)        then a =~= b else false
| }
| fun is_equiv[T](a: Slice[T], b: Slice[T]): Bool {
|   for both in zip(a.iter(), b.iter()) do
|     if not(both.a =~= both.b) then return false
|   true
| }
| fun =~=[T](a: Map[String, T], b: Map[String, T]): Bool {
|   a.size == b.size or return false
|   for entry in a do
|     if b.get_maybe(entry.key) is some(b) then
|       if not(entry.value =~= b) then return false
|   true
| }
| fun =~=(a: EggEnum, b: EggEnum): Bool {
|   a.variant == b.variant and a.payload =~= b.payload
| }
| fun =~=(a: EggMember, b: EggMember): Bool {
|   a.of =~= b.of and a.name == b.name
| }
| fun =~=(a: EggSwitch, b: EggSwitch): Bool {
|   a.condition =~= b.condition and a.cases =~= b.cases
| }
| fun =~=(a: EggCallFun, b: EggCallFun): Bool {
|   a.fun_ == b.fun_ and a.args =~= b.args
| }
| fun =~=(a: EggCallLambda, b: EggCallLambda): Bool {
|   a.lambda =~= b.lambda and a.args =~= b.args
| }
| fun =~=(a: EggBody, b: EggBody): Bool {
|   a.params.len == b.params.len or return false
|   var b_called_with_params_of_a = {
|     var builder = egg_body_builder().&
|     var mapping = map[EggId, EggId]()
|     for param in a.params do fillings.&.put(param, builder.param(param.type()))
|     for child in a.children do 

|   }
|   a.expr =~= b.fill(fillings.to_slice())
| }
