import mod.mar

struct EggBodyBuilder { params: List[EggId], children: List[EggId] }
fun egg_body_builder(): _ {
  EggBodyBuilder { params = list[EggId](), children = list[EggId]() }
}
fun param(builder: &EggBodyBuilder, type: EggType): EggId {
  var id = EggId { id = egg_dag.put(EggExpr.param(type)) }
  builder.params.&.push(id)
  id
}
fun push(builder: &EggBodyBuilder, op: EggExpr): EggId {
  var id = EggId { id = egg_dag.put(op) }
  builder.children.&.push(id)
  id
}
fun finish(builder: EggBodyBuilder, returns: EggId): EggBody {
  EggBody {
    params = builder.params.to_slice(),
    children = builder.children.to_slice(),
    returns,
  }
}

fun type(builder: &EggBodyBuilder, type: EggType): EggId {
  builder.push(EggExpr.type(type))
}

fun int(builder: &EggBodyBuilder, int: Int): EggId {
  builder.push(EggExpr.int(int))
}

fun string(builder: &EggBodyBuilder, string: String): EggId {
  builder.push(EggExpr.string(string))
}

fun struct_(builder: &EggBodyBuilder, fields: Map[String, EggId]): EggId {
  builder.push(EggExpr.struct_(fields))
}

fun enum_(builder: &EggBodyBuilder, type: EggType, variant: String, payload: EggId): EggId {
  builder.push(EggExpr.enum_(EggEnum { type, variant, payload }))
}

fun lambda(builder: &EggBodyBuilder, body: EggBody): EggId {
  builder.push(EggExpr.lambda(body))
}

fun member(builder: &EggBodyBuilder, of: EggId, name: String): EggId {
  builder.push(EggExpr.member(EggMember { of, name }))
}

fun switch_(
  builder: &EggBodyBuilder, condition: EggId, type: EggType, cases: Map[String, EggBody]
): EggId {
  builder.push(EggExpr.switch_(EggSwitch { condition, type, cases }))
}

fun call(
  builder: &EggBodyBuilder, 
  fun_: String, substitutions: Substitutions,
  args: Slice[EggId], return_type: EggType,
): EggId {
  builder.push(EggExpr.call_fun(EggCallFun {
    fun_, substitutions, args, return_type
  }))
}

fun call(builder: &EggBodyBuilder, lambda: EggId, args: Slice[EggId]): EggId {
  builder.push(EggExpr.call_lambda(EggCallLambda { lambda, args, }))
}

fun call(builder: &EggBodyBuilder, 
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[EggId]
): EggId {
  builder.push(EggExpr.call_builtin(EggCallBuiltin {
    builtin, substitutions, args
  }))
}

fun cast(builder: &EggBodyBuilder, what: EggId, type: EggType): EggId {
  builder.push(EggExpr.cast(EggCast { what, type }))
}

fun crash(builder: &EggBodyBuilder, message: EggId): EggId {
  builder.call(EggBuiltin.crash, no_substitutions, list(message).to_slice())
}

fun crash(builder: &EggBodyBuilder, message: String): EggId {
  builder.crash(builder.string(message))
}

| fun recursive_call(args: Slice[EggId], return_type: EggType): EggId {
|   call(EggCallee.recursive, args, return_type)
| }
| fun add(a: EggId, b: EggId): EggId {
|   EggBuiltin.add_ints.call(list(a, b).to_slice(), type_int)
| }
| fun array_get(array: EggId, index: EggId): EggId {
|   EggBuiltin.array_get.call(
|     list(array, index).to_slice(),
|     array.type.kind().array.unwrap(),
|   )
| }
| fun array_len(array: EggId): EggId {
|   EggBuiltin.array_len.call(list(array).to_slice(), type_int)
| }
| fun box(inner: EggId): EggId {
|   EggBuiltin.box.no_substitutions().call(
|     list(inner).to_slice(), type_box(inner.type)
|   )
| }
| fun unbox(box: EggId): EggId {
|   EggCalledBuiltin {}
|   EggBuiltin.unbox.call(
|     list(box).to_slice(), box.type.kind().box.unwrap()
|   )
| }
| fun byte_to_int(byte: EggId): EggId {
|   EggBuiltin.byte_to_int.call(list(byte).to_slice(), type_int)
| }
| fun generate_array(length: EggId, generator: EggId): EggId {
|   EggBuiltin.generate_array.call(
|     list(length, generator).to_slice(),
|     type_array(body.type_of(generator).kind().lambda.unwrap().return_type),
|   )
| }
| fun compare_ints(a: EggId, b: EggId): EggId {
|   EggBuiltin.compare_ints.call(list(a, b).to_slice(), type_ordering)
| }


| fun unreachable(builder: &EggBodyBuilder, type: EggType): EggId {
|   egg_crash("unreachable", type)
| }
| fun loop_(name: String, args: Slice[EggId], body: EggBody): EggId {
|   EggExpr.loop_(EggLoop { name, args, body = body.put_on_heap() })
|     .egg_dag.put(body.returns.type)
| }
| fun continue_(args: Slice[EggId]): EggId {
|   EggExpr.continue_(args).egg_dag.put(type_never)
| }


| var egg_nothing = struct_(map[String, EggId]())
| var egg_true = enum_(type_bool, "true", egg_nothing)
| var egg_false = enum_(type_bool, "false", egg_nothing)

| fun body(
|   dag: &Dag[EggId], params: Slice[EggType], returns: EggId
| ): EggBody {
|   var body = dag.body_builder().&
|   for param in params do body.param(param)
|   body.finish(returns)
| }
| fun body_accepting_nothing(dag: &Dag[EggId], returns: EggId): EggBody {
|   body(list(type_nothing).to_slice(), returns)
| }

| fun with_substitutions(
|   builtin: EggBuiltin, substitutions: Substitutions
| ): EggCalledBuiltin {
|   EggCalledBuiltin { builtin, substitutions }
| }
| fun no_substitutions(builtin: EggBuiltin): EggCalledBuiltin {
|   builtin.with_substitutions(no_substitutions)
| }
