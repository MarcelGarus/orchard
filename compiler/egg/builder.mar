import mod.mar

struct EggBodyBuilder { params: List[EggId], children: List[EggId] }
fun egg_body_builder(): _ {
  EggBodyBuilder { params = list[EggId](), children = list[EggId]() }
}
fun param(builder: &EggBodyBuilder, type: EggType): EggId {
  var id = EggId { id = egg_dag.put(EggExpr.param(type)) }
  builder.params.&.push(id)
  id
}
fun push(builder: &EggBodyBuilder, id: EggId): EggId {
  builder.children.&.push(id)
  id
}
fun push(builder: &EggBodyBuilder, expr: EggExpr): EggId {
  builder.push(EggId { id = egg_dag.put(expr) })
}
fun finish(builder: EggBodyBuilder, returns: EggId): EggBody {
  EggBody {
    params = builder.params.to_slice(),
    children = builder.children.to_slice(),
    returns,
  }
}

fun type(builder: &EggBodyBuilder, type: EggType): EggId {
  builder.push(EggExpr.type(type))
}

fun int(builder: &EggBodyBuilder, int: Int): EggId {
  builder.push(EggExpr.int(int))
}

fun string(builder: &EggBodyBuilder, string: String): EggId {
  builder.push(EggExpr.string(string))
}

fun struct_(builder: &EggBodyBuilder, fields: Map[String, EggId]): EggId {
  builder.push(EggExpr.struct_(fields))
}

fun enum_(builder: &EggBodyBuilder, type: EggType, variant: String, payload: EggId): EggId {
  builder.push(EggExpr.enum_(EggEnum { type, variant, payload }))
}

fun lambda(builder: &EggBodyBuilder, body: EggBody): EggId {
  builder.push(EggExpr.lambda(body))
}

fun member(builder: &EggBodyBuilder, of: EggId, name: String): EggId {
  builder.push(EggExpr.member(EggMember { of, name }))
}

fun switch_(
  builder: &EggBodyBuilder, condition: EggId, type: EggType, cases: Map[String, EggBody]
): EggId {
  builder.push(EggExpr.switch_(EggSwitch { condition, type, cases }))
}

fun call(
  builder: &EggBodyBuilder, 
  fun_: String, substitutions: Substitutions,
  args: Slice[EggId], return_type: EggType,
): EggId {
  builder.push(EggExpr.call_fun(EggCallFun {
    fun_, substitutions, args, return_type
  }))
}

fun call(builder: &EggBodyBuilder, lambda: EggId, args: Slice[EggId]): EggId {
  builder.push(EggExpr.call_lambda(EggCallLambda { lambda, args, }))
}

fun call(builder: &EggBodyBuilder, 
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[EggId]
): EggId {
  builder.push(EggExpr.call_builtin(EggCallBuiltin {
    builtin, substitutions, args
  }))
}

fun cast(builder: &EggBodyBuilder, what: EggId, type: EggType): EggId {
  builder.push(EggExpr.cast(EggCast { what, type }))
}

fun byte(builder: &EggBodyBuilder, byte: Byte): EggId {
  builder.push(EggExpr.byte(byte))
}

fun lower_byte(builder: &EggBodyBuilder, int: EggId): EggId {
  builder.push(EggExpr.lower_byte(int))
}

fun byte_to_int(builder: &EggBodyBuilder, byte: EggId): EggId {
  builder.push(EggExpr.byte_to_int(byte))
}

fun add(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.add(tuple(a, b)))
}

fun subtract(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.subtract(tuple(a, b)))
}

fun multiply(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.multiply(tuple(a, b)))
}

fun divide(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.divide(tuple(a, b)))
}

fun modulo(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.modulo(tuple(a, b)))
}

fun and_(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.and_(tuple(a, b)))
}

fun or_(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.or_(tuple(a, b)))
}

fun xor(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.xor(tuple(a, b)))
}

fun compare(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.compare(tuple(a, b)))
}

fun unchecked_divide(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.unchecked_divide(tuple(a, b)))
}

fun unchecked_modulo(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.unchecked_modulo(tuple(a, b)))
}

fun box(builder: &EggBodyBuilder, arg: EggId): EggId {
  builder.push(EggExpr.box(arg))
}

fun unbox(builder: &EggBodyBuilder, arg: EggId): EggId {
  builder.push(EggExpr.unbox(arg))
}

fun array(
  builder: &EggBodyBuilder, items: Slice[EggId], item_type: EggType
): EggId {
  builder.push(EggExpr.array(EggArray { items, item_type }))
}

fun generate_array(
  builder: &EggBodyBuilder, length: EggId, generator: EggBody
): EggId {
  builder.push(EggExpr.generate_array(EggGenerateArray { length, generator }))
}

fun array_get(builder: &EggBodyBuilder, array: EggId, index: EggId): EggId {
  builder.push(EggExpr.array_get(EggArrayGet { array, index }))
}

fun array_set(
  builder: &EggBodyBuilder, array: EggId, index: EggId, item: EggId
): EggId {
  builder.push(EggExpr.array_set(EggArraySet { array, index, item }))
}

fun array_slice(
  builder: &EggBodyBuilder, array: EggId, start: EggId, end: EggId
): EggId {
  builder.push(EggExpr.array_slice(EggArraySlice { array, start, end }))
}

fun array_len(builder: &EggBodyBuilder, array: EggId): EggId {
  builder.push(EggExpr.array_len(array))
}

fun unchecked_generate_non_empty_array(
  builder: &EggBodyBuilder, length: EggId, generator: EggBody
): EggId {
  builder.push(EggExpr.unchecked_generate_non_empty_array(EggGenerateArray {
    length, generator
  }))
}

fun unchecked_array_get(
  builder: &EggBodyBuilder, array: EggId, index: EggId
): EggId {
  builder.push(EggExpr.unchecked_array_get(EggArrayGet { array, index }))
}

fun unchecked_array_set(
  builder: &EggBodyBuilder, array: EggId, index: EggId, item: EggId
): EggId {
  builder.push(EggExpr.unchecked_array_set(EggArraySet { array, index, item }))
}

fun unchecked_array_slice(
  builder: &EggBodyBuilder, array: EggId, start: EggId, end: EggId
): EggId {
  builder.push(EggExpr.unchecked_array_slice(EggArraySlice {
    array, start, end
  }))
}

fun type_info(builder: &EggBodyBuilder, type: EggId): EggId {
  builder.push(EggExpr.type_info(type))
}

fun static_to_dynamic(builder: &EggBodyBuilder, static: EggId): EggId {
  builder.push(EggExpr.static_to_dynamic(static))
}

fun dynamic_to_static(
  builder: &EggBodyBuilder, dynamic: EggId, static: EggType
): EggId {
  builder.push(EggExpr.dynamic_to_static(EggDynamicToStatic {
    dynamic, static
  }))
}

fun crash(builder: &EggBodyBuilder, message: EggId, type: EggType): EggId {
  builder.push(EggExpr.crash(EggCrash { message, type }))
}

fun crash(builder: &EggBodyBuilder, message: String, type: EggType): EggId {
  builder.crash(builder.string(message), type)
}

fun unreachable(builder: &EggBodyBuilder, type: EggType): EggId {
  builder.push(EggExpr.unreachable(type))
}

fun recursive(
  builder: &EggBodyBuilder, initial: Slice[EggId], body: EggBody
): EggId {
  builder.push(EggExpr.recursive(EggRecursive { initial, body }))
}

fun recurse(
  builder: &EggBodyBuilder, next: Slice[EggId], type: EggType
): EggId {
  builder.push(EggExpr.recurse(EggRecurse { next, type }))
}

| fun loop_(name: String, args: Slice[EggId], body: EggBody): EggId {
|   EggExpr.loop_(EggLoop { name, args, body = body.put_on_heap() })
|     .egg_dag.put(body.returns.type)
| }
| fun continue_(args: Slice[EggId]): EggId {
|   EggExpr.continue_(args).egg_dag.put(type_never)
| }


fun nothing(builder: &EggBodyBuilder): EggId {
  builder.struct_(map[String, EggId]())
}

fun if_(
  builder: &EggBodyBuilder, condition: EggId, then_: EggBody, else_: EggBody
): EggId {
  builder.switch_(condition, then_.returns.type(), map(
    "true" -> then_,
    "false" -> else_,
  ))
}

fun switch_on_ordering(
  builder: &EggBodyBuilder,
  ordering: EggId, less: EggBody, equal: EggBody, greater: EggBody,
): EggId {
  builder.switch_(ordering, less.returns.type(), map(
    "less" -> less,
    "equal" -> equal,
    "greater" -> greater,
  ))
}

fun egg_body_taking_nothing_returning_nothing(): EggBody {
  var builder = egg_body_builder().&
  builder.param(type_nothing)
  builder.finish(builder.nothing())
}

fun egg_body_taking_nothing_crashing_with_out_of_bounds(): EggBody {
  var builder = egg_body_builder().&
  builder.param(type_nothing)
  builder.finish(builder.crash("out of bounds", type_nothing))
}

| var egg_nothing = struct_(map[String, EggId]())
| var egg_true = enum_(type_bool, "true", egg_nothing)
| var egg_false = enum_(type_bool, "false", egg_nothing)

| fun body(
|   dag: &Dag[EggId], params: Slice[EggType], returns: EggId
| ): EggBody {
|   var body = dag.body_builder().&
|   for param in params do body.param(param)
|   body.finish(returns)
| }
