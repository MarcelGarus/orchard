import mod.mar

fun egg_param(type: EggType): Id { egg_dag.put(EggOp.param(type)) }

fun egg_type(type: EggType): Id { egg_dag.put(EggOp.type(type)) }

fun egg_int(int: Int): Id { egg_dag.put(EggOp.int(int)) }

fun egg_string(string: String): Id { egg_dag.put(EggOp.string(string)) }

fun egg_struct(fields: Map[String, Id]): Id {
  egg_dag.put(EggOp.struct_(fields))
}

fun egg_enum(type: EggType, variant: String, payload: Id): Id {
  egg_dag.put(EggOp.enum_(EggEnum { type, variant, payload }))
}

fun egg_lambda(body: EggBody): Id { egg_dag.put(EggOp.lambda(body)) }

fun egg_member(of: Id, name: String): Id {
  egg_dag.put(EggOp.member(EggMember { of, name }))
}

fun egg_switch(condition: Id, type: EggType, cases: Map[String, EggBody]): Id {
  egg_dag.put(EggOp.switch_(EggSwitch { condition, type, cases }))
}

fun egg_call(
  fun_: String, substitutions: Substitutions,
  args: Slice[Id], return_type: EggType,
): Id {
  egg_dag.put(EggOp.call_fun(EggCallFun {
    fun_, substitutions, args, return_type
  }))
}

fun egg_call(lambda: Id, args: Slice[Id]): Id {
  egg_dag.put(EggOp.call_lambda(EggCallLambda { lambda, args, }))
}

fun egg_call(
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[Id]
): Id {
  egg_dag.put(EggOp.call_builtin(EggCallBuiltin {
    builtin, substitutions, args
  }))
}

fun egg_cast(what: Id, type: EggType): Id {
  egg_dag.put(EggOp.cast(EggCast { what, type }))
}

fun egg_crash(message: Id): Id {
  egg_call(EggBuiltin.crash, no_substitutions, list(message).to_slice())
}

fun egg_crash(message: String): Id { egg_crash(egg_string(message)) }

| fun recursive_call(args: Slice[Id], return_type: EggType): Id {
|   call(EggCallee.recursive, args, return_type)
| }
| fun add(a: Id, b: Id): Id {
|   EggBuiltin.add_ints.call(list(a, b).to_slice(), type_int)
| }
| fun array_get(array: Id, index: Id): Id {
|   EggBuiltin.array_get.call(
|     list(array, index).to_slice(),
|     array.type.kind().array.unwrap(),
|   )
| }
| fun array_len(array: Id): Id {
|   EggBuiltin.array_len.call(list(array).to_slice(), type_int)
| }
| fun box(inner: Id): Id {
|   EggBuiltin.box.no_substitutions().call(
|     list(inner).to_slice(), type_box(inner.type)
|   )
| }
| fun unbox(box: Id): Id {
|   EggCalledBuiltin {}
|   EggBuiltin.unbox.call(
|     list(box).to_slice(), box.type.kind().box.unwrap()
|   )
| }
| fun byte_to_int(byte: Id): Id {
|   EggBuiltin.byte_to_int.call(list(byte).to_slice(), type_int)
| }
| fun generate_array(length: Id, generator: Id): Id {
|   EggBuiltin.generate_array.call(
|     list(length, generator).to_slice(),
|     type_array(body.type_of(generator).kind().lambda.unwrap().return_type),
|   )
| }
| fun compare_ints(a: Id, b: Id): Id {
|   EggBuiltin.compare_ints.call(list(a, b).to_slice(), type_ordering)
| }


| fun egg_unreachable(type: EggType): Id {
|   egg_crash("unreachable", type)
| }
| fun loop_(name: String, args: Slice[Id], body: EggBody): Id {
|   EggOp.loop_(EggLoop { name, args, body = body.put_on_heap() })
|     .egg_dag.put(body.returns.type)
| }
| fun continue_(args: Slice[Id]): Id {
|   EggOp.continue_(args).egg_dag.put(type_never)
| }


| var egg_nothing = struct_(map[String, Id]())
| var egg_true = enum_(type_bool, "true", egg_nothing)
| var egg_false = enum_(type_bool, "false", egg_nothing)

| fun body(
|   dag: &Dag[Id], params: Slice[EggType], returns: Id
| ): EggBody {
|   var body = dag.body_builder().&
|   for param in params do body.param(param)
|   body.finish(returns)
| }
| fun body_accepting_nothing(dag: &Dag[Id], returns: Id): EggBody {
|   body(list(type_nothing).to_slice(), returns)
| }

| fun with_substitutions(
|   builtin: EggBuiltin, substitutions: Substitutions
| ): EggCalledBuiltin {
|   EggCalledBuiltin { builtin, substitutions }
| }
| fun no_substitutions(builtin: EggBuiltin): EggCalledBuiltin {
|   builtin.with_substitutions(no_substitutions)
| }


struct EggBuilder { params: List[Id], children: List[Id] }
fun egg_builder(): _ {
  EggBuilder { params = list[Id](), children = list[Id]() }
}
fun push_param(builder: &EggBuilder, id: Id) { builder.params.&.push(id) }
fun push(builder: &EggBuilder, id: Id) { builder.children.&.push(id) }
fun finish(builder: EggBuilder, returns: Id): EggBody {
  EggBody {
    params = builder.params.to_slice(),
    children = builder.children.to_slice(),
    returns,
  }
}
