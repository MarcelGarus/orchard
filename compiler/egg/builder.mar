import mod.mar

struct EggBodyBuilder {
  dag: &Dag[EggExpr], params: List[Id], children: List[Id]
}
fun body_builder(dag: &Dag[EggExpr]): _ {
  EggBodyBuilder { dag, params = list[Id](), children = list[Id]() }
}
fun finish(builder: EggBodyBuilder, returns: EggExpr): EggBody {
  EggBody {
    params = builder.params.to_slice(),
    children = builder.children.to_slice(),
    returns,
  }
}
fun push_param(builder: &EggBodyBuilder, type: EggType, src: Src): EggExpr {
  var id = builder.dag.put(expr(EggOp.param, type, src))
  builder.params.&.push(id)
  egg_id(id, type, src)
}
fun push(builder: &EggBodyBuilder, expr: EggExpr): EggExpr {
  if expr.op is param then panic("pushing param to body")
  var id = builder.dag.put(expr)
  builder.children.&.push(id)
  egg_id(id, expr.type, expr.src)
}

| Functions for creating expressions.

fun expr(op: EggOp, type: EggType, src: Src): EggExpr {
  EggExpr { op, type, src }
}

fun egg_id(id: Id, type: EggType, src: Src): EggExpr {
  expr(EggOp.id(id), type, src)
}
fun egg_type(type: EggType, src: Src): EggExpr {
  expr(EggOp.type(type), type_type, src)
}
fun egg_int(int: Int, src: Src): EggExpr { expr(EggOp.int(int), type_int, src) }
fun egg_string(string: String, src: Src): EggExpr {
  expr(EggOp.string(string), type_string, src)
}
fun struct_(fields: Slice[Tuple2[String, EggExpr]], src: Src): EggExpr {
  var field_types = map[String, EggType]()
  for field in fields do field_types.&.put(field.a, field.b.type)
  expr(EggOp.struct_(fields), type_struct(field_types), src)
}
fun enum_(type: EggType, name: String, value: EggExpr, src: Src): EggExpr {
  expr(EggOp.enum_(EggEnum { name, value = value.put_on_heap() }), type, src)
}
fun lambda(dag: Dag[EggExpr], body: EggBody, src: Src): EggExpr {
  var param_types = list[EggType]()
  for id in body.params do param_types.&.push(dag.type_of(id))
  var type = type_lambda(param_types.to_slice(), body.returns.type)
  expr(EggOp.lambda(body.put_on_heap()), type, src)
}
fun member(of: EggExpr, name: String, src: Src): EggExpr {
  expr(
    EggOp.member(EggMember { of = of.put_on_heap(), name }),
    of.type.kind().struct_.unwrap().get(name),
    src,
  )
}
fun switch_(
  condition: EggExpr, type: EggType, cases: Map[String, EggBody], src: Src
): EggExpr {
  expr(
    EggOp.switch_(EggSwitch { condition = condition.put_on_heap(), cases }),
    type,
    src,
  )
}
fun call(
  callee: EggCallee, args: Slice[EggExpr], return_type: EggType, src: Src
): EggExpr {
  expr(EggOp.call(EggCall { callee, args }), return_type, src)
}
fun call(
  fun_: EggCalledFun, args: Slice[EggExpr], return_type: EggType, src: Src
): EggExpr {
  EggCallee.fun_(fun_).call(args, return_type, src)
}
fun call(
  builtin: EggCalledBuiltin, args: Slice[EggExpr], return_type: EggType,
  src: Src,
): EggExpr {
  EggCallee.builtin(builtin).call(args, return_type, src)
}
fun call(lambda: EggExpr, args: Slice[EggExpr], src: Src): EggExpr {
  EggCallee.lambda(lambda.put_on_heap()).call(
    args, lambda.type.kind().lambda.unwrap().return_type, src
  )
}
fun cast(expr: EggExpr, type: EggType, src: Src): EggExpr {
  if expr.type == type then return expr
  expr(EggOp.cast(expr.put_on_heap()), type, src)
}

fun crash(message: EggExpr, type: EggType, src: Src): EggExpr {
  EggBuiltin.crash.no_substitutions().call(list(message).to_slice(), type, src)
}
fun egg_crash(message: String, type: EggType, src: Src): EggExpr {
  crash(egg_string(message, src), type, src)
}

| fun recursive_call(args: Slice[EggExpr], return_type: EggType): Id {
|   call(EggCallee.recursive, args, return_type)
| }
| fun add(a: Id, b: Id): Id {
|   EggBuiltin.add_ints.call(list(a, b).to_slice(), type_int)
| }
| fun array_get(array: Id, index: Id): Id {
|   EggBuiltin.array_get.call(
|     list(array, index).to_slice(),
|     array.type.kind().array.unwrap(),
|   )
| }
| fun array_len(array: Id): Id {
|   EggBuiltin.array_len.call(list(array).to_slice(), type_int)
| }
| fun box(inner: Id): Id {
|   EggBuiltin.box.no_substitutions().call(
|     list(inner).to_slice(), type_box(inner.type)
|   )
| }
| fun unbox(box: Id): Id {
|   EggCalledBuiltin {}
|   EggBuiltin.unbox.call(
|     list(box).to_slice(), box.type.kind().box.unwrap()
|   )
| }
| fun byte_to_int(byte: Id): Id {
|   EggBuiltin.byte_to_int.call(list(byte).to_slice(), type_int)
| }
| fun generate_array(length: Id, generator: Id): Id {
|   EggBuiltin.generate_array.call(
|     list(length, generator).to_slice(),
|     type_array(body.type_of(generator).kind().lambda.unwrap().return_type),
|   )
| }
| fun compare_ints(a: Id, b: Id): Id {
|   EggBuiltin.compare_ints.call(list(a, b).to_slice(), type_ordering)
| }


| fun egg_unreachable(type: EggType): Id {
|   egg_crash("unreachable", type)
| }
| fun loop_(name: String, args: Slice[EggExpr], body: EggBody): Id {
|   EggOp.loop_(EggLoop { name, args, body = body.put_on_heap() })
|     .expr(body.returns.type)
| }
| fun continue_(args: Slice[EggExpr]): Id {
|   EggOp.continue_(args).expr(type_never)
| }

var egg_nothing = struct_(map[String, EggExpr]())
var egg_true = enum_(type_bool, "true", egg_nothing)
var egg_false = enum_(type_bool, "false", egg_nothing)

fun body(
  dag: &Dag[EggExpr], params: Slice[EggType], returns: EggExpr
): EggBody {
  var body = dag.body_builder().&
  for param in params do body.param(param)
  body.finish(returns)
}
fun body_accepting_nothing(dag: &Dag[EggExpr], returns: EggExpr): EggBody {
  body(list(type_nothing).to_slice(), returns)
}

fun with_substitutions(
  builtin: EggBuiltin, substitutions: Substitutions
): EggCalledBuiltin {
  EggCalledBuiltin { builtin, substitutions }
}
fun no_substitutions(builtin: EggBuiltin): EggCalledBuiltin {
  builtin.with_substitutions(no_substitutions)
}
