import mod.mar

struct EggBodyBuilder { params: List[EggId], children: List[EggId] }
fun egg_body_builder(): _ {
  EggBodyBuilder { params = list[EggId](), children = list[EggId]() }
}
fun param(builder: &EggBodyBuilder, type: EggType): EggId {
  var id = EggId { id = egg_dag.put(EggExpr.param(type)) }
  builder.params.&.push(id)
  id
}
fun push(builder: &EggBodyBuilder, op: EggExpr): EggId {
  var id = EggId { id = egg_dag.put(op) }
  builder.children.&.push(id)
  id
}
fun finish(builder: EggBodyBuilder, returns: EggId): EggBody {
  EggBody {
    params = builder.params.to_slice(),
    children = builder.children.to_slice(),
    returns,
  }
}

fun type(builder: &EggBodyBuilder, type: EggType): EggId {
  builder.push(EggExpr.type(type))
}

fun int(builder: &EggBodyBuilder, int: Int): EggId {
  builder.push(EggExpr.int(int))
}

fun string(builder: &EggBodyBuilder, string: String): EggId {
  builder.push(EggExpr.string(string))
}

fun struct_(builder: &EggBodyBuilder, fields: Map[String, EggId]): EggId {
  builder.push(EggExpr.struct_(fields))
}

fun enum_(builder: &EggBodyBuilder, type: EggType, variant: String, payload: EggId): EggId {
  builder.push(EggExpr.enum_(EggEnum { type, variant, payload }))
}

fun lambda(builder: &EggBodyBuilder, body: EggBody): EggId {
  builder.push(EggExpr.lambda(body))
}

fun member(builder: &EggBodyBuilder, of: EggId, name: String): EggId {
  builder.push(EggExpr.member(EggMember { of, name }))
}

fun switch_(
  builder: &EggBodyBuilder, condition: EggId, type: EggType, cases: Map[String, EggBody]
): EggId {
  builder.push(EggExpr.switch_(EggSwitch { condition, type, cases }))
}

fun call(
  builder: &EggBodyBuilder, 
  fun_: String, substitutions: Substitutions,
  args: Slice[EggId], return_type: EggType,
): EggId {
  builder.push(EggExpr.call_fun(EggCallFun {
    fun_, substitutions, args, return_type
  }))
}

fun call(builder: &EggBodyBuilder, lambda: EggId, args: Slice[EggId]): EggId {
  builder.push(EggExpr.call_lambda(EggCallLambda { lambda, args, }))
}

fun call(builder: &EggBodyBuilder, 
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[EggId]
): EggId {
  builder.push(EggExpr.call_builtin(EggCallBuiltin {
    builtin, substitutions, args
  }))
}

fun cast(builder: &EggBodyBuilder, what: EggId, type: EggType): EggId {
  builder.push(EggExpr.cast(EggCast { what, type }))
}

fun byte(builder: &EggBodyBuilder, byte: Byte): EggId {
  builder.push(EggExpr.byte(byte))
}

fun lower_byte(builder: &EggBodyBuilder, int: EggId): EggId {
  builder.push(EggExpr.lower_byte(int))
}

fun byte_to_int(builder: &EggBodyBuilder, byte: EggId): EggId {
  builder.push(EggExpr.byte_to_int(byte))
}

fun add(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.add(tuple(a, b)))
}

fun subtract(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.subtract(tuple(a, b)))
}

fun multiply(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.multiply(tuple(a, b)))
}

fun divide(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.divide(tuple(a, b)))
}

fun modulo(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.modulo(tuple(a, b)))
}

fun and_(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.and_(tuple(a, b)))
}

fun or_(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.or_(tuple(a, b)))
}

fun xor(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.xor(tuple(a, b)))
}

fun compare(builder: &EggBodyBuilder, a: EggId, b: EggId): EggId {
  builder.push(EggExpr.compare(tuple(a, b)))
}

fun box(builder: &EggBodyBuilder, arg: EggId): EggId {
  builder.push(EggExpr.box(arg))
}

fun unbox(builder: &EggBodyBuilder, arg: EggId): EggId {
  builder.push(EggExpr.unbox(arg))
}

fun array(
  builder: &EggBodyBuilder, items: Slice[EggId], item_type: EggType
): EggId {
  builder.push(EggExpr.array(EggArray { items, item_type }))
}

fun generate_array(
  builder: &EggBodyBuilder, length: EggId, generator: EggBody
): EggId {
  builder.push(EggExpr.generate_array(EggGenerateArray { length, generator }))
}

fun array_get(builder: &EggBodyBuilder, array: EggId, index: EggId): EggId {
  builder.push(EggExpr.array_get(EggArrayGet { array, index }))
}

fun array_set(
  builder: &EggBodyBuilder, array: EggId, index: EggId, item: EggId
): EggId {
  builder.push(EggExpr.array_set(EggArraySet { array, index, item }))
}

fun array_slice(
  builder: &EggBodyBuilder, array: EggId, start: EggId, end: EggId
): EggId {
  builder.push(EggExpr.array_slice(EggArraySlice { array, start, end }))
}

fun array_len(builder: &EggBodyBuilder, array: EggId): EggId {
  builder.push(EggExpr.array_len(array))
}

fun type_info(builder: &EggBodyBuilder, type: EggId): EggId {
  builder.push(EggExpr.type_info(type))
}

fun static_to_dynamic(builder: &EggBodyBuilder, static: EggId): EggId {
  builder.push(EggExpr.static_to_dynamic(static))
}

fun dynamic_to_static(
  builder: &EggBodyBuilder, dynamic: EggId, static: EggType
): EggId {
  builder.push(EggExpr.dynamic_to_static(EggDynamicToStatic {
    dynamic, static
  }))
}

fun crash(builder: &EggBodyBuilder, message: EggId, type: EggType): EggId {
  builder.push(EggExpr.crash(EggCrash { message, type }))
}

fun crash(builder: &EggBodyBuilder, message: String, type: EggType): EggId {
  builder.crash(builder.string(message), type)
}

fun unreachable(builder: &EggBodyBuilder, type: EggType): EggId {
  builder.push(EggExpr.unreachable(type))
}
fun recursive(
  builder: &EggBodyBuilder, initial: Slice[EggId], body: EggBody
): EggId {
  builder.push(EggExpr.recursive(EggRecursive { initial, body }))
}
fun recurse(
  builder: &EggBodyBuilder, next: Slice[EggId], type: EggType
): EggId {
  builder.push(EggExpr.recurse(EggRecurse { next, type }))
}

| fun recursive_call(args: Slice[EggId], return_type: EggType): EggId {
|   call(EggCallee.recursive, args, return_type)
| }
| fun add(a: EggId, b: EggId): EggId {
|   EggBuiltin.add_ints.call(list(a, b).to_slice(), type_int)
| }
| fun array_get(array: EggId, index: EggId): EggId {
|   EggBuiltin.array_get.call(
|     list(array, index).to_slice(),
|     array.type.kind().array.unwrap(),
|   )
| }
| fun array_len(array: EggId): EggId {
|   EggBuiltin.array_len.call(list(array).to_slice(), type_int)
| }
| fun box(inner: EggId): EggId {
|   EggBuiltin.box.no_substitutions().call(
|     list(inner).to_slice(), type_box(inner.type)
|   )
| }
| fun unbox(box: EggId): EggId {
|   EggCalledBuiltin {}
|   EggBuiltin.unbox.call(
|     list(box).to_slice(), box.type.kind().box.unwrap()
|   )
| }
| fun byte_to_int(byte: EggId): EggId {
|   EggBuiltin.byte_to_int.call(list(byte).to_slice(), type_int)
| }
| fun generate_array(length: EggId, generator: EggId): EggId {
|   EggBuiltin.generate_array.call(
|     list(length, generator).to_slice(),
|     type_array(body.type_of(generator).kind().lambda.unwrap().return_type),
|   )
| }
| fun compare_ints(a: EggId, b: EggId): EggId {
|   EggBuiltin.compare_ints.call(list(a, b).to_slice(), type_ordering)
| }


| fun unreachable(builder: &EggBodyBuilder, type: EggType): EggId {
|   egg_crash("unreachable", type)
| }
| fun loop_(name: String, args: Slice[EggId], body: EggBody): EggId {
|   EggExpr.loop_(EggLoop { name, args, body = body.put_on_heap() })
|     .egg_dag.put(body.returns.type)
| }
| fun continue_(args: Slice[EggId]): EggId {
|   EggExpr.continue_(args).egg_dag.put(type_never)
| }


| var egg_nothing = struct_(map[String, EggId]())
| var egg_true = enum_(type_bool, "true", egg_nothing)
| var egg_false = enum_(type_bool, "false", egg_nothing)

| fun body(
|   dag: &Dag[EggId], params: Slice[EggType], returns: EggId
| ): EggBody {
|   var body = dag.body_builder().&
|   for param in params do body.param(param)
|   body.finish(returns)
| }
| fun body_accepting_nothing(dag: &Dag[EggId], returns: EggId): EggBody {
|   body(list(type_nothing).to_slice(), returns)
| }

| fun with_substitutions(
|   builtin: EggBuiltin, substitutions: Substitutions
| ): EggCalledBuiltin {
|   EggCalledBuiltin { builtin, substitutions }
| }
| fun no_substitutions(builtin: EggBuiltin): EggCalledBuiltin {
|   builtin.with_substitutions(no_substitutions)
| }
