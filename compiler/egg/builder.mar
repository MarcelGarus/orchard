import mod.mar

struct EggBodyBuilder { params: List[EggId], children: List[EggId] }
fun egg_body_builder(): _ {
  EggBodyBuilder { params = list[EggId](), children = list[EggId]() }
}
fun finish(body: EggBodyBuilder, returns: EggExpr): EggBody {
  EggBody {
    params = body.params.to_slice(),
    children = body.children.to_slice(),
    returns,
  }
}
fun push_param(body: &EggBodyBuilder, type: EggType): EggExpr {
  var id = EggOp.param.expr(type).create()
  body.params.&.push(id)
  EggExpr { op = EggOp.id(id), type, src = invalid_src }
}
fun push(body: &EggBodyBuilder, expr: EggExpr): EggExpr {
  if expr.op is param then panic("pushing param to body")
  var id = expr.create()
  body.children.&.push(id)
  EggExpr { op = EggOp.id(id), type = expr.type, src = expr.src }
}


fun with_substitutions(
  builtin: EggBuiltin, substitutions: Substitutions
): EggCalledBuiltin {
  EggCalledBuiltin { builtin, substitutions }
}
fun no_substitutions(builtin: EggBuiltin): EggCalledBuiltin {
  builtin.with_substitutions(no_substitutions)
}

| Helper functions for creating EggExprs.

fun expr(op: EggOp, type: EggType): EggExpr { op.expr(type, invalid_src) }

fun egg_id(id: EggId, type: EggType): EggExpr { EggOp.id(id).expr(type) }
fun egg_byte(byte: Byte): EggExpr { EggOp.byte(byte).expr(type_byte) }
fun egg_int(int: Int): EggExpr { EggOp.int(int).expr(type_int) }
fun array(item_type: EggType, items: Slice[EggExpr]): EggExpr {
  EggOp.array(items).expr(type_array(item_type))
}
fun egg_string(string: String): EggExpr {
  var bytes = list[EggExpr]()
  for byte in string.bytes() do bytes.&.push(egg_byte(byte))
  struct_(map("utf8_bytes" -> array(type_byte, bytes.to_slice())))
}
fun struct_(fields: Map[String, EggExpr]): EggExpr {
  var field_types = map[String, EggType]()
  for field in fields do field_types.&.put(field.key, field.value.type)
  EggOp.struct_(fields).expr(type_struct(field_types))
}
fun member(of: EggExpr, name: String): EggExpr {
  EggOp.member(EggMember { of = of.put_on_heap(), name })
    .expr(of.type.kind().struct_.unwrap().get(name))
}
fun enum_(type: EggType, name: String, value: EggExpr): EggExpr {
  EggOp.enum_(EggEnum { name, value = value.put_on_heap() }).expr(type)
}
fun switch_(
  condition: EggExpr, type: EggType, cases: Map[String, EggBody]
): EggExpr {
  EggOp.switch_(EggSwitch {
    condition = condition.put_on_heap(), cases
  }).expr(type)
}
fun lambda(body: EggBody): EggExpr {
  var param_types = list[EggType]()
  for id in body.params do param_types.&.push(id.get().type)
  var type = type_lambda(param_types.to_slice(), body.returns.type)
  EggOp.lambda(body.put_on_heap()).expr(type)
}
fun call(
  callee: EggCallee, args: Slice[EggExpr], return_type: EggType
): EggExpr {
  EggOp.call(EggCall { callee, args }).expr(return_type)
}
fun call(lambda: EggExpr, args: Slice[EggExpr]): EggExpr {
  call(
    EggCallee.lambda(lambda.put_on_heap()),
    args,
    lambda.type.kind().lambda.unwrap().return_type,
  )
}
fun call(
  fun_: EggCalledFun, args: Slice[EggExpr], return_type: EggType
): EggExpr {
  call(EggCallee.fun_(fun_), args, return_type)
}
fun call(
  builtin: EggCalledBuiltin, args: Slice[EggExpr], return_type: EggType
): EggExpr {
  call(EggCallee.builtin(builtin), args, return_type)
}
fun recursive_call(args: Slice[EggExpr], return_type: EggType): EggExpr {
  call(EggCallee.recursive, args, return_type)
}
fun add(a: EggExpr, b: EggExpr): EggExpr {
  EggBuiltin.add_ints.call(list(a, b).to_slice(), type_int)
}
fun array_get(array: EggExpr, index: EggExpr): EggExpr {
  EggBuiltin.array_get.call(
    list(array, index).to_slice(),
    array.type.kind().array.unwrap(),
  )
}
fun array_len(array: EggExpr): EggExpr {
  EggBuiltin.array_len.call(list(array).to_slice(), type_int)
}
fun box(inner: EggExpr): EggExpr {
  EggBuiltin.box.no_substitutions().call(
    list(inner).to_slice(), type_box(inner.type)
  )
}
fun unbox(box: EggExpr): EggExpr {
  EggCalledBuiltin {}
  EggBuiltin.unbox.call(
    list(box).to_slice(), box.type.kind().box.unwrap()
  )
}
fun byte_to_int(byte: EggExpr): EggExpr {
  EggBuiltin.byte_to_int.call(list(byte).to_slice(), type_int)
}
fun generate_array(length: EggExpr, generator: EggExpr): EggExpr {
  EggBuiltin.generate_array.call(
    list(length, generator).to_slice(),
    type_array(body.type_of(generator).kind().lambda.unwrap().return_type),
  )
}
fun compare_ints(a: EggExpr, b: EggExpr): EggExpr {
  EggBuiltin.compare_ints.call(list(a, b).to_slice(), type_ordering)
}
fun cast(expr: EggExpr, type: EggType): EggExpr {
  if expr.type == type then expr else EggOp.cast(expr.put_on_heap()).expr(type)
}
fun crash(message: EggExpr, type: EggType): EggExpr {
  EggBuiltin.crash.no_substitutions().call(list(message).to_slice(), type)
}
fun egg_crash(message: String, type: EggType): EggExpr {
  crash(egg_string(message), type)
}
fun egg_unreachable(type: EggType): EggExpr {
  egg_crash("unreachable", type)
}
fun loop_(name: String, args: Slice[EggExpr], body: EggBody): EggExpr {
  EggOp.loop_(EggLoop { name, args, body = body.put_on_heap() })
    .expr(body.returns.type)
}
fun continue_(args: Slice[EggExpr]): EggExpr {
  EggOp.continue_(args).expr(type_never)
}
fun egg_type(type: EggType): EggExpr {
  EggOp.type(type).expr(type_type)
}
var egg_nothing = struct_(map[String, EggExpr]())
var egg_true = enum_(type_bool, "true", egg_nothing)
var egg_false = enum_(type_bool, "false", egg_nothing)

fun body(params: Slice[EggType], returns: EggExpr): EggBody {
  var body = egg_body_builder().&
  for param in params do body.param(param)
  body.finish(returns)
}
fun body_accepting_nothing(returns: EggExpr): EggBody {
  body(list(type_nothing).to_slice(), returns)
}
