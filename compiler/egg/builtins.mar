import mod.mar

| Plum code can import these functions from the "builtins" module.
enum EggBuiltin {
  | byte operations
  lower_byte,        | Int -> Byte
  byte_to_int,       | Byte -> Int

  | int operations
  | TODO: rename to full words
  add_ints,          | Int Int -> Int
  sub_ints,          | Int Int -> Int
  mul_ints,          | Int Int -> Int
  div_ints,          | Int Int -> Int. Or crash: "divide by zero"
  mod_ints,          | Int Int -> Int. Or crash: "modulo by zero"
  and_ints,          | Int Int -> Int
  or_ints,           | Int Int -> Int
  xor_ints,          | Int Int -> Int
  compare_ints,      | Int Int -> Ordering

  | box operations
  box,               | t -> (Box t)
  unbox,             | (Box t) -> t

  | array operations
  generate_array,    | Int (\ Int -> t) -> (Array t)
  array_get,         | (Array t) Int -> t.             Or crash: "out of bounds"
  array_set,         | (Array t) Int t -> (Array t).   Or crash: "out of bounds"
  array_slice,       | (Array t) Int Int -> (Array t). Or crash: "out of bounds"
  array_len,         | (Array t) -> Int

  | lambda operations
  call,              | (\ -> t) -> t

  | error stuff
  crash,             | String -> Never. Will crash.

  | type operations
  type_of,           | t -> Type
  type_info,         | Type -> TypeInfo

  | dynamic typing operations
  static_to_dynamic, | t -> Dynamic
  dynamic_to_static, | Dynamic -> t. Or crash: "bad shape"
}

var egg_builtins = | Keep in sync with the builtins above!
  list(
    EggBuiltin.lower_byte, EggBuiltin.byte_to_int,
    EggBuiltin.add_ints, EggBuiltin.sub_ints, EggBuiltin.mul_ints,
    EggBuiltin.div_ints, EggBuiltin.mod_ints, EggBuiltin.and_ints,
    EggBuiltin.or_ints, EggBuiltin.xor_ints,
    EggBuiltin.compare_ints,
    EggBuiltin.box, EggBuiltin.unbox,
    EggBuiltin.generate_array, EggBuiltin.array_get, EggBuiltin.array_set,
    EggBuiltin.array_slice, EggBuiltin.array_len,
    EggBuiltin.call,
    EggBuiltin.crash,
    EggBuiltin.type_of, EggBuiltin.type_info,
    EggBuiltin.static_to_dynamic, EggBuiltin.dynamic_to_static,
  ).to_slice()


struct BuiltinTypeSignature { params: Slice[EggType], return_type: EggType }
fun type_signature(builtin: EggBuiltin): BuiltinTypeSignature {
  var params_and_return_type =
    switch builtin
    case lower_byte tuple(list(type_int), type_byte)
    case byte_to_int tuple(list(type_byte), type_int)
    case add_ints tuple(list(type_int, type_int), type_int)
    case sub_ints tuple(list(type_int, type_int), type_int)
    case mul_ints tuple(list(type_int, type_int), type_int)
    case div_ints tuple(list(type_int, type_int), type_int)
    case mod_ints tuple(list(type_int, type_int), type_int)
    case and_ints tuple(list(type_int, type_int), type_int)
    case or_ints tuple(list(type_int, type_int), type_int)
    case xor_ints tuple(list(type_int, type_int), type_int)
    case compare_ints tuple(list(type_int, type_int), type_ordering)
    case box tuple(list(type_var_t), type_box(type_var_t))
    case unbox tuple(list(type_box(type_var_t)), type_var_t)
    case generate_array
      tuple(
        list(type_int, type_lambda(list(type_int).to_slice(), type_var_t)),
        type_array(type_var_t),
      )
    case array_get tuple(list(type_array(type_var_t), type_int), type_var_t)
    case array_set
      tuple(
        list(type_array(type_var_t), type_int, type_var_t),
        type_array(type_var_t),
      )
    case array_slice
      tuple(
        list(type_array(type_var_t), type_range(type_int)),
        type_array(type_var_t),
      )
    case array_len tuple(list(type_array(type_var_t)), type_int)
    case call
      tuple(list(type_lambda(empty_slice[EggType](), type_var_t)), type_var_t)
    case crash tuple(list(type_string), type_never)
    case type_of tuple(list(type_var_t), type_type)
    case type_info tuple(list(type_type), type_type_info)
    case static_to_dynamic tuple(list(type_var_t), type_dynamic)
    case dynamic_to_static
      tuple(list(type_dynamic, type_type), type_variable("arg_1"))
  BuiltinTypeSignature {
    params = params_and_return_type.a.to_slice(),
    return_type = params_and_return_type.b,
  }
}
