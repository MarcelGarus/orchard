import mod.mar


fun write[W](writer: W, egg: Egg) {
  var first = true
  for fun_ in egg.funs do {
    if first then first = false else writer."\n"
    writer.write(fun_.key, fun_.value)
  }
}

fun pretty(id: EggId, namespace: &Namespace): _ {
  PrettyEggId { id, namespace }
}
struct PrettyEggId { id: EggId, namespace: &Namespace }
fun write[W](writer: W, pretty: PrettyEggId) {
  writer."{pretty.namespace.get(pretty.id.id.index).styled(style_of_id)}"
  |{":{pretty.id.id.index}".styled(style_of_id)}"
}

fun write[W](writer: W, signature: String, fun_: EggFun) {
  var namespace = namespace().&
  writer."{pretty_signature_def(signature)}"
  for param in fun_.body.params do
    writer." {pretty(param, namespace)}"
  writer." =\n"
  writer.write(fun_.body, namespace, indentation(1))
}
fun write[W](
  writer: W, body: EggBody, namespace: &Namespace, indentation: Indentation
) {
  for id in body.children do {
    writer."{indentation}{pretty(id, namespace)} = "
    writer.write(id, namespace, indentation + 1)
    writer."\n"
  }
  writer."{indentation}{pretty(body.returns, namespace)}"
}
fun write[W](
  writer: W, id: EggId, namespace: &Namespace, indentation: Indentation
) {
  var type = id.type()
  switch id.resolve()
  case param(type) writer."{pretty_op("param")}  {pretty(type)}"
  case case_param(param) writer."{pretty_op("case param")}  {pretty(type)}"
  case type(type) writer."{pretty_op("type")} {type}  {pretty(type_type)}"
  case int(int) writer."{pretty_op("int")} {int}  {pretty(type)}"
  case string(string)
    writer."{pretty_op("string")} {string.debug()}  {pretty(type)}"
  case struct_(struct_) {
    writer."{pretty_op("&")}"
    for field in struct_ do
      writer." {field.key}: {pretty(field.value, namespace)}"
    writer."  {pretty(type)}"
  }
  case enum_(enum_)
    writer."
      '{pretty_op("|")} {enum_.variant}: {pretty(enum_.payload, namespace)}
      '  {pretty(type)}"
  case lambda(body) {
    writer."{pretty_op("lambda")}"
    for param in body.params do writer." {pretty(param, namespace)}"
    writer."  {pretty(type)}\n"
    writer.write(body, namespace, indentation)
  }
  case raw_lambda(lambda) {
    writer."
      '{pretty_op("lambda")} {pretty_signature(lambda.fun_)}
      ' {pretty(lambda.closure, namespace)}  {pretty(type)}"
  }
  case member(member)
    writer."
      '{pretty_op("member")} {pretty(member.of, namespace)}.{member.name}
      '  {pretty(type)}"
  case switch_(switch_) {
    writer."\n
      '{indentation}{pretty_op("switch")} {pretty(switch_.condition, namespace)}
      '  {pretty(type)}"
    for case_ in switch_.cases do {
      writer."
        '\n{indentation + 1}{case_.key}:
        ' {pretty(case_.value.params.get(0), namespace)}\n"
      writer.write(case_.value, namespace, indentation + 2)
    }
  }
  case call_fun(call) {
    writer."{pretty_op("call")} {pretty_signature(call.fun_)}"
    if call.substitutions.substitutions.is_not_empty() then
      writer." with {call.substitutions}"
    for arg in call.args do writer." {pretty(arg, namespace)}"
    writer."  {pretty(type)}"
  }
  case call_lambda(call) {
    writer."{pretty_op("call lambda")} {pretty(call.lambda, namespace)}"
    if call.args.is_not_empty() then writer." with"
    for arg in call.args do writer." {pretty(arg, namespace)}"
    writer."  {pretty(type)}"
  }
  case call_builtin(call) {
    writer."{pretty_op("call")} {pretty_signature(call.builtin.format())}"
    if call.substitutions.substitutions.is_not_empty() then
      writer." with {call.substitutions}"
    for arg in call.args do writer." {pretty(arg, namespace)}"
    writer."  {pretty(type)}"
  }
  case cast(cast)
    writer."{pretty_op("cast")} {pretty(cast.what, namespace)}  {pretty(type)}"
  case byte(arg) writer."{pretty_op("byte")} {arg}  {pretty(type)}"
  case lower_byte(arg)
    writer."{pretty_op("lower byte")} {pretty(arg, namespace)}  {pretty(type)}"
  case byte_to_int(arg)
    writer."{pretty_op("byte to int")} {pretty(arg, namespace)}  {pretty(type)}"
  case add(args)
    writer."
      '{pretty_op("add")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case subtract(args)
    writer."
      '{pretty_op("subtract")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case multiply(args)
    writer."
      '{pretty_op("multiply")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case divide(args)
    writer."
      '{pretty_op("divide")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case modulo(args)
    writer."
      '{pretty_op("modulo")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case and_(args)
    writer."
      '{pretty_op("and")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case or_(args)
    writer."
      '{pretty_op("or")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case xor(args)
    writer."
      '{pretty_op("xor")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case compare(args)
    writer."
      '{pretty_op("compare")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case unchecked_divide(args)
    writer."
      '{pretty_op("unchecked divide")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case unchecked_modulo(args)
    writer."
      '{pretty_op("unchecked modulo")}
      ' {pretty(args.a, namespace)}
      ' {pretty(args.b, namespace)}
      '  {pretty(type)}"
  case box(arg)
    writer."
      '{pretty_op("box")}
      ' {pretty(arg, namespace)}
      '  {pretty(type)}"
  case unbox(arg)
    writer."
      '{pretty_op("unbox")}
      ' {pretty(arg, namespace)}
      '  {pretty(type)}"
  case array(array) {
    writer."{pretty_op("array")}"
    for item in array.items do writer." {pretty(item, namespace)}"
    writer."  {pretty(type)}"
  }
  case generate_array(args) {
    writer."\n
      '{indentation}{pretty_op("generate array")}
      ' {pretty(args.length, namespace)}
      '  {pretty(type)}\n
      '{indentation + 1}generator
      ' {pretty(args.generator.params.get(0), namespace)}:\n"
    writer.write(args.generator, namespace, indentation + 2)
  }
  case array_get(args)
    writer."
      '{pretty_op("array get")}
      ' {pretty(args.array, namespace)}
      ' {pretty(args.index, namespace)}
      '  {pretty(type)}"
  case array_set(args)
    writer."
      '{pretty_op("array set")}
      ' {pretty(args.array, namespace)}
      ' {pretty(args.index, namespace)}
      ' {pretty(args.item, namespace)}
      '  {pretty(type)}"
  case array_slice(args)
    writer."
      '{pretty_op("array slice")}
      ' {pretty(args.array, namespace)}
      ' {pretty(args.start, namespace)}
      ' {pretty(args.end, namespace)}
      '  {pretty(type)}"
  case array_len(arg)
    writer."
      '{pretty_op("array length")}
      ' {pretty(arg, namespace)}
      '  {pretty(type)}"
  case unchecked_generate_non_empty_array(args) {
    writer."\n
      '{indentation}{pretty_op("unchecked generate non-empty array")}
      ' {pretty(args.length, namespace)}
      '  {pretty(type)}\n
      '{indentation + 1}generator
      ' {pretty(args.generator.params.get(0), namespace)}:\n"
    writer.write(args.generator, namespace, indentation + 2)
  }
  case unchecked_array_get(args)
    writer."
      '{pretty_op("unchecked array get")}
      ' {pretty(args.array, namespace)}
      ' {pretty(args.index, namespace)}
      '  {pretty(type)}"
  case unchecked_array_set(args)
    writer."
      '{pretty_op("unchecked array set")}
      ' {pretty(args.array, namespace)}
      ' {pretty(args.index, namespace)}
      ' {pretty(args.item, namespace)}
      '  {pretty(type)}"
  case unchecked_array_slice(args)
    writer."
      '{pretty_op("unchecked array slice")}
      ' {pretty(args.array, namespace)}
      ' {pretty(args.start, namespace)}
      ' {pretty(args.end, namespace)}
      '  {pretty(type)}"
  case type_info(arg)
    writer."{pretty_op("type info")} {pretty(arg, namespace)}  {pretty(type)}"
  case static_to_dynamic(arg)
    writer."
      '{pretty_op("static to dynamic")}
      ' {pretty(arg, namespace)}
      '  {pretty(type)}"
  case dynamic_to_static(arg)
    writer."
      '{pretty_op("dynamic to static")}
      ' {pretty(arg.dynamic, namespace)}
      '  {pretty(type)}"
  case crash(crash)
    writer."
      '{pretty_op("crash")} {pretty(crash.message, namespace)}  {pretty(type)}"
  case unreachable writer."{pretty_op("unreachable")}  {pretty(type)}"
  case recursive(recursive) {
    writer."\n{indentation}{pretty_op("recursive")}"
    for arg in recursive.initial do writer." {pretty(arg, namespace)}"
    writer."
      '  {pretty(type)}\n
      '{indentation + 1}body"
    for param in recursive.body.params do writer." {pretty(param, namespace)}"
    writer.":\n"
    writer.write(recursive.body, namespace, indentation + 2)
  }
  case recurse(recurse) {
    writer."{pretty_op("recurse")}"
    for arg in recurse.next do writer." {pretty(arg, namespace)}"
    writer."  {pretty(type)}"
  }
}
fun write[W](writer: W, builtin: EggBuiltin) { writer."{builtin.debug()}" }
