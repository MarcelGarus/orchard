| Expression-Guided Graph  
|
| A representation of code where we have used names to establish the connections
| between types, expressions, and functions.
| 
| Every Egg expression has a type. Function calls are resolved to specific
| functions based on the parameter types (aka function overloading) and we have
| figured out how types need to be substituted for things to work out.
| Speaking of types: Types no longer contain user-given names. Instead, we have
| inlined type definitions so that types are completely structural. For example,
| rather than (LinkedList Int), the Egg uses this type:
|
| (| empty: (&) more: (& item: (Int) rest: (^2)))

import ../plum.mar
import builder.mar
import builtins.mar
import dag.mar
import format.mar
| import run.mar
import type.mar
import op_type.mar

| All EggExprs are allocated and managed by the DAG in dag.mar. This allows
| using EggIds everywhere instead of having to use references.

struct Egg { funs: Map[String, EggFun] }
struct EggFun { body: EggBody }
struct EggBody { params: Slice[EggId], children: Slice[EggId], returns: EggId }
enum EggExpr {
  param: EggType,

  | Constructing values.
  type: EggType,
  int: Int,
  string: String,
  struct_: Map[String, EggId],
  enum_: EggEnum,
  lambda: EggBody,

  | Working with values.
  member: EggMember,
  switch_: EggSwitch,
  call_fun: EggCallFun,
  call_lambda: EggCallLambda,
  call_builtin: EggCallBuiltin,

  cast: EggCast,
}
struct EggEnum { type: EggType, variant: String, payload: EggId }
struct EggMember { of: EggId, name: String }
struct EggSwitch { condition: EggId, type: EggType, cases: Map[String, EggBody] }
struct EggCallFun {
  fun_: String, substitutions: Substitutions,
  args: Slice[EggId], return_type: EggType,
}
struct EggCallLambda { lambda: EggId, args: Slice[EggId] }
struct EggCallBuiltin {
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[EggId]
}
struct EggCast { what: EggId, type: EggType }


fun signature(module: Module, name: String, params: Slice[EggType]): String {
  var b = string_builder().&
  b."{module}.{name}"
  for param in params do b." {param}"
  b.to_string()
}

fun return_type(fun_: EggFun): EggType { fun_.body.returns.type() }
