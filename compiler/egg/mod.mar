| Expression-Guided Graph  
|
| A representation of code that is simplified and more suitable for
| type-checking.
|
| Types:
|   Names of types are resolved. Usages of type definitions (which are more like
|   aliases anyway) have been resolved so that types have no names anymore â€“
|   they are completely structural.
|   For example, rather than (LinkedList Int), this stage uses
|   (| empty more: (& item: Int rest: ^2)) as the type.
|
| Functions:
|   Names of locals and types are resolved. Every expression in the function has
|   a type. Function calls are resolved to specific functions, so overloading
|   resolution has already happened. Nested expressions in function bodies have
|   been flattened to a series of small expressions.

import ../plum.mar
import builder.mar
import format.mar
import type.mar

struct Egg { funs: Map[String, EggFun] }

struct EggFun { module: Module, name: StringAndSrc, body: EggBody }
struct EggBody {
  params: Slice[EggId], children: Slice[EggId], returns: EggExpr
}

struct EggExpr { op: EggOp, type: EggType, src: Src }
enum EggOp {
  param,
  id: EggId,
  byte: Byte,
  int: Int,
  array: Slice[EggExpr],
  struct_: Map[String, EggExpr],
  member: EggMember,
  enum_: EggEnum,
  switch_: EggSwitch,
  lambda: &EggBody,
  call: EggCall,
  loop_: EggLoop,
  continue_: Slice[EggExpr],
  cast: &EggExpr,
  type: EggType,
}
struct EggMember { of: &EggExpr, name: String }
struct EggSwitch { condition: &EggExpr, cases: Map[String, EggBody] }
struct EggEnum { name: String, value: &EggExpr }
struct EggLoop { name: String, body: &EggBody, args: Slice[EggExpr] }
struct EggCall { callee: EggCallee, args: Slice[EggExpr] }
enum EggCallee {
  lambda: &EggExpr, fun_: EggCalledFun, builtin: EggCalledBuiltin
}
struct EggCalledFun { signature: String, substitutions: Substitutions }
struct EggCalledBuiltin { builtin: EggBuiltin, substitutions: Substitutions }

enum EggBuiltin {
  | byte operations
  lower_byte, byte_to_int,
  | int operations
  add_ints, sub_ints, mul_ints, div_ints, mod_ints, and_ints, or_ints, xor_ints,
  compare_ints,
  | box operations
  box, unbox,
  | array operations
  generate_array, array_get, array_set, array_slice, array_len,
  | lambda operations
  call,
  | error stuff
  crash,
  | type operations
  type_of, type_info,
  | dynamic typing operations
  static_to_dynamic, dynamic_to_static,
}

var egg_builtins =
  list(
    EggBuiltin.lower_byte, EggBuiltin.byte_to_int,
    EggBuiltin.add_ints, EggBuiltin.sub_ints, EggBuiltin.mul_ints,
    EggBuiltin.div_ints, EggBuiltin.mod_ints, EggBuiltin.and_ints,
    EggBuiltin.or_ints, EggBuiltin.xor_ints,
    EggBuiltin.compare_ints,
    EggBuiltin.box, EggBuiltin.unbox,
    EggBuiltin.generate_array, EggBuiltin.array_get, EggBuiltin.array_set,
    EggBuiltin.array_slice, EggBuiltin.array_len,
    EggBuiltin.call,
    EggBuiltin.crash,
    EggBuiltin.type_of, EggBuiltin.type_info,
    EggBuiltin.static_to_dynamic, EggBuiltin.dynamic_to_static,
  ).to_slice()

fun expr(op: EggOp, type: EggType, src: Src): EggExpr {
  EggExpr { op, type, src }
}

| For simplicity, there's a global store of all Egg expressions.

var egg_exprs = list[EggExpr]().&
struct EggId { index: Int }

fun create(expr: EggExpr): EggId {
  var id = EggId { index = egg_exprs.len }
  egg_exprs.push(expr)
  id
}
fun get(id: EggId): EggExpr { egg_exprs.get(id.index) }
fun hash[H](hasher: H, id: EggId) { hasher.hash(id.index) }
fun ==(a: EggId, b: EggId): Bool { a.index == b.index }

fun param_types(fun_: EggFun): Slice[EggType] {
  var types = list[EggType]()
  for param in fun_.body.params do types.&.push(fun_.dag.type_of(param))
  types.to_slice()
}
fun return_type(fun_: EggFun): EggType { fun_.body.returns.type }
