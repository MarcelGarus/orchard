| Expression-Guided Graph  
|
| A representation of code where we have used names to establish the connections
| between types, expressions, and functions.
| 
| Every Egg expression has a type. Function calls are resolved to specific
| functions based on the parameter types (aka function overloading) and we have
| figured out how types need to be substituted for things to work out.
| Speaking of types: Types no longer contain user-given names. Instead, we have
| inlined type definitions so that types are completely structural. For example,
| rather than (LinkedList Int), the Egg uses this type:
|
| (| empty: (&) more: (& item: (Int) rest: (^2)))

import ../plum.mar
import builder.mar
import builtins.mar
import dag.mar
import equivalent.mar
import format.mar
| import run.mar
import type.mar

| All EggExprs are allocated and managed by the DAG in dag.mar. This allows
| using EggIds everywhere instead of having to use references.

struct Egg { entry_point: String, funs: Map[String, EggFun] }
struct EggFun { body: EggBody }
struct EggBody { params: Slice[EggId], children: Slice[EggId], returns: EggId }
enum EggExpr {
  param: EggType,

  | Constructing values.
  type: EggType,
  int: Int,
  string: String,
  struct_: Map[String, EggId],
  enum_: EggEnum,
  lambda: EggBody,

  | Working with values.
  member: EggMember,
  switch_: EggSwitch,
  call_fun: EggCallFun,
  call_lambda: EggCallLambda,
  call_builtin: EggCallBuiltin,

  | Casting.
  cast: EggCast,

  | Note: All of the expression above are generated when converting the Toast to
  | the Egg. The expression below are only produced using optimizations.
  
  | Byte stuff.
  byte: Byte,
  lower_byte: EggId,
  byte_to_int: EggId,

  | Int stuff.
  add: Tuple2[EggId, EggId],
  subtract: Tuple2[EggId, EggId],
  multiply: Tuple2[EggId, EggId],
  divide: Tuple2[EggId, EggId],
  modulo: Tuple2[EggId, EggId],
  and_: Tuple2[EggId, EggId],
  or_: Tuple2[EggId, EggId],
  xor: Tuple2[EggId, EggId],
  compare: Tuple2[EggId, EggId],
  | unchecked_divide: Tuple2[EggId, EggId],
  | unchecked_modulo: Tuple2[EggId, EggId],

  | Box stuff.
  box: EggId,
  unbox: EggId,

  | Array stuff.
  array: EggArray,
  generate_array: EggGenerateArray,
  array_get: EggArrayGet,
  array_set: EggArraySet,
  array_slice: EggArraySlice,
  array_len: EggId,

  | Type-stuff.
  type_info: EggId,
  static_to_dynamic: EggId,
  dynamic_to_static: EggDynamicToStatic,

  | Crashes the VM.
  crash: EggCrash,

  | Marks code as unreachable. Code that definitely reaches this expression can
  | be optimized away. Note that this is different from crashing.
  unreachable: EggType,

  recursive: EggRecursive,
  recurse: EggRecurse,
}
struct EggEnum { type: EggType, variant: String, payload: EggId }
struct EggMember { of: EggId, name: String }
struct EggSwitch { condition: EggId, type: EggType, cases: Map[String, EggBody] }
struct EggCallFun {
  fun_: String, substitutions: Substitutions,
  args: Slice[EggId], return_type: EggType,
}
struct EggCallLambda { lambda: EggId, args: Slice[EggId] }
struct EggCallBuiltin {
  builtin: EggBuiltin, substitutions: Substitutions, args: Slice[EggId]
}
struct EggCast { what: EggId, type: EggType }
struct EggArray { items: Slice[EggId], item_type: EggType }
struct EggGenerateArray { length: EggId, generator: EggBody }
struct EggArrayGet { array: EggId, index: EggId }
struct EggArraySet { array: EggId, index: EggId, item: EggId }
struct EggArraySlice { array: EggId, start: EggId, end: EggId }
struct EggDynamicToStatic { dynamic: EggId, static: EggType }
struct EggCrash { message: EggId, type: EggType }
struct EggRecursive { initial: Slice[EggId], body: EggBody }
struct EggRecurse { next: Slice[EggId], type: EggType }


fun signature(module: Module, name: String, params: Slice[EggType]): String {
  var b = string_builder().&
  b."{module}.{name}"
  for param in params do b." {param}"
  b.to_string()
}

fun return_type(fun_: EggFun): EggType { fun_.body.returns.type() }

fun verify(fun_: EggFun) {
  if fun_.body.captured().is_not_empty() then
    panic("function not self contained. it captures {fun_.body.captured().debug()}")
}
