import mod.mar

fun compile_init_array_fun(item_type: EggType, pesto: &Pesto): String {
  var signature = "initialize (Array {item_type})"
  if pesto.funs.contains(signature) then return signature
  pesto.funs.&.put(signature, uninitialized[PestoFun]().*)

  var dag = dag[PestoExpr]()
  var builder = body_builder(dag.&, PestoType.struct_(map(
    "buffer" -> PestoType.ptr,
    "cursor" -> PestoType.int,
    "length" -> PestoType.int,
    "generator" -> pesto_lambda_type,
  ))).&
  var args       = builder.param
  var buffer = builder.member(args, "buffer")
  var cursor     = builder.member(args, "cursor")
  var length        = builder.member(args, "length")
  var generator  = builder.member(args, "generator")

  builder.switch_(builder.compare_ints(cursor, length), map(
    "less" -> {
      var builder = body_builder(dag.&, pesto_nothing.type).&
      var closure_ptr = builder.member(generator, "closure")
      builder.increment_reference_count(closure_ptr)
      var item = builder.call_indirect(
        builder.member(generator, "body"),
        builder.struct_(map("0" -> cursor, "1" -> closure_ptr)),
        item_type.to_pesto(),
      )
      builder.store_buffer_item(buffer, cursor, item)
      builder.call(
        signature,
        builder.struct_(map(
          "buffer" -> buffer,
          "cursor" -> builder.add_ints(cursor, builder.int(1)),
          "length" -> length,
          "generator" -> generator,
        )),
        pesto_nothing.type,
      )
      builder.finish_with_nothing()
    },
    "equal" ->
      body_builder(dag.&, pesto_nothing.type).finish_with_nothing(),
    "greater" ->
      body_builder(dag.&, pesto_nothing.type).finish_with_nothing(),
  ))

  var body = builder.finish_with_nothing()
  var fun_ = PestoFun { dag, body }

  pesto.funs.&.put(signature, fun_)
  signature
}

fun compile_array_set(item_type: EggType, pesto: &Pesto): String {
  var signature = "set (Array {item_type})"
  if pesto.funs.contains(signature) then return signature
  pesto.funs.&.put(signature, uninitialized[PestoFun]().*)

  var dag = dag[PestoExpr]()
  var builder = body_builder(dag.&, PestoType.struct_(map(
    "array" -> pesto_array_type,
    "index" -> PestoType.int,
    "item" -> item_type.to_pesto(),
  ))).&
  var args = builder.param
  var array = builder.member(args, "array")
  var index = builder.member(args, "index")
  var item = builder.member(args, "item")
  var buffer = builder.member(array, "buffer")
  var start = builder.member(array, "start")
  var length = builder.member(array, "length")

  | Check that the index is within bounds.
  builder.switch_(builder.compare_ints(index, builder.int(0)), map(
    "less" ->
      body_builder(dag.&, pesto_nothing.type)
        .finish_with_crash("Index out of bounds."),
    "equal" -> body_builder(dag.&, pesto_nothing.type).finish_with_nothing(),
    "greater" ->
      body_builder(dag.&, pesto_nothing.type).finish_with_nothing(),
  ))
  builder.switch_(builder.compare_ints(index, length), map(
    "less" -> body_builder(dag.&, pesto_nothing.type).finish_with_nothing(),
    "equal" ->
      body_builder(dag.&, pesto_nothing.type)
        .finish_with_crash("Index out of bounds."),
    "greater" ->
      body_builder(dag.&, pesto_nothing.type)
        .finish_with_crash("Index out of bounds."),
  ))

  | If the buffer's reference count is 1, we have exclusive ownership and can
  | mutate the buffer in place. Otherwise, we copy the part of the buffer that
  | this array points to, and then we set the item in that copy.
  var refcount = builder.get_reference_count(buffer)
  var array_with_refcount_1 =
    builder.switch_(builder.compare_ints(refcount, builder.int(1)), map(
      | TODO: change this to crash/diverge so that the switch branches are
      | compatible
      "less" -> | can't happen
        body_builder(dag.&, pesto_nothing.type).finish_with_crash(""),
      "equal" ->
        body_builder(dag.&, pesto_nothing.type).finish(array),
      "greater" -> {
        var builder = body_builder(dag.&, pesto_nothing.type).&
        var buffer_copy = builder.new_buffer(item_type.to_pesto(), length)
        builder.call(
          compile_copy_buffer_fun(item_type, pesto),
          builder.struct_(map(
            "from_buffer" -> buffer,
            "from_cursor" -> start,
            "to_buffer" -> buffer_copy,
            "to_cursor" -> builder.int(0),
            "length" -> length,
          )),
          pesto_nothing.type,
        )
        builder.drop_buffer(buffer, item_type, pesto)
        var array = builder.struct_(map(
          "buffer" -> buffer_copy,
          "start" -> builder.int(0),
          "length" -> length,
        ))
        builder.finish(array)
      },
    ))

  var buffer = builder.member(array_with_refcount_1, "buffer")
  var start = builder.member(array_with_refcount_1, "start")
  var offset = builder.add_ints(start, index)
  var previous = builder.load_buffer_item(buffer, item_type.to_pesto(), offset)
  builder.drop(previous, item_type, pesto)
  builder.store_buffer_item(buffer, offset, item)

  var body = builder.finish(array_with_refcount_1)
  var fun_ = PestoFun { dag, body }

  pesto.funs.&.put(signature, fun_)
  signature
}
fun compile_copy_buffer_fun(item_type: EggType, pesto: &Pesto): String {
  var signature = "copy between buffers of {item_type}"
  if pesto.funs.contains(signature) then return signature
  pesto.funs.&.put(signature, uninitialized[PestoFun]().*)

  var dag = dag[PestoExpr]()
  var builder = body_builder(dag.&, PestoType.struct_(map(
    "from_buffer" -> PestoType.ptr,
    "from_cursor" -> PestoType.int,
    "to_buffer" -> PestoType.ptr,
    "to_cursor" -> PestoType.int,
    "length" -> PestoType.int,
  ))).&
  var args        = builder.param
  var from_buffer = builder.member(args, "from_buffer")
  var from_cursor = builder.member(args, "from_cursor")
  var to_buffer   = builder.member(args, "to_buffer")
  var to_cursor   = builder.member(args, "to_cursor")
  var length         = builder.member(args, "length")

  builder.switch_(builder.compare_ints(length, builder.int(0)), map(
    "less" -> | can't happen
      body_builder(dag.&, pesto_nothing.type).finish_with_nothing(),
    "equal" ->
      body_builder(dag.&, pesto_nothing.type).finish_with_nothing(),
    "greater" -> {
      var builder = body_builder(dag.&, pesto_nothing.type).&
      var item = builder.load_buffer_item(
        from_buffer, item_type.to_pesto(), from_cursor
      )
      builder.dup(item, item_type, pesto)
      builder.store_buffer_item(to_buffer, to_cursor, item)
      builder.call(
        signature,
        builder.struct_(map(
          "from_buffer" -> from_buffer,
          "from_cursor" -> builder.add_ints(from_cursor, builder.int(1)),
          "to_buffer" -> to_buffer,
          "to_cursor" -> builder.add_ints(to_cursor, builder.int(1)),
          "length" -> builder.sub_ints(length, builder.int(1)),
        )),
        pesto_nothing.type,
      )
      builder.finish_with_nothing()
    },
  ))

  var body = builder.finish_with_nothing()
  var fun_ = PestoFun { dag, body }

  pesto.funs.&.put(signature, fun_)
  signature
}
