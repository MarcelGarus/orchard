| Converting Yogurt to Pudding  

import plum.mar

fun to_pudding(signature: YogurtSignature): PuddingSignature {
  pudding_signature(signature.str)
}

fun to_pudding(value: YogurtValue, body_builder: &PuddingBodyBuilder): PuddingExpr {
  switch value.kind
  case int(int) PuddingOp.int(int) $ type_int
  case string(string) PuddingOp.string(string) $ type_string
  case struct_(struct_) {
    var fields = map[String, PuddingId]()
    for field in struct_ do {
      var id = body_builder.push(field.value.to_pudding(body_builder))
      fields.&.put(field.key, id)
    }
    PuddingOp.struct_(fields) $ value.type
  }
  case variant(variant) {
    var payloads = list[PuddingId]()
    for payload in variant.payloads do {
      var id = body_builder.push(payload.to_pudding(body_builder))
      payloads.&.push(id)
    }
    PuddingOp.variant(PuddingVariant {
      symbol = variant.symbol, payloads = payloads.to_slice()
    }) $ value.type
  }
  case lambda(lambda) {
    var captures = list[PuddingId]()
    for capture in lambda.captures do {
      var id = body_builder.push(capture.to_pudding(body_builder))
      captures.&.push(id)
    }
    PuddingOp.lambda(PuddingLambda {
      function = lambda.function.to_pudding(),
      captures = captures.to_slice()
    }) $ value.type
  }
  case type(type) PuddingOp.type(type) $ type_type
}

fun to_pudding(
  expr: YogurtExpr,
  fun_: YogurtFun,
  fun_builder: &PuddingFunBuilder, body_builder: &PuddingBodyBuilder,
  yogurt_id_to_pudding_id: &Map[YogurtId, PuddingId],
  yogurt: Yogurt,
): PuddingExpr {
  switch expr.op
  case param unreachable()
  case uninitialized unreachable()
  case comptime(value) value.to_pudding(body_builder)
  case struct_(struct_) {
    var fields = map[String, PuddingId]()
    for field in struct_ do {
      var id = yogurt_id_to_pudding_id.get(field.value)
      body_builder.push(PuddingOp.dup(id) $ PlumType.never)
      fields.&.put(field.key, id)
    }
    PuddingOp.struct_(fields) $ expr.type
  }
  case member(member) {
    var of = yogurt_id_to_pudding_id.get(member.of)
    body_builder.push(PuddingOp.dup(of) $ PlumType.never)
    PuddingOp.member(PuddingMember { of, name = member.name }) $ expr.type
  }
  case variant(variant) {
    var payloads = list[PuddingId]()
    for payload in variant.payloads do {
      var id = yogurt_id_to_pudding_id.get(payload)
      body_builder.push(PuddingOp.dup(id) $ PlumType.never)
      payloads.&.push(id)
    }
    PuddingOp.variant(PuddingVariant {
      symbol = variant.symbol, payloads = payloads.to_slice()
    }) $ expr.type
  }
  case switch_(switch_) {
    var condition = yogurt_id_to_pudding_id.get(switch_.condition)
    body_builder.push(PuddingOp.dup(condition) $ PlumType.never)
    var cases = map[String, PuddingBody]()
    for case_ in switch_.cases do
      cases.&.put(case_.key, case_.value.to_pudding(
        fun_, fun_builder, yogurt_id_to_pudding_id, yogurt
      ))
    PuddingOp.switch_(PuddingSwitch { condition, cases }) $ expr.type
  }
  case lambda(lambda) {
    var captures = list[PuddingId]()
    for capture in lambda.captures do {
      var id = yogurt_id_to_pudding_id.get(capture)
      body_builder.push(PuddingOp.dup(id) $ PlumType.never)
      captures.&.push(id)
    }
    PuddingOp.lambda(PuddingLambda {
      function = PuddingSignature { string = lambda.function.str },
      captures = captures.to_slice()
    }) $ expr.type
  }
  case lambda_call(call) {
    var lambda = yogurt_id_to_pudding_id.get(call.lambda)
    body_builder.push(PuddingOp.dup(lambda) $ PlumType.never)
    var args = list[PuddingId]()
    for arg in call.args do {
      var id = yogurt_id_to_pudding_id.get(arg)
      body_builder.push(PuddingOp.dup(id) $ PlumType.never)
      args.&.push(id)
    }
    PuddingOp.lambda_call(PuddingLambdaCall {
      lambda, args = args.to_slice()
    }) $ expr.type
  }
  case call(call) {
    var args = list[PuddingId]()
    for arg in call.args do {
      var id = yogurt_id_to_pudding_id.get(arg)
      body_builder.push(PuddingOp.dup(id) $ PlumType.never)
      args.&.push(id)
    }
    PuddingOp.call(PuddingCall {
      function = PuddingSignature { string = call.function.str },
      args = args.to_slice(),
    }) $ expr.type
  }
  case instruction(instruction) {
    var args = list[PuddingId]()
    for arg in instruction.args do {
      var id = yogurt_id_to_pudding_id.get(arg)
      body_builder.push(PuddingOp.dup(id) $ PlumType.never)
      args.&.push(id)
    }
    PuddingOp.instruction(PuddingInstruction {
      instruction = instruction.instruction, args = args.to_slice()
    }) $ expr.type
  }
}

fun to_pudding(
  body: YogurtBody,
  fun_: YogurtFun, fun_builder: &PuddingFunBuilder,
  yogurt_id_to_pudding_id: &Map[YogurtId, PuddingId],
  yogurt: Yogurt,
): PuddingBody {
  var body_builder = fun_builder.&.body_builder()
  for param in body.params do {
    var id = body_builder.&.push_param(fun_.get(param).type)
    yogurt_id_to_pudding_id.&.put(param, id)
  }
  for id in body.exprs do {
    var expr = body_builder.&.push(fun_.get(id).to_pudding(
      fun_, fun_builder, body_builder.&, yogurt_id_to_pudding_id, yogurt
    ))
    yogurt_id_to_pudding_id.&.put(id, expr)
  }
  var returns = yogurt_id_to_pudding_id.get(body.returns)

  body_builder.&.push(PuddingOp.dup(returns) $ PlumType.never)
  for param in body.params do
    body_builder.&.push(PuddingOp.drop(yogurt_id_to_pudding_id.get(param)) $ PlumType.never)
  for id in body.exprs do
    body_builder.&.push(PuddingOp.drop(yogurt_id_to_pudding_id.get(id)) $ PlumType.never)

  body_builder.returns(returns)
}

fun to_pudding(
  fun_: YogurtFun, yogurt: Yogurt, funs: &Map[PuddingSignature, PuddingFun]
): PuddingFun {
  var fun_builder = pudding_fun_builder()
  var yogurt_id_to_pudding_id = map[YogurtId, PuddingId]()

  var captures =
    switch fun_.captures
    case none none[Slice[PuddingId]]()
    case some(captures) {
      var mapped = list[PuddingId]()
      for capture in captures do {
        var id = fun_builder.&.create(PuddingOp.param $ fun_.get(capture).type)
        yogurt_id_to_pudding_id.&.put(capture, id)
        mapped.&.push(id)
      }
      some(mapped.to_slice())
    }

  var body = fun_.body.to_pudding(
    fun_, fun_builder.&, yogurt_id_to_pudding_id.&, yogurt
  )
  fun_builder.finish(captures, body)
}

fun to_pudding(yogurt: Yogurt): Pudding {
  var funs = map[PuddingSignature, PuddingFun]()
  for fun_ in yogurt.funs do
    funs.&.put(
      PuddingSignature { string = fun_.key.str },
      fun_.value.to_pudding(yogurt, funs.&),
    )
  Pudding { funs }
}
