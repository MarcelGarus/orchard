import ../plum.mar

fun to_taco(egg: Egg, entry_point: String): Result[Taco, Error] {
  var funs = map[String, TacoBody]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.compile())
  ok[Taco, Error](Taco {
    funs,
    entry_point = TacoCalledFun {
      signature = entry_point, substitutions = no_substitutions
    },
  })
}

fun compile(fun_: EggFun): TacoBody {
  var mapping = map[Id, TacoExpr]()

  var params = list[Hole]()
  for arg in fun_.body.params do {
    var hole = hole(fun_.dag.type_of(arg))
    params.&.push(hole)
    mapping.&.put(arg, taco_hole(hole))
  }
  var params = params.to_slice()

  var expr = fun_.body.compile(mapping.&, fun_.dag)

  TacoBody { params, expr }
}

fun compile(
  body: EggBody, mapping: &Map[Id, TacoExpr], dag: Dag[EggExpr]
): TacoExpr {
  var exprs = list[TacoExpr]()
  for id in body.children do {
    var expr = dag.get(id).compile(mapping, dag)
    exprs.&.push(expr)
    mapping.put(id, expr)
  }
  var result = body.returns.compile(mapping, dag)
  for expr in exprs do result = both(expr, result)
  result
}

fun compile(
  expr: EggExpr, mapping: &Map[Id, TacoExpr], dag: Dag[EggExpr]
): TacoExpr {
  | eprintln("Compiling {expr.op.debug()}")
  var type = expr.type
  switch expr.op
  case param unreachable()
  case id(id) mapping.get(id)
  case type(type) taco_type(type)
  case int(int) taco_int(int)
  case string(string) taco_string(string)
  case struct_(struct_) {
    var values = list[TacoExpr]()
    for field in struct_ do values.&.push(field.b.compile(mapping, dag))
    var result = struct_({
      var fields = map[String, TacoExpr]()
      for field in zip(struct_.iter(), values.iter()) do
        fields.&.put(field.a.a, field.b)
      fields
    })
    for value in values.to_slice().rev_iter() do
      result = both(value, result)
    result
  }
  case enum_(enum_) enum_(type, enum_.name, enum_.value.compile(mapping, dag))
  case member(member) member.of.compile(mapping, dag).member(member.name)
  case lambda(lambda) {
    var holes = list[Hole]()
    for param in lambda.params do {
      var hole = hole(dag.type_of(param))
      mapping.&.put(param, taco_hole(hole))
      holes.&.push(hole)
    }
    lambda(body(holes.to_slice(), lambda.compile(mapping, dag)))
  }
  case switch_(switch_) {
    var cases = map[String, TacoBody]()
    for case_ in switch_.cases do {
      var binding = case_.value.params.get(0)
      var hole = hole(dag.type_of(binding))
      mapping.&.put(binding, taco_hole(hole))
      cases.&.put(case_.key, body(hole, case_.value.compile(mapping, dag)))
    }
    switch_(switch_.condition.compile(mapping, dag), type, cases)
  }
  case call(call) {
    var args = list[TacoExpr]()
    for arg in call.args do args.&.push(arg.compile(mapping, dag))
    var args = args.to_slice()

    switch call.callee
    case fun_(fun_)
      TacoCalledFun {
          signature = fun_.signature, substitutions = fun_.substitutions
      }.call(args, type)
    case lambda(lambda) lambda.compile(mapping, dag).call(args)
    case builtin(builtin) {
      switch builtin.builtin
      case lower_byte lower_byte(args.get(0))
      case byte_to_int byte_to_int(args.get(0))
      case add_ints add(args.get(0), args.get(1))
      case sub_ints subtract(args.get(0), args.get(1))
      case mul_ints multiply(args.get(0), args.get(1))
      case div_ints divide(args.get(0), args.get(1))
      case mod_ints modulo(args.get(0), args.get(1))
      case and_ints and_(args.get(0), args.get(1))
      case or_ints or_(args.get(0), args.get(1))
      case xor_ints xor(args.get(0), args.get(1))
      case compare_ints compare(args.get(0), args.get(1))
      case box box(args.get(0))
      case unbox unbox(args.get(0))
      case generate_array {
        var index = hole(type_int)
        generate_array(
          args.get(0),
          body(index, args.get(1).call(list(taco_hole(index)).to_slice())),
        )
      }
      case array_get array_get(args.get(0), args.get(1))
      case array_set array_set(args.get(0), args.get(1), args.get(2))
      case array_slice
        array_slice(
          args.get(0),
          args.get(1).member("start"),
          args.get(1).member("end"),
        )
      case array_len array_len(args.get(0))
      case call args.get(0).call(empty_slice[TacoExpr]())
      case crash taco_crash(type)  | TODO: keep message
      case type_of taco_type(args.get(0).type)
      case type_info type_info(args.get(0))
      case static_to_dynamic static_to_dynamic(args.get(0))
      case dynamic_to_static dynamic_to_static(args.get(1), type)
    }
  }
  case cast(inner) inner.compile(mapping, dag).cast(type)
}
