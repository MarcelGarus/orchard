import ../plum.mar

fun to_taco(egg: Egg, entry_point: String): Result[Taco, Error] {
  var funs = map[String, TacoFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.compile())
  ok[Taco, Error](Taco {
    funs,
    entry_point = TacoCalledFun {
      signature = entry_point, substitutions = no_substitutions
    },
  })
}

fun compile(fun_: EggFun): TacoFun {
  var mapping = map[Id, TacoExpr]()

  var params = list[Hole]()
  for arg in fun_.body.params do {
    var hole = hole(fun_.dag.type_of(arg))
    params.&.push(hole)
    mapping.&.put(arg, taco_hole(hole))
  }
  var params = params.to_slice()

  var body = fun_.body.compile(mapping.&, fun_.dag)

  TacoFun { params, body }
}

fun compile(
  body: EggBody, mapping: &Map[Id, TacoExpr], dag: Dag[EggExpr]
): TacoExpr {
  var exprs = list[TacoExpr]()
  for id in body.children do {
    var expr = dag.get(id).compile(mapping, dag)
    exprs.&.push(expr)
    mapping.put(id, expr)
  }
  var returns = body.returns.compile(mapping, dag)
  exprs.&.push(returns)
  body(exprs.to_slice())
}

fun compile(
  expr: EggExpr, mapping: &Map[Id, TacoExpr], dag: Dag[EggExpr]
): TacoExpr {
  | eprintln("Compiling {expr.op.debug()}")
  var type = expr.type
  switch expr.op
  case param unreachable()
  case id(id) mapping.get(id)
  case type(type) taco_type(type)
  case int(int) taco_int(int)
  case string(string) taco_string(string)
  case struct_(struct_) {
    var fields = map[String, TacoExpr]()
    for field in struct_ do
      fields.&.put(field.key, field.value.compile(mapping, dag))
    struct_(fields)
  }
  case enum_(enum_) enum_(type, enum_.name, enum_.value.compile(mapping, dag))
  case member(member) member.of.compile(mapping, dag).member(member.name)
  case lambda(lambda) {
    var holes = list[Hole]()
    for param in lambda.params do {
      var hole = hole(dag.type_of(param))
      mapping.&.put(param, taco_hole(hole))
      holes.&.push(hole)
    }
    lambda(holes.to_slice(), lambda.compile(mapping, dag))
  }
  case switch_(switch_) {
    var cases = map[String, Tuple2[Hole, TacoExpr]]()
    for case_ in switch_.cases do {
      var binding = case_.value.params.get(0)
      var hole = hole(dag.type_of(binding))
      mapping.&.put(binding, taco_hole(hole))
      cases.&.put(case_.key, tuple(hole, case_.value.compile(mapping, dag)))
    }
    switch_(switch_.condition.compile(mapping, dag), type, cases)
  }
  case call(call) {
    var args = list[TacoExpr]()
    for arg in call.args do args.&.push(arg.compile(mapping, dag))
    var args = args.to_slice()

    switch call.callee
    case fun_(fun_)
      TacoCalledFun {
          signature = fun_.signature, substitutions = fun_.substitutions
      }.call(args, type)
    case builtin(builtin) {
      switch builtin.builtin
      case lower_byte lower_byte(args.get(0))
      case byte_to_int byte_to_int(args.get(0))
      case add_ints add(args.get(0), args.get(1))
      case sub_ints subtract(args.get(0), args.get(1))
      case mul_ints multiply(args.get(0), args.get(1))
      case div_ints divide(args.get(0), args.get(1))
      case mod_ints modulo(args.get(0), args.get(1))
      case and_ints and_(args.get(0), args.get(1))
      case or_ints or_(args.get(0), args.get(1))
      case xor_ints xor(args.get(0), args.get(1))
      case compare_ints compare(args.get(0), args.get(1))
      case box box(args.get(0))
      case unbox unbox(args.get(0))
      case generate_array generate_array(args.get(0), args.get(1))
      case array_get array_get(args.get(0), args.get(1))
      case array_set array_set(args.get(0), args.get(1), args.get(2))
      case array_slice
        array_slice(
          args.get(0),
          args.get(1).member("start"),
          args.get(1).member("end"),
        )
      case array_len array_len(args.get(0))
      case call args.get(0).call(empty_slice[TacoExpr]())
      case crash taco_crash(type)
      case type_of taco_type(args.get(0).type)
      case type_info type_info(args.get(0))
      case static_to_dynamic static_to_dynamic(args.get(0))
      case dynamic_to_static dynamic_to_static(args.get(1), type)
    }
    case lambda(lambda) lambda.compile(mapping, dag).call(args)
  }
  case cast(inner) inner.compile(mapping, dag).cast(type)
}
