import mod.mar

fun static_to_dynamic(
  value: YogurtExpr, context: &YogurtGlobalContext
): YogurtExpr {
  compile_static_to_dynamic_fun(value.type, context)
    .call(list(value).to_slice(), type_dynamic)
}
fun compile_static_to_dynamic_fun(
  type: EggType, context: &YogurtGlobalContext
): String {
  var compilation = context.start_compiling("{type} to dynamic")
    or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var param = body.param(type)
  var returns = compile_static_to_dynamic_fun_body(type, body, param, context)

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(returns) })
}
fun compile_static_to_dynamic_fun_body(
  type: EggType, dag: &Dag[YogurtExpr], value: YogurtExpr,
  context: &YogurtGlobalContext,
): Id {
  switch type.kind()
  case variable panic("type var in compile to dynamic")
  case byte enum_(type_dynamic, "byte", value)
  case int enum_(type_dynamic, "int", value)
  case never yogurt_unreachable(type_dynamic)
  case type enum_(type_dynamic, "type", yogurt_nothing)
  case box enum_(type_dynamic, "box", unbox(value).static_to_dynamic(context))
  case array(item)
    enum_(type_dynamic, "array", {
      generate_array(
        value.array_len(),
        lambda(
          type_lambda(list(type_int).to_slice(), type_dynamic),
          compile_array_items_to_dynamic_fun(item, context),
          box(value),
        ),
      )
    })
  case struct_(field_types)
    enum_(type_dynamic, "struct", {
      var dynamic_fields = list[YogurtExpr]()
      for field in field_types do {
        var name = field.key
        var field_type = field.value
        dynamic_fields.&.push(struct_(map(
          "name" -> yogurt_string(name),
          "value" -> value.member(name).static_to_dynamic(context),
        )))
      }
      array(type_dynamic_fields, dynamic_fields.to_slice())
    })
  case enum_(variant_types)
    enum_(type_dynamic, "enum", {
      value.switch_(type_dynamic_variant, {
        var cases = map[String, YogurtBody]()
        for variant in variant_types do {
          var name = variant.key
          var variant_type = variant.value

          var body = body_builder(body.dag).&
          var payload_value = body.param(variant_type)
          var name_and_value = yogurt_struct_(map(
            "name" -> yogurt_string(name),
            "value" -> payload_value.static_to_dynamic(context),
          ))
          cases.&.put(name, body.finish(name_and_value))
        }
        cases
      })
    })
  case lambda
    enum_(type_dynamic, "lambda", {
      lambda(
        type_lambda(list(type_array(type_dynamic)).to_slice(), type_dynamic),
        compile_dynamic_lambda_wrapper_fun(type, context),
        box(value),
      )
    })
}
fun compile_array_items_to_dynamic_fun(
  item_type: EggType, context: &YogurtGlobalContext
): String {
  var compilation =
    context.start_compiling("converting array item of {item_type} to dynamic")
      or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&
  var index = body.param(type_int)
  var closure = body.param(type_box(type_array(item_type)))

  var dynamic = unbox(closure).array_get(index).static_to_dynamic(context)

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(converted) })
}
| dynamic wrapper for a static lambda
fun compile_dynamic_lambda_wrapper_fun(
  type: EggType, context: &YogurtGlobalContext
): String {
  var compilation =
    context.start_compiling("dynamic wrapper for a static lambda of {type}")
      or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&
  var args = body.param(type_array(type_dynamic))
  var closure = body.param(type_box(type))

  var lambda_type = type.kind().lambda.unwrap()

  | Make sure the number of arguments is correct.
  compare_ints(args.array_len(), yogurt_int(lambda_type.args.len)).switch_(
    type_nothing,
    map(
      "less" -> dag.body_accepting_nothing(
        yogurt_crash("Wrong number of arguments.", type_nothing)
      ),
      "greater" -> dag.body_accepting_nothing(
        yogurt_crash("Wrong number of arguments.", type_nothing)
      ),
      "equal" -> dag.body_accepting_nothing(yogurt_nothing),
    )
  )

  | Convert the arguments into static ones.
  var static_args = list[YogurtExpr]()
  for arg in lambda_type.args.iter().enumerate() do
    static_args.&.push(
      args.array_get(yogurt_int(arg.index)).dynamic_to_static(arg.item, context)
    )
  var args = static_args.to_slice()

  var converted = closure.unbox().call(args).static_to_dynamic(context)

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(converted) })
}

fun dynamic_to_static(
  value: YogurtExpr, type: EggType, context: &YogurtGlobalContext
): Id {
  compile_dynamic_to_static_fun(type, context)
    .call_fun(list(value).to_slice(), type)
}
fun compile_dynamic_to_static_fun(
  type: EggType, context: &YogurtGlobalContext
): String {
  var compilation =
    context.start_compiling("dynamic to {type}") or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&
  var value = body.param(type_dynamic)

  var result =
    switch type.kind()
    case variable panic("type var in compile to dynamic")
    case byte
      value.expect_variant_or_crash(dag, "byte", {
        var body = dag.body_builder().&
        var byte = body.param(type_byte)
        body.finish(byte)
      })
    case int
      value.expect_variant_or_crash(dag, "int", {
        var body = dag.body_builder().&
        var int = body.param(type_int)
        body.finish(int)
      })
    case never yogurt_crash("tried to build Never from Dynamic", type)
    case type
      | Note: We don't need to re-create the exact type, as you can't inspect
      | non-statically-known types â€“ during runtime, Types don't store
      | anything. So, we just give you _any_ type.
      yogurt_type(type_int)
    case box(inner_type)
      value.expect_variant_or_crash(dag, "box", {
        var body = dag.body_builder().&
        var inner = body.param(type_dynamic)
        body.finish(box(inner.dynamic_to_static(inner_type, context)))
      })
    case array(item_type)
      value.expect_variant_or_crash(dag, "array", {
        var body = dag.body_builder().&
        var payload = body.param(type_array(type_dynamic))
        body.finish(generate_array(
          payload.array_len(),
          lambda(
            type_lambda(list(type_int).to_slice(), item_type),
            compile_dynamic_to_array_items_fun(item_type, context),
            box(payload),
          ),
        ))
      })
    case struct_(field_types)
      value.expect_variant_or_crash(dag, "struct", {
        var body = dag.body_builder().&
        var fields = body.param(type_dynamic_fields)
        body.finish(struct_({
          var fields = map[String, YogurtExpr]()
          for field in field_types do {
            var name = field.key
            var field_type = field.value
            fields.&.put(
              name,
              fields.find_field_in_array(yogurt_string(name), context)
                .dynamic_to_static(field_type, context)
            )
          }
          fields
        }))
      })
    case enum_(variants)
      value.expect_variant_or_crash(dag, "enum", {
        var body = dag.body_builder().&
        var dynamic = body.param(type_dynamic_variant)

        var inner_body = {
          var body = dag.body_builder().&
          var payload = body.param(type_nothing)
          body.finish(yogurt_crash("No enum case matches.", type))
        }
        for variant in variants do {
          var body = dag.body_builder().&
          var payload = body.param(type_nothing)
          inner_body = body.finish(
            compare_strings(
              dynamic.member("name"), yogurt_string(variant.key), context
            ).switch_(type, map(
              "true" -> dag.body_accepting_nothing(
                enum_(
                  type,
                  variant.key,
                  dynamic.member("value").dynamic_to_static(
                    variant.value, context
                  ),
                )
              ),
              "false" -> inner_body,
            ))
          )
        }
        for id in inner_body.children do body.children.&.push(id)
        inner_body.returns
      })
    case lambda
      value.expect_variant_or_crash(dag, "lambda", {
        var body = body_builder(body.dag).&
        var payload = body.param(type_dynamic_lambda)
        body.finish(body.lambda(
          type, compile_static_lambda_wrapper_fun(type, context), box(payload)
        ))
      })

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
fun expect_variant_or_crash(
  value: YogurtExpr, dag: &Dag[YogurtExpr], expected_variant: String,
  body: YogurtBody,
): YogurtExpr {
  value.switch_(body.returns.type, {
    var cases = map[String, YogurtBody]()
    for variant in value.type.kind().enum_.unwrap() do {
      var name = variant.key
      var payload_type = variant.value

      if name == expected_variant then
        body
      else {
        var body = dag.body_builder().&
        var payload = body.param(payload_type)
        var result = yogurt_crash(
          "Expected {expected_variant}, got {name}.", body.returns.type
        )
        cases.&.put(name, body.finish(result))
      }
    }
    cases
  })
}
fun compile_dynamic_to_array_items_fun(
  item_type: EggType, context: &YogurtGlobalContext
): String {
  var compilation =
    context.start_compiling("converting dynamic to array item of {item_type}")
      or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&
  var index = body.param(type_int)
  var closure = body.param(type_box(type_array(type_dynamic)))

  var result = closure.unbox().array_get(index)
    .dynamic_to_static(item_type, context)

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
fun find_field_in_array(
  array: YogurtExpr, name: YogurtExpr, context: &YogurtGlobalContext
): YogurtExpr {
  compile_find_field_in_array_fun(context).call(
    list(array, name, yogurt_int(0)).to_slice(), type_dynamic
  )
}
| Finds the value of a field in an (Array (& name: String value: Dynamic))
fun compile_find_field_in_array_fun(context: &YogurtGlobalContext): String {
  var compilation =
    context.start_compiling(
      "find field in (Array (& name: String value: Dynamic))"
    ) or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = dag.body_builder().&
  var array = body.param(type_dynamic_fields)
  var name  = body.param(type_string)
  var index = body.param(type_int)

  var result = compare_ints(index, array.array_len()).switch_(type_dynamic, map(
    "less" -> {
      var body = dag.body_builder().&
      body.param(type_nothing)
      var field = body.push(array.array_get(index))
      var result = compare_strings(name, field.member("name"), context)
        .switch_(type_dynamic, map(
          "true" -> dag.body_accepting_nothing(field.member("value")),
          "false" -> dag.body_accepting_nothing(
            compile_find_field_in_array_fun(context).call(
              list(array, name, add_ints(index, yogurt_int(1))).to_slice(),
              type_dynamic,
            )
          )
        ))
      body.finish(result)
    },
    "equal" -> dag.body_accepting_nothing(
      yogurt_crash("field not in struct", type_dynamic)
    ),
    "greater" -> dag.body_accepting_nothing(yogurt_unreachable(type_dynamic)),
  ))

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
fun compare_strings(
  a: YogurtExpr, b: YogurtExpr, context: &YogurtGlobalContext
): YogurtExpr {
  compile_compare_strings_fun(context).call(list(a, b).to_slice(), type_bool)
}
fun compile_compare_strings_fun(context: &YogurtGlobalContext): String {
  var compilation =
    context.start_compiling("compare strings") or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&
  var a = body.param(type_string)
  var b = body.param(type_string)

  var a_bytes = a.member("utf8_bytes")
  var b_bytes = b.member("utf8_bytes")

  var result = compare_ints(a_bytes.array_len(), b_bytes.array_len()).switch_(
    type_bool,
    map(
      "less" -> dag.body_accepting_nothing(yogurt_false),
      "equal" -> dag.body_accepting_nothing(
        compile_compare_strings_rec_fun(context).call(
          list(a_bytes, b_bytes, yogurt_int(0)).to_slice(), type_bool
        )
      ),
      "greater" -> dag.body_accepting_nothing(yogurt_false),
    ),
  )

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
fun compile_compare_strings_rec_fun(context: &YogurtGlobalContext): String {
  var compilation =
    context.start_compiling("compare strings rec")
      or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = dag.body_builder().&
  var a = body.param(type_array(type_byte))
  var b = body.param(type_array(type_byte))
  var index = body.param(type_int)
  var body = body.finish(
    compare_ints(index, a.array_len()).switch_(type_bool, map(
      "less" -> dag.body_accepting_nothing(
        compare_ints(
          a.array_get(index).byte_to_int(),
          b.array_get(index).byte_to_int(),
        ).switch_(type_bool, map(
          "less" -> dag.body_accepting_nothing(yogurt_false),
          "equal" -> dag.body_accepting_nothing(
            compile_compare_strings_rec_fun(context).call(
              list(a, b, add_ints(index, yogurt_int(1))).to_slice(), type_bool
            )
          ),
          "greater" -> dag.body_accepting_nothing(yogurt_false),
        )),
      ),
      "equal" -> dag.body_accepting_nothing(yogurt_true),
      "greater" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing)
        body.finish(yogurt_unreachable(type_bool))
      },
    ))
  )

  compilation.done(YogurtFun { dag = dag.*, body })
}

| a static wrapper for a dynamic lambda
fun compile_static_lambda_wrapper_fun(
  type: EggType, context: &YogurtGlobalContext
): String {
  var compilation =
    context.start_compiling("static wrapper for dynamic lambda {type}")
      or(signature) return signature

  var lambda_type = type.kind().lambda.unwrap()

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var args = list[Id]()
  for arg in lambda_type.args do args.&.push(body.param(arg))
  var closure = body.param(type_box(type_dynamic_lambda))

  var dynamic_args = list[Id]()
  for arg in args.iter() do dynamic_args.&.push(arg.static_to_dynamic(context))
  var dynamic_args = array(type_array(type_dynamic), dynamic_args.to_slice())

  var result = closure.unbox().call(list(dynamic_args).to_slice())
    .dynamic_to_static(lambda_type.return_type, context)

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
