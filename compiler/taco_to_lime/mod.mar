import ../plum.mar

fun to_lime(taco: Taco): Lime {
  var funs = map[String, LimeFun]()
  for fun_ in taco.funs do funs.&.put(fun_.key, fun_.value.to_lime(funs.&))
  Lime { entry_point = taco.entry_point.signature, funs }
}

fun to_lime(fun_: TacoFun, funs: &Map[String, LimeFun]): LimeFun {
  LimeFun {
    params = fun_.params,
    body = fun_.body.to_lime(none[OngoingRecursive](), funs),
  }
}

struct OngoingRecursive { captured: Slice[Hole], signature: String }
fun to_lime(
  expr: TacoExpr,
  recursive: Maybe[OngoingRecursive],
  funs: &Map[String, LimeFun],
): LimeExpr {
  switch expr.op
  case hole(hole) lime_hole(hole)
  case type(type) lime_type(type)
  case byte(byte) lime_byte(byte)
  case int(int) lime_int(int)
  case array {
    var items = list[LimeExpr]()
    for item in expr.children do items.&.push(item.to_lime(recursive, funs))
    array(expr.type.kind().array.unwrap(), items.to_slice())
  }
  case struct_ {
    var keys = list[String]()
    for field in expr.type.kind().struct_.unwrap() do keys.&.push(field.key)
    keys.to_slice().&.sort()

    var fields = map[String, LimeExpr]()
    for field in zip(keys.to_slice().iter(), expr.children.iter()) do {
      fields.&.put(field.a, field.b.to_lime(recursive, funs))
    }
    struct_(fields)
  }
  case enum_(name) {
    enum_(expr.type, name, expr.children.get(0).to_lime(recursive, funs))
  }
  case lambda(params) {
    var body = expr.children.get(0)

    var captured = body.collect_captured(params)
    var closure = box({
      var fields = map[String, LimeExpr]()
      for captured in captured.iter().enumerate() do
        fields.&.put("{captured.index}", lime_hole(captured.item))
      struct_(fields)
    })
    var closure_hole = hole(closure.type)

    var signature = "lambda-{funs.size}"
    funs.put(signature, LimeFun {
      params = {
        var actual = list[Hole]()
        actual.&.push(closure_hole)
        for param in params do actual.&.push(param)
        actual.to_slice()
      },
      body = body
        .fill({
          var filling = map[Hole, TacoExpr]()
          for captured in captured.iter().enumerate() do
            filling.&.put(
              captured.item,
              taco_hole(closure_hole).unbox().member("{captured.index}"),
            )
          filling
        })
        .to_lime(some(OngoingRecursive { captured, signature }), funs),
    })
    lambda(signature, closure, expr.type)
  }
  case box box(expr.children.get(0).to_lime(recursive, funs))
  case member(name) {
    expr.children.get(0).to_lime(recursive, funs).member(name)
  }
  case switch_(case_holes) {
    var condition = expr.children.first()
    var cases = expr.children.without_first()
    
    var keys = list[String]()
    for variant in condition.type.kind().enum_.unwrap() do
      keys.&.push(variant.key)
    keys.to_slice().&.sort()

    var lime_cases = map[String, LimeCase]()
    for case_ in zip(keys.iter(), zip(case_holes.iter(), cases.iter())) do
      lime_cases.&.put(
        case_.a, LimeCase { payload = case_.b.a, body = case_.b.b.to_lime(recursive, funs) }
      )
    switch_(condition.to_lime(recursive, funs), expr.type, lime_cases)
  }
  case call_fun(fun_) {
    var args = list[LimeExpr]()
    for arg in expr.children do args.&.push(arg.to_lime(recursive, funs))
    fun_.signature.call(args.to_slice(), expr.type)
  }
  case call_lambda {
    var lambda = expr.children.first().to_lime(recursive, funs)
    var args = list[LimeExpr]()
    for arg in expr.children.without_first() do
      args.&.push(arg.to_lime(recursive, funs))
    lambda.call(args.to_slice())
  }
  case body {
    var children = list[Tuple2[Hole, LimeExpr]]()
    for child in expr.children.without_last() do
      children.&.push(tuple(hole(child.type), child.to_lime(recursive, funs)))
    body(children.to_slice(), expr.children.last().to_lime(recursive, funs))
  }
  case cast unreachable()
  case lower_byte lower_byte(expr.children.get(0).to_lime(recursive, funs))
  case byte_to_int byte_to_int(expr.children.get(0).to_lime(recursive, funs))
  case add_ints
    add(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case sub_ints
    subtract(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case mul_ints
    multiply(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case div_ints
    divide(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case mod_ints
    modulo(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case and_ints
    and_(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case or_ints
    or_(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case xor_ints
    xor(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case compare_ints
    compare(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case unbox unbox(expr.children.get(0).to_lime(recursive, funs))
  case generate_array {
    var index = hole(type_int)
    generate_array(
      expr.children.get(0).to_lime(recursive, funs),
      index,
      expr.children.get(1).to_lime(recursive, funs)
        .call(list(lime_hole(index)).to_slice()),
    )
  }
  case array_get
    array_get(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
    )
  case array_set
    array_set(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
      expr.children.get(2).to_lime(recursive, funs),
    )
  case array_slice
    array_slice(
      expr.children.get(0).to_lime(recursive, funs),
      expr.children.get(1).to_lime(recursive, funs),
      expr.children.get(2).to_lime(recursive, funs),
    )
  case array_len
    array_len(expr.children.get(0).to_lime(recursive, funs))
  case type_info unreachable()
  case static_to_dynamic unreachable()
  case dynamic_to_static unreachable()
  case crash lime_crash(expr.type)
  case recursive(args) {
    var initial = expr.children.without_last()
    var body = expr.children.last()

    var captured = body.collect_captured(args)

    var signature = "recursive-{funs.size}"
    funs.put(signature, LimeFun {
      params = {
        var params = list[Hole]()
        for captured in captured do params.&.push(captured)
        for arg in args do params.&.push(arg)
        params.to_slice()
      },
      body = body.to_lime(some(OngoingRecursive { captured, signature }), funs),
    })

    signature.call({
      var full_args = list[LimeExpr]()
      for captured in captured do full_args.&.push(lime_hole(captured))
      for arg in initial do full_args.&.push(arg.to_lime(recursive, funs))
      full_args.to_slice()
    }, expr.type)
  }
  case recurse {
    var ongoing = recursive.unwrap()
    ongoing.signature.call({
      var args = list[LimeExpr]()
      for captured in ongoing.captured do args.&.push(lime_hole(captured))
      for arg in expr.children do args.&.push(arg.to_lime(recursive, funs))
      args.to_slice()
    }, expr.type)
  }
  case unreachable lime_unreachable(expr.type)
}

fun collect_captured(expr: TacoExpr, ignore: Slice[Hole]): Slice[Hole] {
  var ig = set[Hole]()
  for hole in ignore do ig.&.put(hole)
  var out = set[Hole]()
  expr.collect_captured(ig.&, out.&)
  var sliced = list[Hole]()
  for hole in out do sliced.&.push(hole)
  sliced.to_slice()
}
fun collect_captured(expr: TacoExpr, ignore: &Set[Hole], out: &Set[Hole]) {
  if expr.op is lambda(holes) then for hole in holes do ignore.put(hole)
  if expr.op is switch_(holes) then for hole in holes do ignore.put(hole)
  for child in expr.children do child.collect_captured(ignore, out)
}
