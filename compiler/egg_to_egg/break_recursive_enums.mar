| Adding Dup and Drop Instructions  
|
| This conversion introduces a form of ownership. After this transformation,
| every value in the Egg has one or multiple owners and stores a reference count
| of the the number of owners. Every value in the Egg is reference counted.
| Later on, some of the reference counting operations are simplified (for
| example, if a type doesn't require any heap allocations, no reference counting
| occurs because it is always copied).
| You can only use an expression if you own it. All operations take ownership
| of the input values and give you ownership of the returned values. For
| example, constructing a struct takes ownership of the individual fields and
| gives you ownership of the struct. Calling a function passes ownership of the
| arguments to the function and gives you ownership of the return value.
| The dup expression increments the reference count and allows you to use an
| expression more than once. The drop expression decrements the reference count
| and frees the value's memory if the reference count reaches zero.

import ../plum.mar

fun introduce_ownership(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do funs.&.put(fun_.key, fun_.value.introduce_ownership())
  Egg { entry_point = egg.entry_point, funs }
}

fun introduce_ownership(fun_: EggFun): EggFun {
  var mapping = map[EggId, EggId]()
  fun_.body.visit(ReserveIds { mapping = mapping.& })
  var body = fun_.body.introduce_ownership(set[EggId]().&, mapping)
  EggFun { body }
}
struct ReserveIds { mapping: &Map[EggId, EggId] }
fun visit(body: EggBody, reserve: ReserveIds) {
  for param in body.params do param.visit(reserve)
  for child in body.children do child.visit(reserve)
}
fun visit(id: EggId, reserve: ReserveIds) {
  if not(reserve.mapping.contains(id)) then
    reserve.mapping.put(id, create_egg_placeholder())
  id.visit_children(reserve)
}

fun introduce_ownership(
  body: EggBody,
  needed_later_on: &Set[EggId], mapping: Map[EggId, EggId],
): EggBody {
  var rev_body = list[EggId]()

  rev_body.&.require(mapping.get(body.returns), needed_later_on)

  for id in body.children.rev_iter() do
    id.introduce_ownership(rev_body.&, needed_later_on, mapping)

  var params = list[EggId]()
  for param in body.params do {
    var type = param.type()
    var param = mapping.get(param)
    if not(needed_later_on.contains(param)) then
      rev_body.&.push(EggExpr.drop(param).create())
    else
      needed_later_on.remove(param)
    params.&.push(update(param, EggExpr.param(type)))
  }
  var params = params.to_slice()

  var exprs = list[EggId]()
  for id in rev_body.to_slice().rev_iter() do exprs.&.push(id)
  var exprs = exprs.to_slice()

  EggBody { params, children = exprs, returns = mapping.get(body.returns) }
}

fun require(
  rev_body: &List[EggId], id: EggId, needed_later_on: &Set[EggId]
) {
  if needed_later_on.contains(id) then
    rev_body.push(EggExpr.dup(id).create())
  else
    needed_later_on.put(id)
}

fun introduce_ownership(
  id: EggId,
  rev_body: &List[EggId], needed_later_on: &Set[EggId],
  mapping: Map[EggId, EggId],
) {
  var expr = id.resolve()
  var id = mapping.get(id)

  if not(needed_later_on.contains(id)) then
    rev_body.&.push(EggExpr.drop(id).create())
  else
    needed_later_on.remove(id)

  switch expr
  case byte(byte) rev_body.push(update(id, EggExpr.byte(byte)))
  case lower_byte(int) {
    var int = mapping.get(int)
    rev_body.push(update(id, EggExpr.lower_byte(int)))
    rev_body.require(int, needed_later_on)
  }
  case byte_to_int(byte) {
    var byte = mapping.get(byte)
    rev_body.push(update(id, EggExpr.byte_to_int(byte)))
    rev_body.require(byte, needed_later_on)
  }
  case int(int) rev_body.push(update(id, EggExpr.int(int)))
  case add(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.add(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case subtract(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.subtract(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case multiply(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.multiply(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case unchecked_divide(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.divide(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case unchecked_modulo(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.modulo(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case and_(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.and_(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case or_(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.or_(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case xor(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.xor(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case compare(args) {
    var args = mapping.get(args)
    rev_body.push(update(id, EggExpr.compare(args)))
    rev_body.require(args.a, needed_later_on)
    rev_body.require(args.b, needed_later_on)
  }
  case struct_(struct_) {
    var fields = map[String, EggId]()
    for field in struct_ do fields.&.put(field.key, mapping.get(field.value))
    rev_body.push(update(id, EggExpr.struct_(fields)))
    for field in fields do rev_body.require(field.value, needed_later_on)
  }
  case member(member) {
    var of = mapping.get(member.of)
    rev_body.push(update(
      id, EggExpr.member(EggMember { of, name = member.name })
    ))
    rev_body.require(of, needed_later_on)
  }
  case enum_(enum_) {
    var payload = mapping.get(enum_.payload)
    rev_body.push(update(
      id,
      EggExpr.enum_(EggEnum {
        variant = enum_.variant, payload, type = enum_.type
      }),
    ))
    rev_body.require(payload, needed_later_on)
  }
  case switch_(switch_) {
    var condition = mapping.get(switch_.condition)

    | Lower the individual cases.
    var cases = map[String, EggBody]()
    var needed_by_branches = map[String, Set[EggId]]()
    for case_ in switch_.cases do {
      var needed_by_this_branch = set[EggId]()
      for id in needed_later_on do needed_by_this_branch.&.put(id)
      cases.&.put(
        case_.key,
        case_.value.introduce_ownership(needed_by_this_branch.&, mapping),
      )
      needed_by_branches.&.put(case_.key, needed_by_this_branch)
    }

    | Figure out the IDs that all branches need.
    for entry in needed_by_branches do
      for id in entry.value do needed_later_on.&.put(id)

    | If a branch doesn't use IDs that other branches use, drop those at the
    | start of the branch body.
    for case_ in cases do {
      var needed_by_this_branch = needed_by_branches.get(case_.key)
      var diff_to_other_branches = set[EggId]()
      for id in needed_later_on do
        if not(needed_by_this_branch.contains(id)) then
          diff_to_other_branches.&.put(id)

      var drops = list[EggId]()
      for id in diff_to_other_branches do
        drops.&.push(EggExpr.drop(id).create())

      cases.&.put(case_.key, EggBody {
        params = case_.value.params,
        children = {drops + case_.value.children.to_list()}.to_slice(),
        returns = case_.value.returns,
      })
    }
    rev_body.push(update(
      id, EggExpr.switch_(EggSwitch { condition, type = switch_.type, cases })
    ))
    rev_body.require(condition, needed_later_on)
  }
  case raw_lambda(lambda) {
    var closure = mapping.get(lambda.closure)
    rev_body.push(update(
      id,
      EggExpr.raw_lambda(EggRawLambda {
        fun_ = lambda.fun_, closure, type = lambda.type
      }),
    ))
    rev_body.require(closure, needed_later_on)
  }
  case call_fun(call) {
    var args = mapping.get(call.args)
    rev_body.push(update(
      id,
      EggExpr.call_fun(EggCallFun {
        fun_ = call.fun_,
        substitutions = no_substitutions,
        args,
        return_type = call.return_type,
      }),
    ))
    for arg in args do rev_body.require(arg, needed_later_on)
  }
  case call_lambda(call) {
    var lambda = mapping.get(call.lambda)
    var args = mapping.get(call.args)
    rev_body.push(update(
      id, EggExpr.call_lambda(EggCallLambda { lambda, args })
    ))
    for arg in args do rev_body.require(arg, needed_later_on)
    rev_body.require(lambda, needed_later_on)
  }
  case box(inner) {
    var inner = mapping.get(inner)
    rev_body.push(update(id, EggExpr.box(inner)))
    rev_body.require(inner, needed_later_on)
  }
  case unbox(box) {
    var box = mapping.get(box)
    rev_body.push(update(id, EggExpr.unbox(box)))
    rev_body.require(box, needed_later_on)
  }
  case array(array) {
    var items = mapping.get(array.items)
    rev_body.push(update(
      id, EggExpr.array(EggArray { items, item_type = array.item_type })
    ))
    for item in items do rev_body.require(item, needed_later_on)
  }
  case unchecked_generate_non_empty_array(gen) {
    var length = mapping.get(gen.length)
    var last_used_in_generator = {
      var ids = list[EggId]()
      for id in gen.generator.captured() do {
        var id = mapping.get(id)
        if not(needed_later_on.contains(id)) then ids.&.push(id)
      }
      ids.to_slice()
    }
    for id in last_used_in_generator do {
      needed_later_on.put(id)
      rev_body.push(EggExpr.drop(id).create())
    }
    var generator = gen.generator.introduce_ownership(needed_later_on, mapping)
    rev_body.push(update(
      id, EggExpr.generate_array(EggGenerateArray { length, generator })
    ))
  }
  case array_len(array) {
    var array = mapping.get(array)
    rev_body.push(update(id, EggExpr.array_len(array)))
    rev_body.require(array, needed_later_on)
  }
  case unchecked_array_get(args) {
    var array = mapping.get(args.array)
    var index = mapping.get(args.index)
    rev_body.push(update(id, EggExpr.array_get(EggArrayGet { array, index })))
  }
  case unchecked_array_set(args) {
    var array = mapping.get(args.array)
    var index = mapping.get(args.index)
    var item = mapping.get(args.item)
    rev_body.push(update(
      id, EggExpr.array_set(EggArraySet { array, index, item })
    ))
  }
  case unchecked_array_slice(args) {
    var array = mapping.get(args.array)
    var start = mapping.get(args.start)
    var end = mapping.get(args.end)
    rev_body.push(update(
      id, EggExpr.array_slice(EggArraySlice { array, start, end })
    ))
  }
  case type(ty) rev_body.push(update(id, EggExpr.type(ty)))
  case crash(crash) {
    var message = mapping.get(crash.message)
    rev_body.push(update(
      id, EggExpr.crash(EggCrash { message, type = crash.type })
    ))
    rev_body.require(message, needed_later_on)
  }
  case unreachable(type) rev_body.push(update(id, EggExpr.unreachable(type)))
  case loop_ todo("loop")
  case continue_ todo("continue")
  default unreachable("{expr.debug()} should not occur")
}

fun get(
  mapping: Map[EggId, EggId], tuple: Tuple2[EggId, EggId]
): Tuple2[EggId, EggId] {
  tuple(mapping.get(tuple.a), mapping.get(tuple.b))
}

fun get(
  mapping: Map[EggId, EggId], ids: Slice[EggId],
): Slice[EggId] {
  var out = list[EggId]()
  for id in ids do out.&.push(mapping.get(id))
  out.to_slice()
}
