import mod.mar

fun is_unchecked(id: EggId): Bool {
  switch id.resolve()
  case unchecked_divide true
  case unchecked_modulo true
  case unchecked_generate_non_empty_array true
  case unchecked_array_get true
  case unchecked_array_set true
  case unchecked_array_slice true
  default false
}

fun desugar_checks_of_array_ops(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(DesugarBoundsChecks {}))
  Egg { funs, entry_point = egg.entry_point }
}
struct DesugarBoundsChecks {}
fun map(
  id: EggId, desugar: DesugarBoundsChecks,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(desugar, mapping)
  switch expr
  case generate_array(args) {
    var item_type = args.generator.returns.type()
    var cmp_length_zero = builder.compare(args.length, builder.int(0))
    builder.switch_on_ordering(
      cmp_length_zero,
      {
        var builder = egg_body_builder().&
        builder.case_param(cmp_length_zero, "less")
        builder.finish(builder.crash("negative length", type_array(item_type)))
      },
      {
        var builder = egg_body_builder().&
        builder.case_param(cmp_length_zero, "equal")
        builder.finish(builder.array(empty_slice[EggId](), item_type))
      },
      {
        var builder = egg_body_builder().&
        builder.case_param(cmp_length_zero, "greater")
        builder.finish(
          builder.unchecked_generate_non_empty_array(
            args.length, args.generator
          )
        )
      },
    )
  }
  case array_get(args) {
    builder.assert_is_greater_equal(args.index, builder.int(0), "out of bounds")
    builder.assert_is_less(
      args.index, builder.array_len(args.array), "out of bounds"
    )
    builder.unchecked_array_get(args.array, args.index)
  }
  case array_set(args) {
    builder.assert_is_greater_equal(args.index, builder.int(0), "out of bounds")
    builder.assert_is_less(
      args.index, builder.array_len(args.array), "out of bounds"
    )
    builder.unchecked_array_set(args.array, args.index, args.item)
  }
  case array_slice(args) {
    var length = builder.array_len(args.array)
    builder.assert_is_greater_equal(args.start, builder.int(0), "bad bounds")
    builder.assert_is_greater(args.start, length, "bad bounds")
    builder.assert_is_less_equal(args.start, args.end, "bad bounds")
    builder.assert_is_less_equal(args.end, length, "bad bounds")
    builder.unchecked_array_slice(args.array, args.start, args.end)
  }
  default builder.push(expr)
}


fun desugar_checks_of_divide_and_modulo(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(DesugarDivideAndModulo {}))
  Egg { funs, entry_point = egg.entry_point }
}

struct DesugarDivideAndModulo {}
fun map(
  id: EggId, desugar: DesugarDivideAndModulo,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(desugar, mapping)
  switch expr
  case divide(args) {
    builder.switch_on_ordering(
      builder.compare(args.b, builder.int(0)),
      egg_body_taking_nothing_returning_nothing(),
      egg_body_taking_nothing_crashing("divide by zero", type_nothing),
      egg_body_taking_nothing_returning_nothing(),
    )
    builder.unchecked_divide(args.a, args.b)
  }
  case modulo(args) {
    builder.switch_on_ordering(
      builder.compare(args.b, builder.int(0)),
      egg_body_taking_nothing_returning_nothing(),
      egg_body_taking_nothing_crashing("modulo by zero", type_nothing),
      egg_body_taking_nothing_returning_nothing(),
    )
    builder.unchecked_modulo(args.a, args.b)
  }
  default builder.push(expr)
}

