| Welcome to the Egg optimizer! This file contains lots of code, so I'll point
| out some general themes going on here. The code here is used to turn a Egg
| into a more optimized Egg.
|
| This is achieved by constant folding operations, inlining function calls,
| analyzing fixpoints of recursive expressions, and pulling impure operations
| out of the tree.

import ../mod.mar
import choose_order.mar
import deduplicate.mar
import enum_flow.mar
import fixpoints.mar
import hoist.mar
import tree_shake.mar

fun optimize(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for signature in egg.choose_optimization_order() do {
    eprintln("Optimizing {signature}")
    var optimized = egg.funs.get(signature).map(Optimize { optimized = funs.& })
    eprintln("Optimized {signature}:")
    stderr.write("optimized", optimized)
    stderr."\n"
    optimized.verify()
    funs.&.put(signature, optimized)
  }
  Egg { funs, entry_point = egg.entry_point }.tree_shake()
}
fun optimize_without_inlining(body: EggBody): EggBody {
  body.map(
    Optimize { optimized = map[String, EggFun]().& }, map[EggId, EggId]().&
  )
}

var optimized_cache = map[EggId, EggBody]().put_on_heap()

struct Optimize { optimized: &Map[String, EggFun] }
fun map(
  body: EggBody, optimize: Optimize, mapping: &Map[EggId, EggId]
): EggBody {
  body.map_children(optimize, mapping)
    .use_enum_flow()
    .deduplicate()
    .tree_shake()
}
fun map(
  old: EggId,
  optimize: Optimize, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  if optimized_cache.get_maybe(old) is some(new) then {
    for child in new.children do builder.push(child)
    return new.returns
  }

  | A version of the expression with optimized children. For example, if the
  | current expression is a switch, this will create the same switch but with
  | optimized bodies.
  var children_optimized = old.map_children(optimize, mapping).create()

  | A body that contains:
  | - unoptimized expressions that resulted from optimizing the current
  |   expression
  | - the current slightly optimized expression
  var slightly_optimized = {
    var builder = egg_body_builder().&
    builder.finish(children_optimized.optimize(optimize, builder))
  }

  | A body that contains:
  | - fully optimized expressions that resulted from optimizing the current
  |   expression
  | - the current fully optimized expression
  var fully_optimized =
    if slightly_optimized.returns == children_optimized then {
      | The current expression could not be further optimized apart from
      | optimizing its children.
      slightly_optimized
    } else {
      | The current expression was broken down into some smaller expressions.
      | Optimize those recursively.
      var builder = egg_body_builder().&
      for child in slightly_optimized.children do
        mapping.put(child, child.map(optimize, builder, mapping))
      builder.finish(slightly_optimized.returns.map(mapping))
    }

  for child in fully_optimized.children do builder.push(child)

  mapping.put(old, fully_optimized.returns)
  optimized_cache.put(old, fully_optimized)
  fully_optimized.returns

  | var total_optimized = {

  | }

  | | The optimize function may not be stable, i.e. it may create expressions that
  | | can be further optimized.
  | var new =
  |   if self_optimized.returns == children_optimized then {
  |     optimized_cache.put(old, self_optimized)
  |     builder.push(children_optimized)
  |   } else {
  |   }

  | var namespace = namespace().&
  | | stderr."Original\n  {pretty(old, namespace)} = "
  | | stderr.write(old, namespace, indentation(2))
  | | stderr."\n"
  | | stderr."Optimizing (children optimized)\n  {pretty(children_optimized, namespace)} = "
  | | stderr.write(children_optimized, namespace, indentation(2))
  | | stderr."\n"

  | | Compile the single expression into an optimized body (allowing it to expand
  | | to zero or multiple expressions).

  | | stderr."Self optimized:"
  | | for child in self_optimized.children do {
  | |   stderr."\n  {pretty(child, namespace)} = "
  | |   stderr.write(child, namespace, indentation(2))
  | | }
  | | stderr."\n  {pretty(self_optimized.returns, namespace)}\n"

  | var new =
  |   if self_optimized.returns == children_optimized then {
  |     optimized_cache.put(old, self_optimized)
  |     builder.push(children_optimized)
  |   } else {
  |     for child in self_optimized.children do {
  |       var even_more_optimized = child.map(optimize, builder, mapping)
  |       mapping.put(child, even_more_optimized)
  |     }
  |     self_optimized.returns.map(mapping)
  |   }
  | mapping.put(old, new)
  | | optimized_cache.put(old, new)
  | new
}

| Assuming that the dependencies of the expression are accessible in the
| builder and already optimized, emit expressions that are equivalent to
| performing the expression.
fun optimize(id: EggId, optimize: Optimize, builder: &EggBodyBuilder): EggId {
  eprintln("Optimizing {id.debug()}")
  switch id.resolve()
  case lambda(lambda) {
    | Assuming that the lambda will run often, hoisting pure expressions out of
    | it prevents recalculating them over and over every time the lambda is
    | called.
    |
    | a = ...
    | ---------------------------------------
    | lambda c:           |  b = multiply a a
    |   d = multiply a a  |  lambda d:
    |   e = add c d       |    e = add b d
    |   e                 |    e
    var hoisted = lambda.hoist_from_body_running_often()
    if hoisted.hoisted.is_not_empty() then {
      for id in hoisted.hoisted do builder.push(id)
      return builder.lambda(hoisted.body)
    }
  }
  case member(member) {
    | Constant fold members of known structs.
    |
    | a = ...
    | b = ...
    | c = & foo: a bar: b
    | -------------------
    | member c.foo  |  a
    if member.of.resolve() is struct_(fields) then
      return fields.get(member.name)
  }
  case switch_(switch_) {
    | Constant fold switches on enums of known variants.
    |
    | a = &
    | b = | true: a
    | -----------------------
    | switch b       |  int 2
    |   true d:      |
    |     e = int 2  |
    |     e          |
    |   false f:     |
    |     g = int 3  |
    |     g          |
    if switch_.condition.resolve() is enum_(enum_) then
      return switch_.cases.get(enum_.variant).fill(enum_.payload, builder)

    | If all cases are either the same value that doesn't depend on parameters
    | or unreachable, replace the switch with that value.
    |
    | a = ...
    | ---------------------------------
    | switch a             |  int 3
    |   true b:            |
    |     c = unreachable  |
    |     c                |
    |   false d:           |
    |     e = int 3        |
    |     e                |
    var reachable_cases = list[MapEntry[String, EggBody]]()
    for case_ in switch_.cases do
      if not(case_.value.is_unreachable()) then reachable_cases.&.push(case_)
    eprintln("{reachable_cases.len} reachable cases")
    if reachable_cases.is_empty() then return builder.unreachable(switch_.type)
    else if not(reachable_cases.get(0).value.uses_params()) then {
      var common = reachable_cases.get(0).value.without_params()
      eprintln("common: {common.debug()}")
      var inline = true
      for case_ in reachable_cases do {
        if not(inline) then break
        if case_.value.without_params() != common then inline = false
      }
      if inline then return common.fill(empty_slice[EggId](), builder)
    }

    | If all non-diverging cases are the same and don't depend on parameters,
    | pull them out of the switch, leaving the switch to evaluate to Nothing.
    | This then leaves simpler, more constant-foldable ingredients for later
    | expressions.
    |
    | a = ...
    | ---------------------------------
    | switch a       |  b =
    |   true b:      |    switch a
    |     c = crash  |      true c:
    |     c          |        d = crash
    |   false d:     |        d
    |     e = int 3  |      false e:
    |     e          |        f = &
    |                |        f
    |                |  int 3
    var non_diverging_cases = list[MapEntry[String, EggBody]]()
    for case_ in switch_.cases do
      if not(case_.value.definitely_diverges_biased()) then
        non_diverging_cases.&.push(case_)
    if non_diverging_cases.is_not_empty()
      and not(non_diverging_cases.get(0).value.uses_params())
    then {
      var common = non_diverging_cases.get(0).value.without_params()
      var nothing = egg_body_builder().&.nothing()
      var is_body_just_returning_nothing =
        common.returns == nothing and {
          common.children.is_empty() or
            common.children.len == 1 and common.children.get(0) == nothing
        }
      var inline = not(is_body_just_returning_nothing)
      for case_ in non_diverging_cases do {
        if not(inline) then break
        if case_.value.without_params() != common then inline = false
      }
      if inline then {
        builder.switch_(switch_.condition, type_nothing, {
          var new_cases = map[String, EggBody]()
          for case_ in switch_.cases do
            new_cases.&.put(case_.key, {
              var builder = egg_body_builder().&
              for param in case_.value.params do builder.params.&.push(param)
              if case_.value == common
              then builder.finish(builder.nothing())
              else case_.value
            })
          new_cases
        })
        return common.fill(empty_slice[EggId](), builder)
      }
    }

    | Consider "inlining" switches that switch on the result of other switches.
    |
    | c = compare a b       |  c = compare a b
    | d =                   |  d =
    |   switch c            |    switch c
    |     less e:           |      less e:
    |       f = &           |        f = crash
    |       g = | false: f  |        f
    |       g               |      equal g:
    |     equal h:          |        h = &
    |       i = &           |        h
    |       j = | true: i   |      less i:
    |       j               |        j = crash
    |     greater k:        |        j
    |       l = &           |
    |       m = | true: l   |
    |       m               |
    | n =                   |
    |   switch d            |
    |     true o:           |
    |       p = &           |
    |       p               |
    |     false q:          |
    |       r = crash       |
    | if switch_.condition.resolve() is switch_(inner_switch) then {
    |   var all_cases_known = true
    |   for case_ in inner_switch.cases do
    |     if not(case_.value.expr.resolve() is enum_) then all_cases_known = false
    |   | If not all cases are known, we would have copy the entire outer switch
    |   | into at least one case of the inner switch. That's a huge code
    |   | explosion, so let's not do that.
    |   if all_cases_known then {
    |     | Calculate how much code explosion we would have. For example, if one
    |     | case of the outer switch is really big and multiple branches from the
    |     | inner switch evaluate to that variant, maybe we don't want to inline
    |     | the code.
    |     var max_outer_case_complexity = 0
    |     for case_ in switch_.cases do
    |       max_outer_case_complexity =
    |         max(max_outer_case_complexity, case_.value.expr.num_exprs())
    |     if max_outer_case_complexity <= 2 then {
    |       return switch_(inner_switch.condition.*, expr.type, {
    |         var new_cases = map[String, EggBody]()
    |         for case_ in inner_switch.cases do
    |           new_cases.&.put(
    |             case_.key,
    |             body(
    |               case_.value.params,
    |               switch_(case_.value.expr, expr.type, switch_.cases)
    |                 ,
    |             ),
    |           )
    |         new_cases
    |       })
    |     }
    |   }
    | }

    | TODO: Inner switch but one variant of the outer switch is never chosen;
    | case could be optimized to unreachable.

    | TODO: If a switch diverges in a case, when switching on the same
    | expression later, the diverging case is unreachable.
  }
  case call_fun(call) {
    | TODO: Try to run the function at compile time.

    | Inline the function, if:
    | - The function has already been visited during the optimization pass.
    |   Otherwise, mutually recursive functions might hang the compiler.
    | - The function size fits in some upper bound.
    |   Otherwise, we may get exponential code explosion.
    | - The function is not generic.
    |   Otherwise, the function might call itself with different type arguments
    |   and we can't model that, not even using a recursive expression. After
    |   monomorphization, no generic functions exist, so every function has a
    |   chance of being inlined eventually.
    |
    | a = int 3
    | b = int 2
    | --------------------------------
    | call + a b  |  add a b  |  int 5
    if call.substitutions.substitutions.size == 0 then
      if optimize.optimized.get_maybe(call.fun_) is some(fun_) then {
        var should_inline = fun_.body.num_exprs() <= 30
        if should_inline then {
          eprintln("inlining call")
          eprintln("fun:\n")
          stderr.write(Egg { funs = map("to_inline" -> fun_), entry_point = "" })
          stderr."\n"
          return builder.recursive(
            call.args,
            fun_.body.call_to_recurse(call.fun_, call.return_type),
          )
        }
      }
  }
  case call_lambda(call) {
    | Inline calls of lambda literals.
    |
    | a =
    |   lambda b:
    |     c = int 3
    |     d = add b c
    |     d
    | e = int 4
    | ----------------------------------
    | call lambda a with e  |  f = int 3
    |                       |  add e f
    if call.lambda.resolve() is lambda(lambda_body) then
     return lambda_body.fill(call.args, builder)
  }
  case cast(cast) {
    | Remove unnecessary casts.
    |
    | a = int 2
    | ------------------
    | cast a (Int)  |  a
    if cast.what.type() == cast.type then return cast.what

    | Instead of casting enums, construct them directly with the correct type.
    |
    | a = &
    | b = | none: a (| none: (&))
    | ------------------------------------------------------------------------
    | cast b (| none: (&) some: (Int))  |  | none: a (| none: (&) some: (Int))
    if cast.what.resolve() is enum_(enum_) then {
      return builder.enum_(
        cast.type,
        enum_.variant,
        builder.cast(
          enum_.payload, cast.type.kind().enum_.unwrap().get(enum_.variant)
        ),
      )
    }
  }
  case lower_byte(arg) {
    | Constant fold.
    if arg.resolve() is int(int) then return builder.byte(int.lower_byte())

    | lower_byte(byte_to_int(a)) = a
    if arg.resolve() is byte_to_int(a) then return a
  }
  case byte_to_int(arg) {
    | Constant fold.
    if arg.resolve() is byte(byte) then return builder.int(byte.to_int())
  }
  case add(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a + b)

    | 0 + x = x
    if a.resolve() is int(a) then if a == 0 then return b

    | x + 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | (x - y) + y = x
    if a.resolve() is subtract(args) then if b == args.b then return args.a

    | x + (y - x) = y
    if b.resolve() is subtract(args) then if a == args.b then return args.a
  }
  case subtract(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a - b)

    | x - 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | (x + y) - y = x
    if a.resolve() is add(args) then if args.b == b then return args.a
  }
  case multiply(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a * b)

    | 1 * x = x
    if a.resolve() is int(a) then if a == 1 then return b

    | x * 1 = x
    if b.resolve() is int(b) then if b == 1 then return a
  }
  case divide(args) {
    var a = args.a
    var b = args.b

    | Constant fold crash.
    if b.resolve() is int(b) then if b == 0 then
      return builder.crash(builder.string("divide by zero"), type_int)

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a / b)

    | x / 1 = x
    if b.resolve() is int(b) then if b == 1 then return a
  }
  case modulo(args) {
    var a = args.a
    var b = args.b

    | Constant fold crash.
    if b.resolve() is int(b) then if b == 0 then
      return builder.crash(builder.string("modulo by zero"), type_int)

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a % b)

    | x % 1 = 0
    if b.resolve() is int(b) then if b == 1 then return builder.int(0)
  }
  case and_(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a & b)

    | 0 & x = 0
    if a.resolve() is int(a) then if a == 0 then return builder.int(0)
  
    | x & 0 = 0
    if b.resolve() is int(b) then if b == 0 then return builder.int(0)

    | -1 & x = x
    if a.resolve() is int(a) then if a == -1 then return b

    | x & -1 = x
    if b.resolve() is int(b) then if b == -1 then return a
  }
  case or_(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(or(a, b))

    | 0 or x = x
    if a.resolve() is int(a) then if a == 0 then return b
  
    | x or 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | -1 or x = -1
    if a.resolve() is int(a) then if a == -1 then return builder.int(-1)
  
    | x or -1 = -1
    if b.resolve() is int(b) then if b == -1 then return builder.int(-1)
  }
  case xor(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a ^ b)
    
    | x xor x = 0
    if a == b then return builder.int(0)
  }
  case compare(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.enum_(
        type_ordering,
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater",
        builder.nothing()
      )

    | compare(x, x) == equals
    if a == b then
      return builder.enum_(type_ordering, "equal", builder.nothing())

    | compare((x - y), 0) = compare(x, y)
    if a.resolve() is subtract(sub) then if b.resolve() is int(b) then
      if b == 0 then return builder.compare(sub.a, sub.b)
    
    | Note: Because add and subtract wrap around, we can't optimize something
    | like compare(x + 1, x) to greater.
  }
  case unbox(box) {
    | unbox(box(x)) = x
    if box.resolve() is box(inner) then return inner
  }
  case unchecked_generate_non_empty_array(args) {
    | For small arrays, specialize and constant fold the generator for each
    | index.
    |
    | a = int 4
    | ----------------------------------------------------------
    | unchecked_generate_non_empty_array a  |  b = multiply 0 0
    |   generator b:                        |  c = multiply 1 1
    |     c = multiply b b                  |  d = multiply 2 2
    |     c                                 |  e = multiply 3 3
    |                                       |  f = array b c d e
    if args.length.resolve() is int(length) then if length <= 10 then {
      var items = list[EggId]()
      for index in 0..length do
        items.&.push(args.generator.fill(builder.int(index), builder))
      return builder.array(items.to_slice(), args.generator.returns.type())
    }

    | Hoist expressions (even potentially crashing ones) out of the generator as
    | long as they don't depend on the index or hoisting would change the order
    | of potentially crashing expressions.
    var hoisted = args.generator.hoist_from_body_running_at_least_once()
    if hoisted.hoisted.is_not_empty() then {
      for id in hoisted.hoisted do builder.push(id)
      return builder.unchecked_generate_non_empty_array(
        args.length, hoisted.body
      )
    }
  }
  case unchecked_array_get(args) {
    | Constant fold.
    if args.array.resolve() is array(array) then
      if args.index.resolve() is int(index) then
        return if (0..array.items.len).contains(index) then
          array.items.get(index)
        else
          builder.unreachable(array.item_type)
  }
  case unchecked_array_set(args) {
    | Constant fold.
    if args.array.resolve() is array(array) then
      if args.index.resolve() is int(index) then
        return if (0..array.items.len).contains(index) then {
          var new_items = list[EggId]()
          for item in array.items do new_items.&.push(item)
          new_items.&.set(index, args.item)
          builder.array(new_items.to_slice(), array.item_type)
        } else
          builder.unreachable(type_array(array.item_type))
  }
  case unchecked_array_slice(args) {
    var start = args.start
    var end = args.end

    switch args.array.resolve()
    case array(array) {
      | Constant fold.
      if start.resolve() is int(start) then if end.resolve() is int(end) then
        return
          if (0..array.items.len).contains(start)
            and (0..=array.items.len).contains(end)
            and start <= end
          then builder.array(array.items.subslice(start..end), array.item_type)
          else builder.unreachable(type_array(array.item_type))
    }
    case unchecked_array_slice(inner_args)
      | Merge the two nested slice operations into one.
      return builder.unchecked_array_slice(
        inner_args.array,
        builder.add(inner_args.start, args.start),
        builder.add(inner_args.start, args.end),
      )
    default {}
  }
  case array_len(array) {
    switch array.resolve()
    case array(array)
      | Constant fold.
      return builder.int(array.items.len)
    case generate_array(gen)
      | length(generate_array(length, generator)) = length
      return gen.length
    case array_slice(args)
      | length(slice(array, start, end)) = end - start
      return builder.subtract(args.end, args.start)
    default {}
  }
  case recursive(rec) {
    | Remove the recursive wrapper if the body doesn't recurse.
    if not(rec.body.recurses()) then return rec.body.fill(rec.initial, builder)

    | If this is a recursive of a lambda, flip them around: Have a lambda that
    | contains a recursive computation. Replace recurse expression with lambdas
    | that internally recurse.
    | Lambdas are a form of indirect control flow and bubbling them up allows
    | surrounding code to optimize them away (for example, if they are
    | immediately called).
    | 
    | a = ... (Iterator Int) = (\ -> (| empty more: (& item: Int rest: (^3))))
    | ---
    | b =
    |   recursive a
    |     body c:
    |       d = lambda
    |         e = call lambda c
    |         f =
    |           switch e
    |             empty: g
    |               e
    |             more: h
    |               i = member h.item
    |               j = member h.rest
    |               k = add i f
    |               l = recurse j
    |               m = & rest: l item: k
    |               n = | more: m
    |               n
    |         f
    |       d
    | a =
    | if rec.body.children.len == 1
    |   and rec.body.children.get(0) == rec.body.returns
    | then
    |   if rec.body.returns.resolve() is lambda(lambda) then {
    |     eprintln("Bubbling up lambda!")
    |     return builder.lambda({
    |       var builder = egg_body_builder().&
    |       for param in lambda.params do builder.params.&.push(param)
    |       builder.finish(builder.recursive(rec.initial, {
    |         EggBody {
    |           params = {
    |             var params = list[EggId]()
    |             for param in rec.body.params do params.&.push(param)
    |             for param in lambda.params do params.&.push(param)
    |             params.to_slice()
    |           },
    |           children = lambda.children,
    |           returns = lambda.returns,
    |         }.replace_recurses_with_lambda(lambda.params)
    |       }))
    |     })
    |   }

    | Find fixpoint.
    var fixpoint = rec.find_fixpoint()
    if not(fixpoint.is_trivial()) then {
      var dehydrated_initial = fixpoint.dehydrate(rec.initial, builder)
      var new_body = {
        var builder = egg_body_builder().&
        var dehydrated_params = {
          var res = list[EggId]()
          for d in dehydrated_initial do res.&.push(builder.param(d.type()))
          res.to_slice()
        }
        var rehydrated = fixpoint.hydrate(dehydrated_params, builder)
        builder.finish(rec.body.fill(rehydrated, builder))
      } .optimize_without_inlining()
        .replace_recurses(fixpoint)
      return builder.recursive(dehydrated_initial, new_body)
    }

    | Hoist expressions indepdent of the recursion variables out of the
    | recursion.
    var hoisted = rec.body.hoist_from_body_running_at_least_once()
    if hoisted.hoisted.is_not_empty() then {
      for id in hoisted.hoisted do builder.push(id)
      return builder.recursive(rec.initial, hoisted.body)
    }

    | TODO: recursion without variables? remove and turn recurse into "halt" expressions
  }
  | case recurse(args) {
  |   | Push recurse into switch cases.
  |   if args.len == 1 then if args.get(0).resolve() is switch_(switch_) then {
  |     return switch_(switch_.condition.resolve(), type, {
  |       var cases = map[String, EggBody]()
  |       for case_ in switch_.cases do
  |         cases.&.put(
  |           case_.key,
  |           EggBody {
  |             params = case_.value.params,
  |             expr = recurse(list(case_.value.expr).to_slice(), type)
  |               
  |           }
  |         )
  |       cases
  |     })
  |   }
  | }
  default {}

  builder.push(id)
}

fun recurses(body: EggBody): Bool {
  for child in body.children do if child.recurses() then return true
  false
}
fun recurses(id: EggId): Bool {
  switch id.resolve()
  case recursive false
  case recurse true
  default {
    for child in id.children() do if child.recurses() then return true
    false
  }
}

fun children(id: EggId): Slice[EggId] {
  var children = list[EggId]()
  id.visit_children(GatherChildren { children = children.& })
  children.to_slice()
}
struct GatherChildren { children: &List[EggId] }
fun visit(id: EggId, gather: GatherChildren) { gather.children.push(id) }

| The number of expressions inside this expression.
fun num_exprs(body: EggBody): Int {
  var count = 0
  body.visit(CountExprs { count = count.& })
  count
}
struct CountExprs { count: &Int }
fun visit(id: EggId, counter: CountExprs) {
  counter.count += 1
  id.visit_children(counter)
}

| Converts calls to the given function into recurse expressions.
fun call_to_recurse(body: EggBody, fun_: String, return_type: EggType): EggBody {
  body.map(CallToRecurse { called = fun_, return_type }, map[EggId, EggId]().&)
}
struct CallToRecurse { called: String, return_type: EggType }
fun map(
  id: EggId, mapper: CallToRecurse,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mapper, mapping)
  if expr is call_fun(call) then
    if call.fun_ == mapper.called then
      return builder.recurse(call.args, mapper.return_type)
  builder.push(expr)
}

| Fills the body with concrete arguments for its parameters.
fun fill(body: EggBody, args: Slice[EggId], builder: &EggBodyBuilder): EggId {
  var mapping = map[EggId, EggId]().&
  for both in zip(body.params.iter(), args.iter()) do
    mapping.put(both.a, both.b)
  for old in body.children do {
    var new = old.map(Fill {}, builder, mapping)
    mapping.put(old, new)
  }
  body.returns.map(mapping)
}
fun fill(body: EggBody, arg: EggId, builder: &EggBodyBuilder): EggId {
  body.fill(list(arg).to_slice(), builder)
}
struct Fill {}
fun map(
  expr: EggId, fill: Fill, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]
): EggId {
  builder.push(expr.map_children(fill, mapping))
}

fun without_params(body: EggBody): EggBody {
  EggBody {
    params = empty_slice[EggId](),
    children = body.children,
    returns = body.returns,
  }
}

| fun replace_recurses_with_lambda(body: EggBody, params: Slice[EggId]): EggBody {
|   body.map(ReplaceRecursesWithLambda { params }, map[EggId, EggId]().&)
| }
| struct ReplaceRecursesWithLambda { params: Slice[EggId] }
| fun map(id: EggId, mapper: ReplaceRecursesWithLambda, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]): EggId {
|   var expr = id.map_children(mapper, mapping)
|   if expr is recurse(rec) then
|     builder.lambda({
|       var builder = egg_body_builder().&
|       for param in mapper.params do builder.params.&.push(param)
|       builder.finish(builder.recurse({
|         var args = list[EggId]()
|         for arg in rec.next do args.&.push(arg)
|         for param in mapper.params do args.&.push(param)
|         args.to_slice()
|       }, rec.type.kind().lambda.unwrap().return_type))
|     })
|   else
|     builder.push(expr)
| }
