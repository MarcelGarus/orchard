import mod.mar

enum Diverges { yes, no, maybe }

fun merge(a: Diverges, b: Diverges): Diverges {
  switch a
  case yes Diverges.yes
  case maybe { switch b case yes Diverges.yes default Diverges.maybe }
  case no b
}
fun merge(a: Diverges, b: Diverges, c: Diverges): Diverges {
  a.merge(b).merge(c)
}
fun merge(a: Diverges, b: Diverges, c: Diverges, d: Diverges): Diverges {
  a.merge(b).merge(c).merge(d)
}

fun diverges(body: EggBody): Diverges {
  var result = Diverges.no
  for child in body.children do result = merge(result, child.diverges())
  result
}
fun diverges(id: EggId): Diverges {
  switch id.resolve()
  case param panic("param")
  case type Diverges.no
  case int Diverges.no
  case string Diverges.no
  case struct_ Diverges.no
  case enum_ Diverges.no
  case lambda Diverges.no
  case member Diverges.no
  case switch_(switch_) {
    var result = Diverges.no
    for case_ in switch_.cases do result = merge(result, case_.value.diverges())
    result
  }
  case call_fun(call)
    if call.return_type == type_never then Diverges.yes else Diverges.maybe
  case call_lambda(call)
    if call.lambda.type().kind().lambda.unwrap().return_type == type_never then
      Diverges.yes
    else
      Diverges.maybe
  case call_builtin
    | Note: We don't care about a precise assessment here because builtins are
    | immediately desugared into more specific expressions anyways.
    Diverges.maybe
  case cast Diverges.no
  case byte Diverges.no
  case lower_byte Diverges.no
  case byte_to_int Diverges.no
  case add Diverges.no
  case subtract Diverges.no
  case multiply Diverges.no
  case divide Diverges.maybe
  case modulo Diverges.maybe
  case and_ Diverges.no
  case or_ Diverges.no
  case xor Diverges.no
  case compare Diverges.no
  | case unchecked_divide Diverges.no
  | case unchecked_modulo Diverges.no
  case box Diverges.no
  case unbox Diverges.no
  case array Diverges.no
  case generate_array Diverges.maybe
  case array_get Diverges.maybe
  case array_set Diverges.maybe
  case array_slice Diverges.maybe
  case array_len Diverges.no
  | case unchecked_generate_non_empty_array(gen)
  |   merge(gen.a.diverges(), gen.b.expr.diverges())
  | case unchecked_array_get(args) merge(args.a.diverges(), args.b.diverges())
  | case unchecked_array_set(args)
  |   merge(args.a.diverges(), args.b.diverges(), args.c.diverges())
  | case unchecked_array_slice(args)
  |   merge(args.a.diverges(), args.b.diverges(), args.c.diverges())
  | case type_info Diverges.no
  case static_to_dynamic Diverges.no
  case dynamic_to_static Diverges.maybe
  case crash Diverges.yes
  case unreachable Diverges.maybe
  default Diverges.maybe
}
fun diverges(ids: Slice[EggId]): Diverges {
  var result = Diverges.no
  for id in ids do result = merge(result, id.diverges())
  result
}
