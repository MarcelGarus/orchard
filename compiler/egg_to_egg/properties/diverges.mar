import mod.mar

enum Diverges { yes, no, maybe }

| Given that both a *and* b are executed and exhibit the given behavior, what's
| the overall behavior?
fun both(a: Diverges, b: Diverges): Diverges {
  switch a
  case yes Diverges.yes
  case maybe if b is yes then Diverges.yes else Diverges.maybe
  case no b
}

| Given that either a *or* b is executed and they exhibit the given behavior,
| what's the overall behavior?
fun one_of(a: Diverges, b: Diverges): Diverges {
  switch a
  case yes if b is yes then Diverges.yes else Diverges.maybe
  case no  if b is no  then Diverges.no  else Diverges.maybe
  case maybe Diverges.maybe
}

fun is_pure(id: EggId): Bool { id.diverges() is no }
fun is_impure(id: EggId): Bool { not(id.is_pure()) }

fun diverges(body: EggBody): Diverges {
  var result = Diverges.no
  for child in body.children do result = both(result, child.diverges())
  result
}
fun diverges(id: EggId): Diverges {
  switch id.resolve()
  case param panic("param")
  case type Diverges.no
  case int Diverges.no
  case string Diverges.no
  case struct_ Diverges.no
  case enum_ Diverges.no
  case lambda Diverges.no
  case member Diverges.no
  case switch_(switch_) {
    var result = none[Diverges]()
    for case_ in switch_.cases do {
      var case_behavior = case_.value.diverges()
      result = some(
        switch result
        case some(existing_behavior) one_of(existing_behavior, case_behavior)
        case none case_behavior
      )
    }
    result or Diverges.yes
  }
  case call_fun(call)
    if call.return_type == type_never then Diverges.yes else Diverges.maybe
  case call_lambda(call)
    if call.lambda.type().kind().lambda.unwrap().return_type == type_never then
      Diverges.yes
    else
      Diverges.maybe
  case call_builtin
    | Note: We don't care about a precise assessment here because builtins are
    | immediately desugared into more specific expressions anyways.
    Diverges.maybe
  case cast Diverges.no
  case byte Diverges.no
  case lower_byte Diverges.no
  case byte_to_int Diverges.no
  case add Diverges.no
  case subtract Diverges.no
  case multiply Diverges.no
  case divide Diverges.maybe
  case modulo Diverges.maybe
  case and_ Diverges.no
  case or_ Diverges.no
  case xor Diverges.no
  case compare Diverges.no
  case unchecked_divide Diverges.no
  case unchecked_modulo Diverges.no
  case box Diverges.no
  case unbox Diverges.no
  case array Diverges.no
  case generate_array Diverges.maybe
  case array_get Diverges.maybe
  case array_set Diverges.maybe
  case array_slice Diverges.maybe
  case array_len Diverges.no
  | case unchecked_generate_non_empty_array(gen)
  |   merge(gen.a.diverges(), gen.b.expr.diverges())
  | case unchecked_array_get(args) merge(args.a.diverges(), args.b.diverges())
  | case unchecked_array_set(args)
  |   merge(args.a.diverges(), args.b.diverges(), args.c.diverges())
  | case unchecked_array_slice(args)
  |   merge(args.a.diverges(), args.b.diverges(), args.c.diverges())
  | case type_info Diverges.no
  case static_to_dynamic Diverges.no
  case dynamic_to_static Diverges.maybe
  case crash Diverges.yes
  case unreachable Diverges.maybe
  default Diverges.maybe
}
fun diverges(ids: Slice[EggId]): Diverges {
  var result = Diverges.no
  for id in ids do result = merge(result, id.diverges())
  result
}
