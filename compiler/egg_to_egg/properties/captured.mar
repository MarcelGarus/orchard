import mod.mar

fun captured(id: EggId): Set[EggId] {
  var out = set[EggId]()
  id.visit(CollectCaptured { ignore = set[EggId]().&, out = out.& })
  out
}
fun captured(body: EggBody): Set[EggId] {
  var out = set[EggId]()
  body.visit(CollectCaptured { ignore = set[EggId]().&, out = out.& })
  out
}
fun uses_params(body: EggBody): Bool {
  var collect = CollectCaptured { ignore = set[EggId]().&, out = set[EggId]().& }
  for child in body.children do {
    child.visit(collect)
    collect.ignore.put(child)
  }
  collect.add(body.returns)
  for param in body.params do
    if collect.out.contains(param) then return true
  false
}

struct CollectCaptured { ignore: &Set[EggId], out: &Set[EggId] }
fun add(collect: CollectCaptured, id: EggId) {
  if not(collect.ignore.contains(id)) then collect.out.put(id)
}
fun visit(body: EggBody, collect: CollectCaptured) {
  for param in body.params do collect.ignore.put(param)
  for child in body.children do {
    child.visit(collect)
    collect.ignore.put(child)
  }
  collect.add(body.returns)
}
fun visit(id: EggId, collect: CollectCaptured) {
  switch id.resolve()
  case param panic("param")
  case case_param panic("case param")
  case type {}
  case int {}
  case string {}
  case struct_(fields) for field in fields do collect.add(field.value)
  case enum_(enum_) collect.add(enum_.payload)
  case lambda(body) body.visit(collect)
  case raw_lambda(lambda) collect.add(lambda.closure)
  case member(member) collect.add(member.of)
  case switch_(switch_) {
    collect.add(switch_.condition)
    for case_ in switch_.cases do case_.value.visit(collect)
  }
  case call_fun(call) for arg in call.args do collect.add(arg)
  case call_lambda(call) {
    collect.add(call.lambda)
    for arg in call.args do collect.add(arg)
  }
  case call_builtin(call) for arg in call.args do collect.add(arg)
  case cast(cast) collect.add(cast.what)
  case byte {}
  case lower_byte(arg)  collect.add(arg)
  case byte_to_int(arg) collect.add(arg)
  case add(args)      { collect.add(args.a)  collect.add(args.b) }
  case subtract(args) { collect.add(args.a)  collect.add(args.b) }
  case multiply(args) { collect.add(args.a)  collect.add(args.b) }
  case divide(args)   { collect.add(args.a)  collect.add(args.b) }
  case modulo(args)   { collect.add(args.a)  collect.add(args.b) }
  case and_(args)     { collect.add(args.a)  collect.add(args.b) }
  case or_(args)      { collect.add(args.a)  collect.add(args.b) }
  case xor(args)      { collect.add(args.a)  collect.add(args.b) }
  case compare(args)  { collect.add(args.a)  collect.add(args.b) }
  case unchecked_divide(args) { collect.add(args.a)  collect.add(args.b) }
  case unchecked_modulo(args) { collect.add(args.a)  collect.add(args.b) }
  case box(arg)   collect.add(arg)
  case unbox(arg) collect.add(arg)
  case array(array) for item in array.items do collect.add(item)
  case generate_array(args) {
    collect.add(args.length)
    args.generator.visit(collect)
  }
  case array_get(args) { collect.add(args.array)  collect.add(args.index) }
  case array_set(args) {
    collect.add(args.array)
    collect.add(args.index)
    collect.add(args.item)
  }
  case array_slice(args) {
    collect.add(args.array)
    collect.add(args.start)
    collect.add(args.end)
  }
  case array_len(arg) collect.add(arg)
  case unchecked_generate_non_empty_array(args) {
    collect.add(args.length)
    args.generator.visit(collect)
  }
  case unchecked_array_get(args) {
    collect.add(args.array)
    collect.add(args.index)
  }
  case unchecked_array_set(args) {
    collect.add(args.array)
    collect.add(args.index)
    collect.add(args.item)
  }
  case unchecked_array_slice(args) {
    collect.add(args.array)
    collect.add(args.start)
    collect.add(args.end)
  }
  case type_info(arg) collect.add(arg)
  case static_to_dynamic(static) collect.add(static)
  case dynamic_to_static(convert) collect.add(convert.dynamic)
  case crash(crash) collect.add(crash.message)
  case unreachable {}
  case recursive(rec) {
    for arg in rec.initial do collect.add(arg)
    rec.body.visit(collect)
  }
  case recurse(rec) for arg in rec.next do collect.add(arg)
}
