import mod.mar

fun choose_optimization_order(egg: Egg): Slice[String] {
  var rev_order = list[String]()
  egg.entry_point.visit(ChooseOrder { egg, rev_order = rev_order.& })
  var order = list[String]()
  for signature in rev_order.to_slice().rev_iter() do order.&.push(signature)
  order.to_slice()
}
struct ChooseOrder { egg: Egg, rev_order: &List[String] }
fun visit(signature: String, choose: ChooseOrder) {
  eprintln("order {signature}")
  if choose.rev_order.iter().&.contains(signature) then return {}
  choose.rev_order.push(signature)
  choose.egg.funs.get(signature).body.visit(choose).ignore()
}
fun visit(id: EggId, choose: ChooseOrder) {
  if id.resolve() is call_fun(call) then call.fun_.visit(choose)
  id.visit_children(choose)
}
