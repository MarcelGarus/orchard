import mod.mar

fun visit[V](fun_: EggFun, visitor: V) {
  fun_.body.visit(visitor, visit[EggId, EggId]().&)
}

fallback fun visit[V](body: EggBody, visitor: V) {
  for child in body.children do child.visit(visitor)
}

fun visit_children[V](id: EggId, visitor: V) {
  switch id.resolve()
  case param panic("param")
  case type {}
  | case byte {}
  case int {}
  case string {}
  | case array(items) TacoOp.array(items.visit(visitor)).expr(expr.type)
  case struct_(fields) {}
  case enum_(enum_) {}
  case lambda(body) body.visit(visitor)
  | case box(inner) builder.box(inner.visit(visitor, builder))
  case member(member) {}
  case switch_(switch_) {
    for case_ in switch_.cases do case_.value.visit(visitor)
  }
  case call_fun(call) {}
  case call_lambda(call) {}
  case call_builtin(call) {}
  case cast(cast) {}
  | case lower_byte(int) lower_byte(int.visit(visitor))
  | case byte_to_int(byte) byte_to_int(byte.visit(visitor))
  | case add(args) add(args.a.visit(visitor), args.b.visit(visitor))
  | case subtract(args) subtract(args.a.visit(visitor), args.b.visit(visitor))
  | case multiply(args) multiply(args.a.visit(visitor), args.b.visit(visitor))
  | case divide(args) divide(args.a.visit(visitor), args.b.visit(visitor))
  | case modulo(args) modulo(args.a.visit(visitor), args.b.visit(visitor))
  | case and_(args) and_(args.a.visit(visitor), args.b.visit(visitor))
  | case or_(args) or_(args.a.visit(visitor), args.b.visit(visitor))
  | case xor(args) xor(args.a.visit(visitor), args.b.visit(visitor))
  | case compare(args) compare(args.a.visit(visitor), args.b.visit(visitor))
  | case unchecked_divide(args)
  |   unchecked_divide(args.a.visit(visitor), args.b.visit(visitor))
  | case unchecked_modulo(args)
  |   unchecked_modulo(args.a.visit(visitor), args.b.visit(visitor))
  | case unbox(box) unbox(box.visit(visitor))
  | case generate_array(gen) generate_array(gen.a.visit(visitor), gen.b.visit(visitor))
  | case array_get(args) array_get(args.a.visit(visitor), args.b.visit(visitor))
  | case array_set(args)
  |   array_set(args.a.visit(visitor), args.b.visit(visitor), args.c.visit(visitor))
  | case array_slice(args)
  |   array_slice(args.a.visit(visitor), args.b.visit(visitor), args.c.visit(visitor))
  | case array_len(array) array_len(array.visit(visitor))
  | case unchecked_generate_non_empty_array(gen)
  |   unchecked_generate_non_empty_array(gen.a.visit(visitor), gen.b.visit(visitor))
  | case unchecked_array_get(args)
  |   unchecked_array_get(args.a.visit(visitor), args.b.visit(visitor))
  | case unchecked_array_set(args)
  |   unchecked_array_set(
  |     args.a.visit(visitor), args.b.visit(visitor), args.c.visit(visitor)
  |   )
  | case unchecked_array_slice(args)
  |   unchecked_array_slice(
  |     args.a.visit(visitor), args.b.visit(visitor), args.c.visit(visitor)
  |   )
  | case crash expr
  | case type_info(type) type_info(type.visit(visitor))
  | case static_to_dynamic(static) static_to_dynamic(static.visit(visitor))
  | case dynamic_to_static(dyn) dynamic_to_static(dyn.visit(visitor), expr.type)
  | case recursive(rec) recursive(rec.a.visit(visitor), rec.b.visit(visitor))
  | case recurse(args) recurse(args.visit(visitor), expr.type)
  | case unreachable expr
}
