import mod.mar

fun map[M](fun_: EggFun, mapper: M): EggFun {
  EggFun { body = fun_.body.map(mapper, map[EggId, EggId]().&) }
}

fallback fun map[M](
  body: EggBody, mapper: M, mapping: &Map[EggId, EggId]
): EggBody {
  body.map_children(mapper, mapping)
}

fun map_children[M](
  body: EggBody, mapper: M, mapping: &Map[EggId, EggId]
): EggBody {
  var builder = egg_body_builder().&
  for old in body.params do {
    var new = builder.param(old.type())
    mapping.put(old, new)
  }
  for old in body.children do {
    var new = old.map(mapper, builder, mapping)
    mapping.put(old, new)
  }
  builder.finish(body.returns.map(mapping))
}

fun map_children[M](
  id: EggId, mapper: M, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]
): EggExpr {
  switch id.resolve()
  case param unreachable()
  case type(type) EggExpr.type(type)
  case int(int) EggExpr.int(int)
  case string(string) EggExpr.string(string)
  case struct_(struct_) {
    var fields = map[String, EggId]()
    for field in struct_ do fields.&.put(field.key, field.value.map(mapping))
    EggExpr.struct_(fields)
  }
  case enum_(enum_)
    EggExpr.enum_(EggEnum {
      type = enum_.type,
      variant = enum_.variant,
      payload = enum_.payload.map(mapping),
    })
  case lambda(body) EggExpr.lambda(body.map(mapper, mapping))
  case member(member)
    EggExpr.member(EggMember {
      of = member.of.map(mapping), name = member.name
    })
  case switch_(switch_) {
    var condition = switch_.condition.map(mapping)
    var cases = map[String, EggBody]()
    for case_ in switch_.cases do
      cases.&.put(case_.key, case_.value.map(mapper, mapping))
    EggExpr.switch_(EggSwitch { condition, type = switch_.type, cases })
  }
  case call_fun(call)
    EggExpr.call_fun(EggCallFun {
      fun_ = call.fun_,
      substitutions = call.substitutions,
      args = call.args.map(mapping),
      return_type = call.return_type,
    })
  case call_lambda(call)
    EggExpr.call_lambda(EggCallLambda {
      lambda = call.lambda.map(mapping), args = call.args.map(mapping)
    })
  case call_builtin(call)
    EggExpr.call_builtin(EggCallBuiltin {
      builtin = call.builtin,
      substitutions = call.substitutions,
      args = call.args.map(mapping),
    })
  case cast(cast)
    EggExpr.cast(EggCast { what = cast.what.map(mapping), type = cast.type })
  case byte(byte) EggExpr.byte(byte)
  case lower_byte(arg) EggExpr.lower_byte(arg.map(mapping))
  case byte_to_int(arg) EggExpr.byte_to_int(arg.map(mapping))
  case add(args) EggExpr.add(tuple(args.a.map(mapping), args.b.map(mapping)))
  case subtract(args)
    EggExpr.subtract(tuple(args.a.map(mapping), args.b.map(mapping)))
  case multiply(args)
    EggExpr.multiply(tuple(args.a.map(mapping), args.b.map(mapping)))
  case divide(args)
    EggExpr.divide(tuple(args.a.map(mapping), args.b.map(mapping)))
  case modulo(args)
    EggExpr.modulo(tuple(args.a.map(mapping), args.b.map(mapping)))
  case and_(args) EggExpr.and_(tuple(args.a.map(mapping), args.b.map(mapping)))
  case or_(args) EggExpr.or_(tuple(args.a.map(mapping), args.b.map(mapping)))
  case xor(args) EggExpr.xor(tuple(args.a.map(mapping), args.b.map(mapping)))
  case compare(args)
    EggExpr.compare(tuple(args.a.map(mapping), args.b.map(mapping)))
  case unchecked_divide(args)
    EggExpr.unchecked_divide(tuple(args.a.map(mapping), args.b.map(mapping)))
  case unchecked_modulo(args)
    EggExpr.unchecked_modulo(tuple(args.a.map(mapping), args.b.map(mapping)))
  case box(arg) EggExpr.box(arg.map(mapping))
  case unbox(arg) EggExpr.unbox(arg.map(mapping))
  case array(array)
    EggExpr.array(EggArray {
      items = array.items.map(mapping), item_type = array.item_type
    })
  case generate_array(args)
    EggExpr.generate_array(EggGenerateArray {
      length = args.length.map(mapping),
      generator = args.generator.map(mapper, mapping),
    })
  case array_get(args)
    EggExpr.array_get(EggArrayGet {
      array = args.array.map(mapping), index = args.index.map(mapping)
    })
  case array_set(args)
    EggExpr.array_set(EggArraySet {
      array = args.array.map(mapping),
      index = args.index.map(mapping),
      item = args.item.map(mapping),
    })
  case array_slice(args)
    EggExpr.array_slice(EggArraySlice {
      array = args.array.map(mapping),
      start = args.start.map(mapping),
      end = args.end.map(mapping),
    })
  case array_len(arg) EggExpr.array_len(arg.map(mapping))
  case unchecked_generate_non_empty_array(args)
    EggExpr.unchecked_generate_non_empty_array(EggGenerateArray {
      length = args.length.map(mapping),
      generator = args.generator.map(mapper, mapping),
    })
  case unchecked_array_get(args)
    EggExpr.unchecked_array_get(EggArrayGet {
      array = args.array.map(mapping), index = args.index.map(mapping)
    })
  case unchecked_array_set(args)
    EggExpr.unchecked_array_set(EggArraySet {
      array = args.array.map(mapping),
      index = args.index.map(mapping),
      item = args.item.map(mapping),
    })
  case unchecked_array_slice(args)
    EggExpr.unchecked_array_slice(EggArraySlice {
      array = args.array.map(mapping),
      start = args.start.map(mapping),
      end = args.end.map(mapping),
    })
  case type_info(arg) EggExpr.type_info(arg.map(mapping))
  case static_to_dynamic(arg) EggExpr.static_to_dynamic(arg.map(mapping))
  case dynamic_to_static(convert)
    EggExpr.dynamic_to_static(EggDynamicToStatic {
      dynamic = convert.dynamic.map(mapping), static = convert.static
    })
  case crash(crash)
    EggExpr.crash(EggCrash {
      message = crash.message.map(mapping), type = crash.type
    })
  case unreachable(type) EggExpr.unreachable(type)
  case recursive(rec)
    EggExpr.recursive(EggRecursive {
      initial = rec.initial.map(mapping), body = rec.body.map(mapper, mapping)
    })
  case recurse(rec)
    EggExpr.recurse(EggRecurse {
      next = rec.next.map(mapping), type = rec.type
    })
}

fun map(id: EggId, mapping: &Map[EggId, EggId]): EggId {
  mapping.get_maybe(id) or id
}
fun map(ids: Slice[EggId], mapping: &Map[EggId, EggId]): Slice[EggId] {
  var new = list[EggId]()
  for old in ids do new.&.push(old.map(mapping))
  new.to_slice()
}
