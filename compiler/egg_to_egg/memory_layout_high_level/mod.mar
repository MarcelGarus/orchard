import ../mod.mar
import dup_drop_free.mar

fun mem_layout_high_level(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do {
    | eprintln("mem_layout_high_level {fun_.key}")
    funs.&.put(fun_.key, fun_.value.mem_layout_high_level(funs.&))
  }
  Egg { entry_point = egg.entry_point, funs }
}

fun mem_layout_high_level(fun_: EggFun, funs: &Map[String, EggFun]): EggFun {
  | TODO: Turn this into a separate pass?
  | From now on, functions accept a struct containing all arguments. So here,
  | we build a type for that.
  | var param_type = {
  |   var param_types = map[String, EggType]()
  |   for param in fun_.body.params.iter().enumerate() do
  |     param_types.&.put("{param.index}", param.item.type())
  |   type_struct(param_types)
  | }

  | var builder = egg_body_builder().&
  | var mapping = map[EggId, EggId]().&
  fun_.map(MemLayoutHighLevel { funs })

  | for param in fun_.body.params.iter().enumerate() do
  |   mapping.put(param.item, builder.member(builder.param, "{param.index}"))
  | var body = builder.finish(fun_.body.map(MemLayoutHighLevel {}, builder, mapping))
}

struct MemLayoutHighLevel { funs: &Map[String, EggFun] }

| Converts a body to Egg. Assumes that mappings for the parameters have
| already been added.
| fun map(
|   body: EggBody,
|   layout: MemLayoutHighLevel,
|   builder: &EggBodyBuilder,
|   mapping: &Map[EggId, EggId],
| ): EggId {
|   for id in body.children do
|     mapping.put(id, id.map(layout, builder, mapping))
|   mapping.get(body.returns)
| }

fun map(
  id: EggId,
  layout: MemLayoutHighLevel,
  builder: &EggBodyBuilder,
  mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.resolve()

  switch expr
  case param(type) builder.param(type)
  case dup(dup) {
    builder.desugared_dup(mapping.get(dup.id), dup.type)
    builder.nothing()
  }
  case drop(dup) {
    builder.desugared_drop(mapping.get(dup.id), dup.type, layout.funs)
    builder.nothing()
  }
  case enum_(enum_) {
    var payload = mapping.get(enum_.payload)
    if enum_.type.kind().enum_.unwrap().get(enum_.variant)
      .is_unboxed_recursive()
    then
      payload = builder.new(payload)
    builder.enum_(enum_.type, enum_.variant, payload)
  }
  case switch_(switch_) {
    var condition = mapping.get(switch_.condition)
    var cases = map[String, EggBody]()
    for case_ in switch_.cases do {
      var variant = case_.key
      var case_ = case_.value
      var builder = egg_body_builder().&

      var payload_type = condition.type().kind().enum_.unwrap().get(variant)
      var payload = builder.param(payload_type)
      if payload_type.is_unboxed_recursive() then
        payload = builder.load(payload, payload_type)
      mapping.put(case_.params.get(0), payload)

      for child in case_.children do
        mapping.put(child, child.map(layout, builder, mapping))

      var body = builder.finish(case_.returns.map(mapping.*))
      cases.&.put(variant, body)
    }
    builder.switch_(condition, switch_.type, cases)
  }
  case raw_lambda(lambda) {
    var closure_ptr = mapping.get(lambda.closure)
    var lambda_body_fun_ptr = builder.function_ptr(lambda.fun_)
    var free_fun_ptr = builder.function_ptr(
      free_box_fun(lambda.closure.type().kind().box.unwrap(), layout.funs)
    )
    builder.struct_(map(
      "closure" -> closure_ptr,
      "body" -> lambda_body_fun_ptr,
      "free" -> free_fun_ptr,
    ))
  }
  case call_fun(call) {
    | var args = map[String, EggId]()
    | for arg in call.args.iter().enumerate() do
    |   args.&.put("{arg.index}", mapping.get(arg.item))
    | var args = builder.struct_(args)

    builder.call(call.fun_, call.substitutions, call.args, call.return_type)
  }
  case call_lambda(call) {
    var lambda = mapping.get(call.lambda)
    var closure_ptr = builder.member(lambda, "closure")
    var body_ptr = builder.member(lambda, "body")

    | var args = map[String, EggId]()
    | for arg in call.args.iter().enumerate() do
    |   args.&.put("{arg.index}", mapping.get(arg.item))
    | args.&.put("{call.args.len}", closure_ptr)
    | var args = builder.struct_(args)

    builder.call_indirect(
      body_ptr,
      call.args.map(mapping.*),
      call.lambda.type().kind().lambda.unwrap().return_type,
    )
  }
  case unbox(box) {
    var box_type = box.type()
    var inner_type = box_type.kind().box.unwrap()
    var inner = builder.load(
      mapping.get(box), inner_type
    )
    builder.desugared_dup(inner, inner_type)
    builder.desugared_drop(mapping.get(box), box_type, layout.funs)
    inner
  }
  case array(array) {
    | Special case arrays of byte literals.
    var all_bytes = true
    for item in array.items do
      if not(item.resolve() is byte) then all_bytes = false
    if all_bytes then {
      var buffer = builder.new_buffer(type_byte, builder.int(array.items.len))
      var bytes = list[Byte]()
      for byte in array.items do bytes.&.push(byte.resolve().byte.unwrap())
      builder.store_buffer_bytes(buffer, bytes.to_slice())
      return builder.struct_(map(
        "buffer" -> buffer,
        "start" -> builder.int(0),
        "end" -> builder.int(array.items.len),
      ))
    }
    
    var buffer = builder.new_buffer(
      array.item_type, builder.int(array.items.len)
    )
    for item in array.items.iter().enumerate() do
      builder.store_buffer_item(
        buffer, array.item_type, builder.int(item.index), mapping.get(item.item)
      )
    builder.struct_(map(
      "buffer" -> buffer,
      "start" -> builder.int(0),
      "end" -> builder.int(array.items.len),
    ))
  }
  case generate_array(gen) {
    var length = mapping.get(gen.length)
    var item_type = gen.generator.returns.type()
    var buffer = builder.new_buffer(item_type, length)
    builder.loop_(list(builder.int(0)).to_slice(), {
      var builder = egg_body_builder().&
      var cursor = builder.param(type_int)
      mapping.put(gen.generator.params.get(0), cursor)
      builder.finish(builder.switch_on_ordering(
        builder.compare(cursor, length),
        {
          var builder = egg_body_builder().&
          var generated = gen.generator.map(layout, mapping)
          for child in generated.children do builder.push(child)
          var item = generated.returns
          builder.store_buffer_item(buffer, item_type, cursor, item)
          builder.finish(
            builder.continue_(
              list(builder.add(cursor, builder.int(1))).to_slice(),
              type_nothing,
            )
          )
        },
        egg_body_builder().finish_with_nothing(),
        egg_body_builder().finish_with_unreachable(type_nothing),
      ))
    })
    builder.struct_(map(
      "buffer" -> buffer,
      "start" -> builder.int(0),
      "end" -> length,
    ))
  }
  case array_len(array) {
    var array_type = array.type()
    var array = mapping.get(array)
    var length = builder.subtract(
      builder.member(array, "end"),
      builder.member(array, "start"),
    )
    builder.desugared_drop(array, array_type, layout.funs)
    return length
  }
  case array_get(args) {
    var array_type = args.array.type()
    var item_type = array_type.kind().array.unwrap()
    var array = mapping.get(args.array)
    var index = mapping.get(args.index)
    var item = builder.load_buffer_item(
      builder.member(array, "buffer"),
      item_type,
      builder.add(builder.member(array, "start"), index),
    )
    builder.desugared_dup(item, item_type)
    builder.desugared_drop(array, array_type, layout.funs)
    item
  }
  case array_set(args) {
    var array_type = args.array.type()
    var item_type = array_type.kind().array.unwrap()
    var array = mapping.get(args.array)
    var index = mapping.get(args.index)
    var item = mapping.get(args.item)
    var buffer = builder.member(array, "buffer")
    var start = builder.member(array, "start")
    var end = builder.member(array, "end")

    | If the buffer's reference count is 1, we have exclusive ownership and can
    | mutate the buffer in place. Otherwise, we copy the part of the buffer that
    | this array points to, and then we set the item in that copy.
    var owned_array = builder.switch_on_ordering(
      builder.compare(builder.get_refcount(buffer), builder.int(1)),
      egg_body_builder().finish_with_unreachable(array_type),
      egg_body_builder().finish(array),
      {
        var builder = egg_body_builder().&
        var length = builder.subtract(end, start)
        var copy = builder.new_buffer(item_type, length)
        builder.decrement_refcount(buffer)
        builder.loop_(builder.int(0), {
          var builder = egg_body_builder().&
          var cursor = builder.param(type_int)
          builder.finish(builder.switch_on_ordering(
            builder.compare(cursor, length),
            {
              var builder = egg_body_builder().&
              var item = builder.load_buffer_item(
                buffer, item_type, builder.add(start, cursor)
              )
              builder.store_buffer_item(copy, item_type, cursor, item)
              builder.finish(builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                array_type,
              ))
            },
            egg_body_builder().finish(copy),
            egg_body_builder().finish_with_unreachable(array_type),
          ))
        })
        builder.finish(builder.struct_(map(
          "buffer" -> copy,
          "start" -> builder.int(0),
          "length" -> length,
        )))
      },
    )

    var offset = builder.add(start, index)
    var previous = builder.load_buffer_item(buffer, item_type, offset)
    builder.drop(previous, item_type)
    builder.store_buffer_item(buffer, offset, item)
    owned_array
  }
  case array_slice(args) {
    var array = mapping.get(args.a)
    var start = mapping.get(args.b)
    var end = mapping.get(args.c)
    var old_start = builder.member(array, "start")
    builder.struct_(map(
      "buffer" -> builder.member(array, "buffer"),
      "start" -> builder.add(old_start, start),
      "end" -> builder.add(old_start, end),
    ))
  }
  case type builder.nothing()
  default builder.push(id.map_children(layout, mapping))
}










fun lower_arrays(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do {
    funs.&.put(fun_.key, fun_.value.lower_arrays())
  }
  Egg { entry_point = egg.entry_point, funs }
}

fun lower_arrays(fun_: EggFun): EggFun { fun_.map(LowerArrays {}) }

struct LowerArrays {}

fun map(
  id: EggId,
  lower: LowerArrays,
  builder: &EggBodyBuilder,
  mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.resolve()
  switch expr
  case array(array) {
    | Special case byte arrays.
    var all_bytes = true
    for item in array.items do
      if not(item.resolve() is byte) then all_bytes = false
    if all_bytes then {
      var buffer = builder.new_buffer(type_byte, builder.int(array.items.len))
      var bytes = list[Byte]()
      for byte in array.items do bytes.&.push(byte.resolve().byte.unwrap())
      builder.store_buffer_bytes(buffer, bytes.to_slice())
      return builder.struct_(map(
        "buffer" -> buffer,
        "start" -> builder.int(0),
        "end" -> builder.int(array.items.len),
      ))
    }
    
    var item_type = id.type().kind().array.unwrap()
    var buffer = builder.new_buffer(item_type, builder.int(array.items.len))
    for item in array.items.iter().enumerate() do
      builder.store_buffer_item(
        buffer,
        item.item.type(),
        builder.int(item.index),
        mapping.get(item.item),
      )
    builder.struct_(map(
      "buffer" -> buffer,
      "start" -> builder.int(0),
      "end" -> builder.int(array.items.len),
    ))
  }
  case generate_array(gen) {
    var length = mapping.get(gen.length)
    var generator = gen.generator
    var item_type = generator.returns.type()
    var buffer = builder.new_buffer(item_type, length)
    builder.loop_(list(builder.int(0)).to_slice(), {
      var builder = egg_body_builder().&
      var cursor = builder.param(type_int)
      builder.finish(builder.switch_(builder.compare(cursor, length), type_nothing, map(
        "less" -> {
          var builder = egg_body_builder().&
          builder.param(type_nothing)
          mapping.put(generator.params.get(0), cursor)
          for child in generator.children do child.map(lower, builder, mapping)
          var item = generator.returns.map(mapping.*)
          builder.store_buffer_item(buffer, item_type, cursor, item)
          builder.finish(
            builder.continue_(
              list(builder.add(cursor, builder.int(1))).to_slice(),
              type_nothing,
            )
          )
        },
        "equal" -> {
          var builder = egg_body_builder().&
          builder.param(type_nothing)
          builder.finish(builder.nothing())
        },
        "greater" -> {
          var builder = egg_body_builder().&
          builder.param(type_nothing)
          builder.finish(builder.unreachable(type_nothing))
        },
      )))
    })
    builder.struct_(map(
      "buffer" -> buffer,
      "start" -> builder.int(0),
      "end" -> length,
    ))
  }
  case array_len(array) {
    var array_type = array.type()
    var array = mapping.get(array)
    var length = builder.subtract(
      builder.member(array, "end"),
      builder.member(array, "start"),
    )
    builder.drop(array, array_type)
    return length
  }
  case array_get(args) {
    var array_type = args.a.type()
    var item_type = array_type.kind().array.unwrap()
    var array = mapping.get(args.a)
    var index = mapping.get(args.b)
    var item = builder.load_buffer_item(
      builder.member(array, "buffer"),
      type,
      builder.add(builder.member(array, "start"), index),
    )
    builder.dup(item, item_type)
    builder.drop(array, array_type)
    item
  }
  case array_set(args) {
    var item_type = args.a.type().kind().array.unwrap()
    var array = mapping.get(args.a)
    var index = mapping.get(args.b)
    var item = mapping.get(args.c)
    var buffer = builder.member(array, "buffer")
    var start = builder.member(array, "start")
    var end = builder.member(array, "end")

    | If the buffer's reference count is 1, we have exclusive ownership and can
    | mutate the buffer in place. Otherwise, we copy the part of the buffer that
    | this array points to, and then we set the item in that copy.
    var owned_array = builder.switch_(
      builder.compare(builder.get_refcount(buffer), builder.int(1)),
      map(
        "less" -> {
          var builder = egg_body_builder().&
          builder.param(type_nothing)
          builder.finish(builder.unreachable(pesto_array_type))
        },
        "equal" -> {
          var builder = egg_body_builder().&
          builder.param(type_nothing)
          builder.finish(array)
        },
        "greater" -> {
          var builder = egg_body_builder().&
          builder.param(type_nothing)
          var length = builder.subtract(end, start)
          var copy = builder.new_buffer(item_type.lower_arrays(), length)
          builder.decrement_refcount(buffer)
          builder.loop_(list(builder.int(0)).to_slice(), {
            var builder = egg_body_builder(PestoType.int).&
            var cursor = builder.param
            builder.finish(builder.switch_(
              builder.compare(cursor, length),
              map(
                "less" -> {
                  var builder = egg_body_builder(type_nothing).&
                  var item = builder.load_buffer_item(
                    buffer, item_type.lower_arrays(), builder.add(start, cursor)
                  )
                  builder.store_buffer_item(copy, cursor, item)
                  builder.finish(builder.continue_(
                    list(builder.add(cursor, builder.int(1))).to_slice(), PestoType.ptr
                  ))
                },
                "equal" ->
                  egg_body_builder(type_nothing).finish(copy),
                "greater" ->
                  egg_body_builder(type_nothing)
                    .finish_with_unreachable(PestoType.ptr),
              )
            ))
          })
          builder.finish(builder.struct_(map(
            "buffer" -> copy,
            "start" -> builder.int(0),
            "length" -> length,
          )))
        },
      ),
    )

    var offset = builder.add(start, index)
    var previous = builder.load_buffer_item(
      buffer, item_type.lower_arrays(), offset
    )
    builder.drop(previous, item_type)
    builder.store_buffer_item(buffer, offset, item)
    owned_array
  }
  case array_slice(args) {
    var array = mapping.get(args.a)
    var start = mapping.get(args.b)
    var end = mapping.get(args.c)
    var old_start = builder.member(array, "start")
    builder.struct_(map(
      "buffer" -> builder.member(array, "buffer"),
      "start" -> builder.add(old_start, start),
      "end" -> builder.add(old_start, end),
    ))
  }
  default builder.push(id.map_children(lower, mapping))
}














fun get(
  mapping: Map[EggId, EggId], tuple: Tuple2[EggId, EggId]
): Tuple2[EggId, EggId] {
  tuple(mapping.get(tuple.a), mapping.get(tuple.b))
}
