import ../mod.mar
import dup_drop_free.mar

fun mem_layout_high_level(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do {
    | eprintln("mem_layout_high_level {fun_.key}")
    funs.&.put(fun_.key, fun_.value.mem_layout_high_level(funs.&))
  }
  Egg { entry_point = egg.entry_point, funs }
}

fun mem_layout_high_level(fun_: EggFun, funs: &Map[String, EggFun]): EggFun {
  | TODO: Turn this into a separate pass?
  | From now on, functions accept a struct containing all arguments. So here,
  | we build a type for that.
  | var param_type = {
  |   var param_types = map[String, EggType]()
  |   for param in fun_.body.params.iter().enumerate() do
  |     param_types.&.put("{param.index}", param.item.type())
  |   type_struct(param_types)
  | }

  | var builder = egg_body_builder().&
  | var mapping = map[EggId, EggId]().&
  fun_.map(MemLayoutHighLevel { funs })

  | for param in fun_.body.params.iter().enumerate() do
  |   mapping.put(param.item, builder.member(builder.param, "{param.index}"))
  | var body = builder.finish(fun_.body.map(MemLayoutHighLevel {}, builder, mapping))
}

struct MemLayoutHighLevel { funs: &Map[String, EggFun] }

| Converts a body to Egg. Assumes that mappings for the parameters have
| already been added.
| fun map(
|   body: EggBody,
|   layout: MemLayoutHighLevel,
|   builder: &EggBodyBuilder,
|   mapping: &Map[EggId, EggId],
| ): EggId {
|   for id in body.children do
|     mapping.put(id, id.map(layout, builder, mapping))
|   mapping.get(body.returns)
| }

fun map(
  id: EggId,
  layout: MemLayoutHighLevel,
  builder: &EggBodyBuilder,
  mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.resolve()

  switch expr
  case param(type) builder.param(type.to_pesto())
  case unchecked_divide(args) {
    eprintln("mapping {pretty(id, namespace().&)}: {id.resolve().debug()}:")
    eprint("mapping:")
    for entry in mapping do eprint(" {pretty(entry.key, namespace().&)}: {pretty(entry.value, namespace().&)}")
    eprintln()
    builder.push(id.map_children(layout, mapping))
  }
  case multiply(args) {
    eprintln("mapping {pretty(id, namespace().&)}: {id.resolve().debug()}")
    eprint("mapping:")
    for entry in mapping do eprint(" {pretty(entry.key, namespace().&)}: {pretty(entry.value, namespace().&)}")
    eprintln()
    builder.push(id.map_children(layout, mapping))
  }
  case dup(dup) {
    builder.desugared_dup(dup.id.map(mapping.*), dup.type)
    builder.nothing()
  }
  case drop(drop) {
    builder.desugared_drop(drop.id.map(mapping.*), drop.type, layout.funs)
    builder.nothing()
  }
  case enum_(enum_) {
    var payload = enum_.payload.map(mapping.*)
    if enum_.type.kind().enum_.unwrap().get(enum_.variant)
      .is_unboxed_recursive()
    then
      payload = builder.new(payload)
    builder.enum_(enum_.type, enum_.variant, payload)
  }
  case switch_(switch_) {
    var condition = switch_.condition.map(mapping.*)
    var cases = map[String, EggBody]()
    for case_ in switch_.cases do {
      var variant = case_.key
      var case_ = case_.value
      var builder = egg_body_builder().&

      var payload_type = condition.type().kind().enum_.unwrap().get(variant)
      var payload = builder.param(payload_type)
      if payload_type.is_unboxed_recursive() then
        payload = builder.load(payload, payload_type.to_pesto())
      mapping.put(case_.params.get(0), payload)

      for child in case_.children do
        mapping.put(child, child.map(layout, builder, mapping))

      var body = builder.finish(case_.returns.map(mapping.*))
      cases.&.put(variant, body)
    }
    builder.switch_(condition, cases)
  }
  case raw_lambda(lambda)
    builder.struct_(map(
      "closure" -> lambda.closure.map(mapping.*),
      "body" -> builder.function_ptr(lambda.fun_),
      "free" -> builder.function_ptr(
        free_box_fun(lambda.closure.type().kind().box.unwrap(), layout.funs)
      ),
    ))
  case call_fun(call) {
    | var args = map[String, EggId]()
    | for arg in call.args.iter().enumerate() do
    |   args.&.put("{arg.index}", mapping.get(arg.item))
    | var args = builder.struct_(args)

    builder.call(
      call.fun_, call.args.map(mapping.*), call.return_type.to_pesto()
    )
  }
  case call_lambda(call) {
    var lambda = call.lambda.map(mapping.*)
    var closure_ptr = builder.member(lambda, "closure")
    var body_ptr = builder.member(lambda, "body")

    | var args = map[String, EggId]()
    | for arg in call.args.iter().enumerate() do
    |   args.&.put("{arg.index}", mapping.get(arg.item))
    | args.&.put("{call.args.len}", closure_ptr)
    | var args = builder.struct_(args)

    builder.call_indirect(
      body_ptr,
      call.args.map(mapping.*),
      call.lambda.type().kind().lambda.unwrap().return_type.to_pesto(),
    )
  }
  case box(value) {
    builder.new(value.map(mapping.*))
  }
  case unbox(box) {
    var box_type = box.type()
    var box = box.map(mapping.*)
    var inner_type = box_type.kind().box.unwrap()
    var inner = builder.load(box, inner_type.to_pesto())
    builder.desugared_dup(inner, inner_type)
    builder.desugared_drop(box, box_type, layout.funs)
    inner
  }
  case array(array) {
    | Special case byte arrays.
    var all_bytes = true
    for item in array.items do
      if not(item.resolve() is byte) then all_bytes = false
    if all_bytes then {
      var buffer = builder.new_buffer(
        type_byte.to_pesto(), builder.int(array.items.len)
      )
      var bytes = list[Byte]()
      for byte in array.items do bytes.&.push(byte.resolve().byte.unwrap())
      builder.store_buffer_bytes(buffer, bytes.to_slice())
      return builder.struct_(map(
        "buffer" -> buffer,
        "start" -> builder.int(0),
        "end" -> builder.int(array.items.len),
      ))
    }

    var item_type = id.type().kind().array.unwrap()
    var buffer = builder.new_buffer(
      item_type.to_pesto(), builder.int(array.items.len)
    )
    for item in array.items.iter().enumerate() do
      builder.store_buffer_item(
        buffer,
        item.item.type().to_pesto(),
        builder.int(item.index),
        item.item.map(mapping.*),
      )
    builder.struct_(map(
      "buffer" -> buffer,
      "start" -> builder.int(0),
      "end" -> builder.int(array.items.len),
    ))
  }
  case unchecked_generate_non_empty_array(gen) {
    var length = gen.length.map(mapping.*)
    var generator = gen.generator
    var item_type = generator.returns.type()
    var buffer = builder.new_buffer(item_type.to_pesto(), length)
    builder.loop_(list(builder.int(0)).to_slice(), {
      var builder = egg_body_builder().&
      var cursor = builder.param(type_int)
      builder.finish(
        builder.switch_on_ordering(
          builder.compare(cursor, length),
          {
            var builder = egg_body_builder().&
            mapping.put(generator.params.get(0), cursor)
            for child in generator.children do
              mapping.put(child, child.map(layout, builder, mapping))
            var item = generator.returns.map(mapping.*)
            builder.store_buffer_item(buffer, item_type.to_pesto(), cursor, item)
            builder.finish(
              builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                type_nothing.to_pesto(),
              )
            )
          },
          egg_body_builder().finish_with_nothing(),
          egg_body_builder().finish_with_unreachable(type_nothing.to_pesto()),
        )
      )
    })
    builder.struct_(map(
      "buffer" -> buffer, "start" -> builder.int(0), "end" -> length
    ))
  }
  case array_len(array) {
    var array_type = array.type()
    var array = array.map(mapping.*)
    var length = builder.subtract(
      builder.member(array, "end"), builder.member(array, "start")
    )
    builder.drop(array, array_type)
    return length
  }
  case unchecked_array_get(args) {
    var array_type = args.array.type()
    var item_type = array_type.kind().array.unwrap()
    var array = args.array.map(mapping.*)
    var index = args.index.map(mapping.*)
    var item = builder.load_buffer_item(
      builder.member(array, "buffer"),
      item_type.to_pesto(),
      builder.add(builder.member(array, "start"), index),
    )
    builder.dup(item, item_type)
    builder.drop(array, array_type)
    item
  }
  case unchecked_array_set(args) {
    var array_type = args.array.type()
    var item_type = array_type.kind().array.unwrap()
    var array = args.array.map(mapping.*)
    var index = args.index.map(mapping.*)
    var item = args.item.map(mapping.*)
    var buffer = builder.member(array, "buffer")
    var start = builder.member(array, "start")
    var end = builder.member(array, "end")

    | If the buffer's reference count is 1, we have exclusive ownership and can
    | mutate the buffer in place. Otherwise, we copy the part of the buffer that
    | this array points to, and then we set the item in that copy.
    var owned_array = builder.switch_on_ordering(
      builder.compare(builder.get_refcount(buffer), builder.int(1)),
      egg_body_builder().finish_with_unreachable(array_type.to_pesto()),
      egg_body_builder().finish(array),
      {
        var builder = egg_body_builder().&
        var length = builder.subtract(end, start)
        var copy = builder.new_buffer(item_type.to_pesto(), length)
        builder.decrement_refcount(buffer)
        builder.loop_(list(builder.int(0)).to_slice(), {
          var builder = egg_body_builder().&
          var cursor = builder.param(type_int)
          builder.finish(builder.switch_on_ordering(
            builder.compare(cursor, length),
            {
              var builder = egg_body_builder().&
              var item = builder.load_buffer_item(
                buffer, item_type.to_pesto(), builder.add(start, cursor)
              )
              builder.store_buffer_item(
                copy, item_type.to_pesto(), cursor, item
              )
              builder.finish(builder.continue_(
                list(builder.add(cursor, builder.int(1))).to_slice(),
                PestoType.ptr,
              ))
            },
            egg_body_builder().finish(copy),
            egg_body_builder().finish_with_unreachable(PestoType.ptr),
          ))
        })
        builder.finish(builder.struct_(map(
          "buffer" -> copy, "start" -> builder.int(0), "length" -> length
        )))
      },
    )

    var offset = builder.add(start, index)
    var previous = builder.load_buffer_item(
      buffer, item_type.to_pesto(), offset
    )
    builder.drop(previous, item_type)
    builder.store_buffer_item(buffer, item_type.to_pesto(), offset, item)
    owned_array
  }
  case array_slice(args) {
    var array = args.array.map(mapping.*)
    var start = args.start.map(mapping.*)
    var end = args.end.map(mapping.*)
    var old_start = builder.member(array, "start")
    builder.struct_(map(
      "buffer" -> builder.member(array, "buffer"),
      "start" -> builder.add(old_start, start),
      "end" -> builder.add(old_start, end),
    ))
  }
  case type builder.nothing()
  case crash(crash)
    builder.crash(crash.message.map(mapping.*), crash.type.to_pesto())
  case unreachable(type) builder.unreachable(type.to_pesto())
  case continue_(continue_)
    builder.continue_(continue_.next.map(mapping.*), continue_.type.to_pesto())
  default {
    builder.push(id.map_children(layout, mapping))
  }
}




fun get(
  mapping: Map[EggId, EggId], tuple: Tuple2[EggId, EggId]
): Tuple2[EggId, EggId] {
  tuple(tuple.a.map(mapping.*), tuple.b.map(mapping.*))
}
