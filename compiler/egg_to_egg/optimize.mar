| Welcome to the Egg optimizer! This file contains lots of code, so I'll point
| out some general themes going on here. The code here is used to turn a Egg
| into a more optimized Egg.
|
| This is achieved by constant folding operations, inlining function calls,
| analyzing fixpoints of recursive expressions, and pulling impure operations
| out of the tree.

import mod.mar

fun optimize(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for signature in egg.choose_optimization_order() do {
    | eprintln("Optimizing {signature}")
    funs.&.put(
      signature,
      egg.funs.get(signature).map(Optimize { optimized = funs.&, egg }),
    )
  }
  Egg { funs, entry_point = egg.entry_point }.tree_shake()
}

struct Optimize { optimized: &Map[String, EggFun], egg: Egg }
fun map(
  body: EggBody, optimize: Optimize, mapping: &Map[EggId, EggId]
): EggBody {
  body.map_children(optimize, mapping).tree_shake()
}
fun map(
  id: EggId,
  optimize: Optimize, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var id = EggId { id = egg_dag.put(id.map_children(optimize, builder, mapping)) }

  | var namespace = namespace().&
  | stderr."Optimizing\n  {pretty(id, namespace)} = "
  | stderr.write(id, namespace, indentation(0))
  | stderr."\n"

  | Compile the single expression into an optimized body (allowing it to expand
  | to zero or multiple expressions).
  var optimized = {
    var builder = egg_body_builder().&
    builder.finish(id.optimize(optimize, builder))
  }
  var better_id = optimized.returns

  | stderr."Optimized:"
  | for child in optimized.children do {
  |   stderr."\n  {pretty(child, namespace)} = "
  |   stderr.write(child, namespace, indentation(0))
  | }
  | stderr."\n  {pretty(better_id, namespace)}\n"

  if optimized.children.is_empty() then return better_id
  if optimized.children.len == 1 then
    if optimized.children.get(0) == better_id then
      return builder.push(better_id.resolve())
  
  var last = none[EggId]()
  for child in optimized.children do {
    var id = child.map(optimize, builder, mapping)
    last = some(id)
  }
  last.unwrap()
}

| Assuming that the dependencies of the expression are accessible in the
| builder and already optimized, emit expressions that are equivalent to
| performing the expression.
fun optimize(id: EggId, optimize: Optimize, builder: &EggBodyBuilder): EggId {
  switch id.resolve()
  case member(member) {
    | Constant fold members of known structs.
    |
    | member foo    | both
    |   &           |   hole b
    |     foo:      |   hole a
    |       hole a  |
    |     bar:      |
    |       hole b  |
    if member.of.resolve() is struct_(fields) then
      return fields.get(member.name)
  }
  case switch_(switch_) {
    | Constant fold switches on enums of known variants.
    |
    | switch      | int 2
    |   | true:   |
    |     &       |
    |   true a:   |
    |     int 2   |
    |   false b:  |
    |     int 3   |
    | if switch_.condition.resolve() is enum_(enum_) then {
    |   return switch_.cases.get(enum_.variant)
    |     .fill(enum_.payload.*)
    |     .optimize(context)
    | }

    | If all non-diverging cases are the same and don't depend on parameters,
    | pull them out of the switch. This then allows the surrounding expressions
    | to bubble up the "both", leaving a simpler, constant-foldable expression.
    |
    | add           | add             | both
    |   switch      |   both          |   switch
    |     hole a    |     switch      |     hole a
    |     true b:   |       hole a    |     true b:
    |       crash   |       true b:   |       crash
    |     false c:  |         crash   |     false c:
    |       int 3   |       false c:  |       &
    |   int 2       |         &       |   add
    |               |     int 3       |     int 3
    |               |   int 2         |     int 2
    | var non_diverging_cases = list[MapEntry[String, EggBody]]()
    | for case_ in switch_.cases do {
    |   var diverges =
    |     {case_.value.expr.op is crash} or {case_.value.expr.op is unreachable}
    |   if not(diverges) then non_diverging_cases.&.push(case_)
    | }
    | if non_diverging_cases.is_not_empty() then {
    |   var common = non_diverging_cases.get(0).value.expr
    |   var inline = common != taco_nothing
    |   for case_ in non_diverging_cases do {
    |     if case_.value.expr != common then { inline = false  break }
    |     if case_.value.expr.collect_captured().iter().&
    |       .contains(case_.value.params.get(0))
    |     then { inline = false  break }
    |   }
    |   if inline then {
    |     return both(
    |       switch_(switch_.condition.*, type_nothing, {
    |         var new_cases = map[String, EggBody]()
    |         for case_ in switch_.cases do
    |           new_cases.&.put(
    |             case_.key,
    |             body(
    |               case_.value.params,
    |               if case_.value.expr == common
    |               then taco_nothing
    |               else case_.value.expr.op.expr(type_nothing),
    |             ),
    |           )
    |         new_cases
    |       }),
    |       common,
    |     ).opt(context)
    |   }
    | }

    | Consider inlining nested switches.
    |
    | switch          | switch
    |   switch        |   compare
    |     compare     |     hole a
    |       hole a    |     hole b
    |       hole b    |   less c:
    |     less c:     |     crash
    |       | false:  |   equal d:
    |         &       |     &
    |     equal d:    |   greater e:
    |       | true:   |     crash
    |         &       |
    |     greater e:  |
    |       | false:  |
    |         &       |
    |   true f:       |
    |     &           |
    |   false g:      |
    |     crash       |
    | if switch_.condition.op is switch_(inner_switch) then {
    |   var all_cases_known = true
    |   for case_ in inner_switch.cases do
    |     if not(case_.value.expr.op is enum_) then all_cases_known = false
    |   | If not all cases are known, we would have copy the entire outer switch
    |   | into at least one case of the inner switch. That's a huge code
    |   | explosion, so let's not do that.
    |   if all_cases_known then {
    |     | Calculate how much code explosion we would have. For example, if one
    |     | case of the outer switch is really big and multiple branches from the
    |     | inner switch evaluate to that variant, maybe we don't want to inline
    |     | the code.
    |     var max_outer_case_complexity = 0
    |     for case_ in switch_.cases do
    |       max_outer_case_complexity =
    |         max(max_outer_case_complexity, case_.value.expr.num_exprs())
    |     if max_outer_case_complexity <= 2 then {
    |       return switch_(inner_switch.condition.*, expr.type, {
    |         var new_cases = map[String, EggBody]()
    |         for case_ in inner_switch.cases do
    |           new_cases.&.put(
    |             case_.key,
    |             body(
    |               case_.value.params,
    |               switch_(case_.value.expr, expr.type, switch_.cases)
    |                 .opt(context),
    |             ),
    |           )
    |         new_cases
    |       })
    |     }
    |   }
    | }

    | TODO: Inner switch but one variant of the outer switch is never chosen;
    | case could be optimized to unreachable.
  }
  case call_fun(call) {
    | TODO: Try to run the function at compile time.

    | Inline the function, if:
    | - The function has already been visited during the optimization pass.
    |   Otherwise, mutually recursive functions might hang the compiler.
    | - The function size fits in some upper bound.
    |   Otherwise, we may get exponential code explosion.
    | - The function is not generic.
    |   Otherwise, the function might call itself with different type arguments
    |   and we can't model that, not even using a recursive expression. After
    |   monomorphization, no generic functions exist, so every function has a
    |   chance of being inlined eventually.
    |
    | call core/int/+  | add
    |   int 3          |   int 3
    |   int 2          |   int 2
    | if call.fun_.substitutions.substitutions.size == 0 then
    |   if context.optimized.get_maybe(call.fun_.signature) is some(body) then {
    |     var should_inline = true | body.expr.num_exprs() <= 30
    |     if should_inline then {
    |       return recursive(
    |         call.args,
    |         body
    |           .specialize(call.fun_.substitutions)
    |           .new_holes()
    |           .call_to_recurse(
    |             call.fun_, type.specialize(call.fun_.substitutions)
    |           ),
    |       ).opt(context)
    |     }
    |   }
  }
  case call_lambda(call) {
    | Constant fold calls of lambda literals.
    | 
    | call lambda   | add
    |   lambda a:   |   int 3
    |     add       |   hole b
    |       hole a  |
    |       hole b  |
    |   int 3       |
    | if call.lambda.op is lambda(body) then
    |   return body.fill(call.args).optimize(context)
  }
  case cast(cast) {
    | Remove unnecessary casts.
    |
    | cast (Int)  |  int 2
    |   int 2     |
    if cast.what.type() == cast.type then return cast.what

    | Instead of casting enums, construct them directly with the correct type.
    |
    | cast (| none: (&) some: (Int))  | | none:  (| none: (&) some: (Int))
    |   | none:  (| none: (&))        |     &
    |       &                         |
    if cast.what.resolve() is enum_(enum_) then {
      return builder.enum_(
        cast.type,
        enum_.variant,
        builder.cast(
          enum_.payload, cast.type.kind().enum_.unwrap().get(enum_.variant)
        ),
      )
    }
  }
  case lower_byte(arg) {
    | Constant fold getting the lower byte of known ints.
    |
    | lower byte  | byte 3
    |   int 3     |
    | if arg.op is int(int) then return taco_byte(int.lower_byte())
  }
  case byte_to_int(arg) {
    | Constant fold converting known bytes to ints.
    |
    | byte to int  | int 2
    |   byte 2     |
    | if arg.op is byte(byte) then return taco_int(byte.to_int())
  }
  case add(args) {
    var a = args.a
    var b = args.b

    | Constant fold addition.
    | if a.op is int(a) then if b.op is int(b) then return taco_int(a + b)
    | if a.op is int(a) then if a == 0 then return b  | 0 + x
    | if b.op is int(b) then if b == 0 then return a  | x + 0
    | if a.op is subtract(args) then
    |   if b == args.b.* then
    |     return both(b, args.a.*).opt(context)  | (x - y) + y
    | if b.op is subtract(args) then
    |   if a == args.b.* then
    |     return both(a, args.a.*).opt(context)  | x + (y - x)
  }
  case subtract(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()

    | Constant fold subtraction.
    | if a.op is int(a) then if b.op is int(b) then return taco_int(a - b)

    | Simplify subtraction.
    |
    | subtract  | hole a
    |   hole a  |
    |   int 0   |
    | if b.op is int(b) then if b == 0 then return a  | x - 0
  }
  case multiply(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()

    | Constant fold multiplication.
    |
    | multiply  | int 8
    |   int 2   |
    |   int 4   |
    | if a.op is int(a) then if b.op is int(b) then return taco_int(a * b)

    | Simplify multiplication.
    |
    | multiply  | hole a
    |   hole a  |
    |   int 1   |
    | if a.op is int(a) then if a == 1 then return b  | 1 * x
    | if b.op is int(b) then if b == 1 then return a  | x * 1
  }
  case divide(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()
    | if a.op is int(a) then if b.op is int(b) then if b != 0 then
    |   return taco_int(a / b)
    | if b.op is int(b) then if b == 1 then return a  | x / 1
  }
  case modulo(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()
    | if a.op is int(a) then if b.op is int(b) then if b != 0 then
    |   return taco_int(a % b)
    | if b.op is int(b) then if b == 1 then return taco_int(0)  | x % 1
  }
  case and_(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()
    | if a.op is int(a) then if b.op is int(b) then return taco_int(a & b)
    | if a.op is int(a) then if a == 0 then return taco_int(0)  | 0 & x
    | if b.op is int(b) then if b == 0 then return taco_int(0)  | x & 0
    | if a.op is int(a) then if a == -1 then return b  | -1 & x
    | if b.op is int(b) then if b == -1 then return a  | x & -1
  }
  case or_(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()
    | if a.op is int(a) then if b.op is int(b) then return taco_int(or(a, b))
    | if a.op is int(a) then if a == 0 then return b  | 0 | x
    | if b.op is int(b) then if b == 0 then return a  | x | 0
    | if a.op is int(a) then if a == -1 then return taco_int(-1)  | -1 | x
    | if b.op is int(b) then if b == -1 then return taco_int(-1)  | x | -1
  }
  case xor(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()
    | if a.op is int(a) then if b.op is int(b) then return taco_int(a ^ b)
  }
  case compare(args) {
    var a = args.a.resolve()
    var b = args.b.resolve()

    | Constant fold.
    |
    | compare  | | less:
    |   int 2  |   &
    |   int 3  |
    | if a.op is int(a) then if b.op is int(b) then {
    |   var symbol =
    |     switch a <=> b
    |     case less "less"
    |     case equal "equal"
    |     case greater "greater"
    |   return enum_(type, symbol, taco_nothing)
    | }

    | Simplify some comparisons.
    |
    | compare     | compare
    |   subtract  |   hole a
    |     hole a  |   hole b
    |     hole b  |
    |   int 0     |
    | if a.op is subtract(sub) then if b.op is int(b) then if b == 0 then {
    |   return compare(sub.a.resolve(), sub.b.resolve())
    | }
  }
  case unbox(box) {
    | TODO: Document
    | if box.op is box(inner) then return inner.resolve()
  }
  | case unchecked_generate_non_empty_array(gen) {
  |   | Bubble up unreachable, crashes, and both.
  |   if gen.a.op is unreachable then return taco_unreachable(expr.type)
  |   if gen.a.op is crash then return taco_crash(expr.type)
  |   if gen.a.op is both(both) then
  |     return both(
  |       both.a.resolve(), unchecked_generate_non_empty_array(both.b.resolve(), gen.b.resolve())
  |     ).opt(context)
  |   if gen.b.find_both_independent_of_locals() is some(ignored) then
  |     return both(
  |       gen.a.resolve(),
  |       both(
  |         ignored,
  |         unchecked_generate_non_empty_array(
  |           gen.a.resolve(), gen.b.assert_not_crashing(ignored)
  |         ),
  |       ).opt(context),
  |     ).opt(context)

  |   | For small arrays, specialize and constant fold the generator for each
  |   | index.
  |   |
  |   | unchecked_generate_non_empty_array  | array
  |   |   int 5                             |   int 0
  |   |   generator a:                      |   int 1
  |   |     multiply                        |   int 4
  |   |       hole a                        |   int 9
  |   |       hole a                        |   int 25
  |   if gen.a.op is int(len) then if len <= 10 then {
  |     var items = list[EggExpr]()
  |     for index in 0..len do
  |       items.&.push(
  |         gen.b
  |           .fill(list(taco_int(index)).to_slice())
  |           .optimize(context)
  |       )
  |     return array(gen.b.expr.type, items.to_slice())
  |   }
  | }
  case array_get(args) {
    var array = args.array.resolve()
    var index = args.index.resolve()
    | if array.op is array(items) then if index.op is int(index) then
    |   if (0..items.len).contains(index) then return items.get(index)
  }
  case array_set(args) {
    var array = args.array.resolve()
    var index = args.index.resolve()
    var item  = args.item.resolve()
    | if array.op is array(items) then if index.op is int(index) then
    |   if (0..items.len).contains(index) then {
    |     var new_items = list[EggExpr]()
    |     for item in items do new_items.&.push(item)
    |     new_items.&.set(index, item)
    |     return array(type, new_items.to_slice())
    |   }
  }
  case array_slice(args) {
    var array = args.array.resolve()
    var start = args.start.resolve()
    var end = args.end.resolve()
    | switch array.op
    | case array(items) {
    |   if start.op is int(start) then if end.op is int(end) then {
    |     if (0..items.len).contains(start) and (0..items.len).contains(end)
    |     then return array(type, items.subslice(start..end))
    |   }
    | }
    | case array_slice(inner_args) {
    |   var inner_array = inner_args.a.resolve()
    |   var inner_start = inner_args.b.resolve()
    |   var inner_end = inner_args.c.resolve()

    |   | Merge the two nested slice operations into one. This requires explicitly
    |   | performing the checks that the inner slice would have done.
    |   return array_slice(
    |     inner_array,
    |     if_(
    |       compare(inner_start, taco_int(0)).opt(context)
    |         .is_less().opt(context),
    |       taco_crash(type_int),
    |       add(inner_start, start).opt(context),
    |     ).opt(context),
    |     if_(
    |       compare(
    |         inner_end, array_len(inner_array).opt(context)
    |       ).opt(context).is_less_equal().opt(context),
    |       add(inner_start, end).opt(context),
    |       taco_crash(type_int),
    |     ).opt(context),
    |   )
    | }
    | default {}
  }
  case array_len(array) {
    | switch array.op
    | case array(items) return taco_int(items.len)
    | case generate_array(gen) {
    |   | The generator may panic for an index, so we need to call it with the
    |   | original indices.
    |   return both(
    |     recursive(list(taco_int(0)).to_slice(), {
    |       var index = gen.b.params.get(0)
    |       body(index, both(
    |         gen.b.expr,
    |         if_(
    |           compare(taco_hole(index), gen.a.resolve()).is_equal(),
    |           taco_nothing,
    |           recurse(
    |             list(add(taco_hole(index), taco_int(1))).to_slice(),
    |             type_nothing,
    |           ),
    |         )
    |       ).opt(context))
    |     }),
    |     gen.a.resolve(),
    |   ).opt(context)
    | }
    | case array_slice(args) {
    |   var array = args.a.resolve()
    |   var start = args.b.resolve()
    |   var end = args.c.resolve()

    |   | We can calculate the length from the slice bounds. We must also perform
    |   | bounds checking, just like the array slice function would have done.
    |   return both(
    |     if_(
    |       compare(start, taco_int(0)).is_less(),
    |       taco_crash(type_nothing),
    |       if_(
    |         compare(end, array_len(array)).is_greater(),
    |         taco_crash(type_nothing),
    |         taco_nothing,
    |       ),
    |     ),
    |     subtract(end, start),
    |   ).opt(context)
    | }
    | default {}
  }
  | case recursive(rec) {
  |   if not(rec.b.expr.recurses()) then
  |     return rec.b.fill(rec.a).optimize(context)

  |   | Find fixpoints
  |   stderr."Optimizing shallow recursive. Args:\n"
  |   for arg in rec.a do {
  |     stderr.write(arg, holes_namespace().&, indentation(1))
  |     stderr."\n"
  |   }
  |   var mask = rec.b.find_fixpoint_mask(rec.a, context)
  |   var new_args = {
  |     var res = list[EggExpr]()
  |     for arg in rec.a.mask(mask) do res.&.push(arg.optimize(context))
  |     res.to_slice()
  |   }
  |   var new_holes = {
  |     var res = list[Hole]()
  |     for arg in new_args do res.&.push(hole(arg.type))
  |     res.to_slice()
  |   }
  |   return recursive(
  |     new_args,
  |     body(
  |       new_holes,
  |       rec.b
  |         .fill(new_holes.unmask(mask))
  |         .optimize(context)
  |         .replace_recurses(mask),
  |     )
  |   )
  | }
  | case recurse(args) {
  |   | Bubble up crashes and both.
  |   for arg in args do if arg.op is crash then return taco_crash(type)
  |   for arg in args.iter().enumerate() do if arg.item.op is both(both) then {
  |     var new_args = list[EggExpr]()
  |     for i in 0..args.len do
  |       new_args.&.push(if i == arg.index then both.b.resolve() else args.get(i))
  |     return both(
  |       both.a.resolve(),
  |       recurse(new_args.to_slice(), expr.type).opt(context),
  |     ).opt(context)
  |   }

  |   | Push recurse into switch cases.
  |   if args.len == 1 then if args.get(0).op is switch_(switch_) then {
  |     return switch_(switch_.condition.resolve(), type, {
  |       var cases = map[String, EggBody]()
  |       for case_ in switch_.cases do
  |         cases.&.put(
  |           case_.key,
  |           EggBody {
  |             params = case_.value.params,
  |             expr = recurse(list(case_.value.expr).to_slice(), type)
  |               .opt(context)
  |           }
  |         )
  |       cases
  |     })
  |   }
  | }
  default {}

  builder.children.&.push(id)
  id
}

| fun opt(expr: EggExpr, context: OptimizeEggContext): EggExpr {

|   switch expr.op
|   default {}

|   expr
| }

| | The number of expressions inside this expression.
| fun num_exprs(expr: EggExpr): Int {
|   var num = 1
|   for child in expr.children() do num = num + child.num_exprs()
|   num
| }

| | Whether the expression contains a recurse expression that is not nested within
| | a recursive expression.
| fun recurses(expr: EggExpr): Bool {
|   if expr.op is recursive then return false  | An inner recurse is local.
|   if expr.op is recurse then return true
|   for child in expr.children() do if child.recurses() then return true
|   false
| }

| | Converts calls to the given called signature into recurse expressions.
| fun call_to_recurse(
|   expr: EggExpr, called: EggCalledFun, return_type: EggType
| ): EggExpr {
|   expr.map(CallToRecurse { called, return_type })
| }
| fun call_to_recurse(
|   body: EggBody, called: EggCalledFun, return_type: EggType
| ): EggBody {
|   body.map(CallToRecurse { called, return_type })
| }
| struct CallToRecurse { called: EggCalledFun, return_type: EggType }
| fun map(expr: EggExpr, call_to_recurse: CallToRecurse): EggExpr {
|   var expr = expr.map_children(call_to_recurse)
|   if expr.op is call_fun(call) then
|     if call.fun_ == call_to_recurse.called then
|       return recurse(call.args, call_to_recurse.return_type)
|   expr
| }

| | Fills the body with concrete arguments for its parameters.
| fun fill(body: EggBody, args: Slice[EggExpr]): EggExpr {
|   var fillings = map[Hole, EggExpr]()
|   for both in zip(body.params.iter(), args.iter()) do
|     fillings.&.put(both.a, both.b)
|   body.expr.fill(fillings)
| }
| fun fill(body: EggBody, arg: EggExpr): EggExpr {
|   body.fill(list(arg).to_slice())
| }
| fun fill(expr: EggExpr, fillings: Map[Hole, EggExpr]): EggExpr {
|   expr.map(Fill { fillings })
| }
| struct Fill { fillings: Map[Hole, EggExpr] }
| fun map(expr: EggExpr, fill: Fill): EggExpr {
|   if expr.op is hole(hole) then
|     if fill.fillings.get_maybe(hole) is some(value) then return value
|   expr.map_children(fill)
| }

| fun collect_captured(expr: EggExpr): Slice[Hole] {
|   var out = set[Hole]()
|   expr.visit(CollectCaptured { ignore = set[Hole]().&, out = out.& })
|   var res = list[Hole]()
|   for hole in out do res.&.push(hole)
|   res.to_slice()
| }
| fun collect_captured(body: EggBody): Slice[Hole] {
|   var out = set[Hole]()
|   body.visit(CollectCaptured { ignore = set[Hole]().&, out = out.& })
|   var res = list[Hole]()
|   for hole in out do res.&.push(hole)
|   res.to_slice()
| }
| struct CollectCaptured { ignore: &Set[Hole], out: &Set[Hole] }
| fun visit(expr: EggExpr, collect_captured: CollectCaptured) {
|   if expr.op is hole(hole) then
|     if not(collect_captured.ignore.contains(hole)) then
|       collect_captured.out.put(hole)
|   expr.visit_children(collect_captured)
| }
| fun visit(body: EggBody, collect_captured: CollectCaptured) {
|   for param in body.params do collect_captured.ignore.put(param)
|   body.expr.visit(collect_captured)
| }

| fun find_both_independent_of_locals(body: EggBody): Maybe[EggExpr] {
|   var independent = none[EggExpr]()
|   body.expr.visit(FindBothIndependentOfLocals {
|     locals = body.params, independent = independent.&
|   })
|   independent
| }
| struct FindBothIndependentOfLocals {
|   locals: Slice[Hole], independent: &Maybe[EggExpr]
| }
| fun visit(expr: EggExpr, finder: FindBothIndependentOfLocals) {
|   if expr.op is both(both) then {
|     var is_independent = true
|     for captured in both.a.*.collect_captured() do
|       for id in finder.locals do
|         if captured == id then is_independent = false
|     if is_independent then {
|       finder.independent.* = some(both.a.*)
|       return {}
|     }
|   }
|   expr.visit_children(finder)
| }
| fun visit(body: EggBody, finder: FindBothIndependentOfLocals) {}
