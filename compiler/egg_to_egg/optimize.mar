| Welcome to the Egg optimizer! This file contains lots of code, so I'll point
| out some general themes going on here. The code here is used to turn a Egg
| into a more optimized Egg.
|
| This is achieved by constant folding operations, inlining function calls,
| analyzing fixpoints of recursive expressions, and pulling impure operations
| out of the tree.

import mod.mar

fun optimize(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for signature in egg.choose_optimization_order() do {
    eprintln("Optimizing {signature}")
    var optimized = egg.funs.get(signature).map(Optimize { optimized = funs.&, egg })
    eprintln("Optimized {signature}:")
    stderr.write("fds", optimized)
    stderr."\n"
    optimized.verify()
    funs.&.put(signature, optimized)
  }
  Egg { funs, entry_point = egg.entry_point }.tree_shake()
}

struct Optimize { optimized: &Map[String, EggFun], egg: Egg }
fun map(
  body: EggBody, optimize: Optimize, mapping: &Map[EggId, EggId]
): EggBody {
  body.map_children(optimize, mapping).tree_shake()
}
fun map(
  old: EggId,
  optimize: Optimize, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var namespace = namespace().&
  | stderr."Optimizing children of\n"
  | stderr.write(old, namespace, indentation(1))
  | stderr."\n"

  var children_optimized = EggId {
    id = egg_dag.put(old.map_children(optimize, builder, mapping))
  }

  | stderr."Optimizing (children optimized)\n  {pretty(children_optimized, namespace)} = "
  | stderr.write(children_optimized, namespace, indentation(2))
  | stderr."\n"

  | Compile the single expression into an optimized body (allowing it to expand
  | to zero or multiple expressions).
  var fully_optimized = {
    var builder = egg_body_builder().&
    builder.finish(children_optimized.optimize(optimize, builder))
  }

  | stderr."Fully optimized:"
  | for child in fully_optimized.children do {
  |   stderr."\n  {pretty(child, namespace)} = "
  |   stderr.write(child, namespace, indentation(2))
  | }
  | stderr."\n  {pretty(fully_optimized.returns, namespace)}\n"

  var new =
    if fully_optimized.returns == children_optimized then
      builder.push(children_optimized)
    else {
      for child in fully_optimized.children do {
        var even_more_optimized = child.map(optimize, builder, mapping)
        mapping.put(child, even_more_optimized)
      }
      fully_optimized.returns.map(mapping)
    }
  mapping.put(old, new)
  new
}

| Assuming that the dependencies of the expression are accessible in the
| builder and already optimized, emit expressions that are equivalent to
| performing the expression.
fun optimize(id: EggId, optimize: Optimize, builder: &EggBodyBuilder): EggId {
  | eprintln("Optimizing {id.debug()}")
  switch id.resolve()
  case lambda(lambda) {
    | Assume that the lambda will run often, hoist pure expressions out of it do
    | prevent redoing the work to calculate them over and over every time the
    | lambda is called.
    |
    | b =                   | b = multiply a a
    |   lambda c:           | c =
    |     d = multiply a a  |   lambda d:
    |     e = add c d       |     e = add b d
    |     e                 |     e
    var hoisted = lambda.hoist_from_body_running_often()
    if hoisted.hoisted.is_not_empty() then {
      for id in hoisted.hoisted do builder.push(id)
      return builder.lambda(hoisted.body)
    }
  }
  case member(member) {
    | Constant fold members of known structs.
    |
    | c = & foo: a bar: b  | c = & foo: a bar: b
    | d = member c.foo     | e = add a a 
    | e = add d d          |
    if member.of.resolve() is struct_(fields) then
      return fields.get(member.name)
  }
  case switch_(switch_) {
    | Constant fold switches on enums of known variants.
    |
    | a = &            | a = &
    | b = | true: a    | b = | true: a
    | c =              | e = int 2
    |   switch b       |
    |     true d:      |
    |       e = int 2  |
    |       e          |
    |     false f:     |
    |       g = int 3  |
    |       g          |
    if switch_.condition.resolve() is enum_(enum_) then
      return switch_.cases.get(enum_.variant).fill(enum_.payload, builder)

    | If all non-diverging cases are the same and don't depend on parameters,
    | pull them out of the switch, leaving the switch to evaluate to Nothing.
    | This then leaves simpler, more constant-foldable ingredients for later
    | expressions.
    |
    | b =              | b =              | b =
    |   switch a       |   switch a       |   switch a
    |     true c:      |     true c:      |     true c:
    |       d = crash  |       d = crash  |       d = crash
    |       d          |       d          |       d
    |     false e:     |     false e:     |     false e:
    |       f = int 3  |       f = &      |       f = &
    |       f          |       f          |       f
    | g = int 2        | g = int 3        | g = int 5
    | h = add b g      | h = int 2        |
    |                  | i = add g h      |
    | var non_diverging_cases = list[MapEntry[String, EggBody]]()
    | for case_ in switch_.cases do {
    |   var diverges =
    |     {case_.value.expr.resolve() is crash} or {case_.value.expr.resolve() is unreachable}
    |   if not(diverges) then non_diverging_cases.&.push(case_)
    | }
    | if non_diverging_cases.is_not_empty() then {
    |   var common = non_diverging_cases.get(0).value.expr
    |   var inline = common != taco_nothing
    |   for case_ in non_diverging_cases do {
    |     if case_.value.expr != common then { inline = false  break }
    |     if case_.value.expr.collect_captured().iter().&
    |       .contains(case_.value.params.get(0))
    |     then { inline = false  break }
    |   }
    |   if inline then
    |     return both(
    |       switch_(switch_.condition.*, type_nothing, {
    |         var new_cases = map[String, EggBody]()
    |         for case_ in switch_.cases do
    |           new_cases.&.put(
    |             case_.key,
    |             body(
    |               case_.value.params,
    |               if case_.value.expr == common
    |               then taco_nothing
    |               else case_.value.expr.resolve().expr(type_nothing),
    |             ),
    |           )
    |         new_cases
    |       }),
    |       common,
    |     )
    | }

    | Consider "inlining" switches that switch on the result of other switches.
    |
    | c = compare a b       | c = compare a b
    | d =                   | d =
    |   switch c            |   switch c
    |     less e:           |     less e:
    |       f = &           |       f = crash
    |       g = | false: f  |       f
    |       g               |     equal g:
    |     equal h:          |       h = &
    |       i = &           |       h
    |       j = | true: i   |     less i:
    |       j               |       j = crash
    |     greater k:        |       j
    |       l = &           |
    |       m = | true: l   |
    |       m               |
    | n =                   |
    |   switch d            |
    |     true o:           |
    |       p = &           |
    |       p               |
    |     false q:          |
    |       r = crash       |
    | if switch_.condition.resolve() is switch_(inner_switch) then {
    |   var all_cases_known = true
    |   for case_ in inner_switch.cases do
    |     if not(case_.value.expr.resolve() is enum_) then all_cases_known = false
    |   | If not all cases are known, we would have copy the entire outer switch
    |   | into at least one case of the inner switch. That's a huge code
    |   | explosion, so let's not do that.
    |   if all_cases_known then {
    |     | Calculate how much code explosion we would have. For example, if one
    |     | case of the outer switch is really big and multiple branches from the
    |     | inner switch evaluate to that variant, maybe we don't want to inline
    |     | the code.
    |     var max_outer_case_complexity = 0
    |     for case_ in switch_.cases do
    |       max_outer_case_complexity =
    |         max(max_outer_case_complexity, case_.value.expr.num_exprs())
    |     if max_outer_case_complexity <= 2 then {
    |       return switch_(inner_switch.condition.*, expr.type, {
    |         var new_cases = map[String, EggBody]()
    |         for case_ in inner_switch.cases do
    |           new_cases.&.put(
    |             case_.key,
    |             body(
    |               case_.value.params,
    |               switch_(case_.value.expr, expr.type, switch_.cases)
    |                 ,
    |             ),
    |           )
    |         new_cases
    |       })
    |     }
    |   }
    | }

    | TODO: Inner switch but one variant of the outer switch is never chosen;
    | case could be optimized to unreachable.
  }
  case call_fun(call) {
    | TODO: Try to run the function at compile time.

    | Inline the function, if:
    | - The function has already been visited during the optimization pass.
    |   Otherwise, mutually recursive functions might hang the compiler.
    | - The function size fits in some upper bound.
    |   Otherwise, we may get exponential code explosion.
    | - The function is not generic.
    |   Otherwise, the function might call itself with different type arguments
    |   and we can't model that, not even using a recursive expression. After
    |   monomorphization, no generic functions exist, so every function has a
    |   chance of being inlined eventually.
    |
    | a = int 3                | a = int 3    | a = int 3
    | b = int 2                | b = int 2    | b = int 2
    | c = call core/int/+ a b  | c = add a b  | c = int 5
    if call.substitutions.substitutions.size == 0 then
      if optimize.optimized.get_maybe(call.fun_) is some(fun_) then {
        var should_inline = true | body.expr.num_exprs() <= 30
        if should_inline then {
          eprintln("inlining call")
          eprintln("fun:\n")
          stderr.write(Egg { funs = map("to_inline" -> fun_), entry_point = "" })
          stderr."\n"
          return builder.recursive(
            call.args,
            fun_.specialize(call.substitutions).body,
            | .call_to_recurse(
            |   call.fun_, call.return_type.specialize(call.substitutions)
            | ),
          )
        }
      }
  }
  case call_lambda(call) {
    | Inline calls of lambda literals.
    |
    | a = lambda b:             | a = lambda b:  | a = lambda b:
    |   c = int 3               |   c = int 3    |   c = int 3
    |   d = add b c             |   d = add b c  |   d = add b c
    |   d                       |   d            |   d
    | e = int 4                 | e = int 4      | e = int 4
    | f = call lambda a with e  | f = int 3      | f = int 3
    |                           | g = add e f    | g = int 7
    if call.lambda.resolve() is lambda(lambda_body) then
     return lambda_body.fill(call.args, builder)
  }
  case cast(cast) {
    | Remove unnecessary casts.
    |
    | cast (Int)  |  int 2
    |   int 2     |
    if cast.what.type() == cast.type then return cast.what

    | Instead of casting enums, construct them directly with the correct type.
    |
    | cast (| none: (&) some: (Int))  | | none:  (| none: (&) some: (Int))
    |   | none:  (| none: (&))        |     &
    |       &                         |
    if cast.what.resolve() is enum_(enum_) then {
      return builder.enum_(
        cast.type,
        enum_.variant,
        builder.cast(
          enum_.payload, cast.type.kind().enum_.unwrap().get(enum_.variant)
        ),
      )
    }
  }
  case lower_byte(arg) {
    | Constant fold.
    if arg.resolve() is int(int) then return builder.byte(int.lower_byte())

    | lower_byte(byte_to_int(a)) = a
    if arg.resolve() is byte_to_int(a) then return a
  }
  case byte_to_int(arg) {
    | Constant fold.
    if arg.resolve() is byte(byte) then return builder.int(byte.to_int())
  }
  case add(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a + b)

    | 0 + x = x
    if a.resolve() is int(a) then if a == 0 then return b

    | x + 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | (x - y) + y = x
    if a.resolve() is subtract(args) then if b == args.b then return args.a

    | x + (y - x) = y
    if b.resolve() is subtract(args) then if a == args.b then return args.a
  }
  case subtract(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a - b)

    | x - 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | (x + y) - y = x
    if a.resolve() is add(args) then if args.b == b then return args.a
  }
  case multiply(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a * b)

    | 1 * x = x
    if a.resolve() is int(a) then if a == 1 then return b

    | x * 1 = x
    if b.resolve() is int(b) then if b == 1 then return a
  }
  case divide(args) {
    var a = args.a
    var b = args.b

    | Constant fold crash.
    if b.resolve() is int(b) then if b == 0 then
      return builder.crash(builder.string("divide by zero"), type_int)

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a / b)

    | x / 1 = x
    if b.resolve() is int(b) then if b == 1 then return a
  }
  case modulo(args) {
    var a = args.a
    var b = args.b

    | Constant fold crash.
    if b.resolve() is int(b) then if b == 0 then
      return builder.crash(builder.string("modulo by zero"), type_int)

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a % b)

    | x % 1 = 0
    if b.resolve() is int(b) then if b == 1 then return builder.int(0)
  }
  case and_(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a & b)

    | 0 & x = 0
    if a.resolve() is int(a) then if a == 0 then return builder.int(0)
  
    | x & 0 = 0
    if b.resolve() is int(b) then if b == 0 then return builder.int(0)

    | -1 & x = x
    if a.resolve() is int(a) then if a == -1 then return b

    | x & -1 = x
    if b.resolve() is int(b) then if b == -1 then return a
  }
  case or_(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(or(a, b))

    | 0 or x = x
    if a.resolve() is int(a) then if a == 0 then return b
  
    | x or 0 = x
    if b.resolve() is int(b) then if b == 0 then return a

    | -1 or x = -1
    if a.resolve() is int(a) then if a == -1 then return builder.int(-1)
  
    | x or -1 = -1
    if b.resolve() is int(b) then if b == -1 then return builder.int(-1)
  }
  case xor(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.int(a ^ b)
    
    | x xor x = 0
    if a == b then return builder.int(0)
  }
  case compare(args) {
    var a = args.a
    var b = args.b

    | Constant fold.
    if a.resolve() is int(a) then if b.resolve() is int(b) then
      return builder.enum_(
        type_ordering,
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater",
        builder.nothing()
      )

    | compare((x - y), 0) = compare(x, y)
    if a.resolve() is subtract(sub) then if b.resolve() is int(b) then
      if b == 0 then return builder.compare(sub.a, sub.b)
    
    | Note: Because add and subtract wrap around, we can't optimize something
    | like compare(x + 1, x) to greater.
  }
  case unbox(box) {
    | unbox(box(x)) = x
    if box.resolve() is box(inner) then return inner
  }
  case unchecked_generate_non_empty_array(args) {
    | if args.b.find_both_independent_of_locals() is some(ignored) then
    |   return both(
    |     args.a.resolve(),
    |     both(
    |       ignored,
    |       unchecked_generate_non_empty_array(
    |         args.a.resolve(), args.b.assert_not_crashing(ignored)
    |       ),
    |     ),
    |   )

    | For small arrays, specialize and constant fold the generator for each
    | index.
    |
    | a = int 4                               | a = int 5
    | b =                                     | b = int 0
    |   unchecked_generate_non_empty_array a  | c = int 1
    |     generator c:                        | d = int 4
    |       d = multiply c c                  | e = int 9
    |       d                                 | f = array b c d e
    if args.length.resolve() is int(length) then if length <= 10 then {
      var items = list[EggId]()
      for index in 0..length do
        items.&.push(args.generator.fill(builder.int(index), builder))
      return builder.array(items.to_slice(), args.generator.returns.type())
    }

    | Hoist expressions (even potentially crashing ones) that don't depend on
    | the parameters out of the generator.
    var hoisted = args.generator.hoist_from_body_running_often()
    if hoisted.hoisted.is_not_empty() then {
      for id in hoisted.hoisted do builder.push(id)
      return builder.unchecked_generate_non_empty_array(
        args.length, hoisted.body
      )
    }
  }
  case array_get(args) {
    | Constant fold.
    if args.array.resolve() is array(array) then
      if args.index.resolve() is int(index) then
        return if (0..array.items.len).contains(index) then
          array.items.get(index)
        else
          builder.crash("out of bounds", array.item_type)
  }
  case array_set(args) {
    | Constant fold.
    if args.array.resolve() is array(array) then
      if args.index.resolve() is int(index) then
        return if (0..array.items.len).contains(index) then {
          var new_items = list[EggId]()
          for item in array.items do new_items.&.push(item)
          new_items.&.set(index, args.item)
          builder.array(new_items.to_slice(), array.item_type)
        } else
          builder.crash("out of bounds", type_array(array.item_type))
  }
  case array_slice(args) {
    var array = args.array
    var start = args.start
    var end = args.end

    switch array.resolve()
    case array(array) {
      | Constant fold.
      if start.resolve() is int(start) then if end.resolve() is int(end) then
        return
          if (0..array.items.len).contains(start)
            and (0..=array.items.len).contains(end)
            and start <= end
          then builder.array(array.items.subslice(start..end), array.item_type)
          else builder.crash("out of bounds", type_array(array.item_type))
    }
    | case array_slice(inner_args) {
    |   var inner_array = inner_args.a
    |   var inner_start = inner_args.b
    |   var inner_end = inner_args.c

    |   | Merge the two nested slice operations into one. This requires explicitly
    |   | performing the checks that the inner slice would have done.
    |   return array_slice(
    |     inner_array,
    |     if_(
    |       compare(inner_start, taco_int(0))
    |         .is_less(),
    |       taco_crash(type_int),
    |       add(inner_start, start),
    |     ),
    |     if_(
    |       compare(
    |         inner_end, array_len(inner_array)
    |       ).is_less_equal(),
    |       add(inner_start, end),
    |       taco_crash(type_int),
    |     ),
    |   )
    | }
    default {}
  }
  case array_len(array) {
    switch array.resolve()
    case array(array)
      | Constant fold.
      return builder.int(array.items.len)
    case generate_array(gen)
      | length(generate_array(length, generator)) = length
      return gen.length
    case array_slice(args)
      | length(slice(array, start, end)) = end - start
      return builder.subtract(args.end, args.start)
    default {}
  }
  case recursive(rec) {
    eprintln("it's recursive")
    if not(rec.body.recurses()) then {
      eprintln("recursive does not recurse")
      return rec.body.fill(rec.initial, builder)
    } else
      eprintln("recursive recurses")

    | Find fixpoints
    | stderr."Optimizing shallow recursive. Args:\n"
    | for arg in rec.initial do {
    |   stderr.write(arg, holes_namespace().&, indentation(1))
    |   stderr."\n"
    | }
    | var mask = rec.b.find_fixpoint_mask(rec.a, context)
    | var new_args = {
    |   var res = list[EggExpr]()
    |   for arg in rec.a.mask(mask) do res.&.push(arg.optimize(context))
    |   res.to_slice()
    | }
    | var new_holes = {
    |   var res = list[Hole]()
    |   for arg in new_args do res.&.push(hole(arg.type))
    |   res.to_slice()
    | }
    | return recursive(
    |   new_args,
    |   body(
    |     new_holes,
    |     rec.b
    |       .fill(new_holes.unmask(mask))
    |       .optimize(context)
    |       .replace_recurses(mask),
    |   )
    | )
  }
  | case recurse(args) {
  |   | Bubble up crashes and both.
  |   for arg in args do if arg.resolve() is crash then return taco_crash(type)
  |   for arg in args.iter().enumerate() do if arg.item.resolve() is both(both) then {
  |     var new_args = list[EggExpr]()
  |     for i in 0..args.len do
  |       new_args.&.push(if i == arg.index then both.b.resolve() else args.get(i))
  |     return both(
  |       both.a.resolve(),
  |       recurse(new_args.to_slice(), expr.type),
  |     )
  |   }

  |   | Push recurse into switch cases.
  |   if args.len == 1 then if args.get(0).resolve() is switch_(switch_) then {
  |     return switch_(switch_.condition.resolve(), type, {
  |       var cases = map[String, EggBody]()
  |       for case_ in switch_.cases do
  |         cases.&.put(
  |           case_.key,
  |           EggBody {
  |             params = case_.value.params,
  |             expr = recurse(list(case_.value.expr).to_slice(), type)
  |               
  |           }
  |         )
  |       cases
  |     })
  |   }
  | }
  default {}

  builder.push(id)
}

fun recurses(body: EggBody): Bool {
  for child in body.children do if child.recurses() then return true
  false
}
fun recurses(id: EggId): Bool {
  switch id.resolve()
  case recursive false
  case recurse true
  default {
    for child in id.children() do if child.recurses() then return true
    false
  }
}

fun children(id: EggId): Slice[EggId] {
  var children = list[EggId]()
  id.visit_children(GatherChildren { children = children.& })
  children.to_slice()
}
struct GatherChildren { children: &List[EggId] }
fun visit(id: EggId, gather: GatherChildren) { gather.children.push(id) }

| | The number of expressions inside this expression.
| fun num_exprs(expr: EggExpr): Int {
|   var num = 1
|   for child in expr.children() do num = num + child.num_exprs()
|   num
| }

| | Converts calls to the given called signature into recurse expressions.
| fun call_to_recurse(
|   expr: EggExpr, called: EggCalledFun, return_type: EggType
| ): EggExpr {
|   expr.map(CallToRecurse { called, return_type })
| }
| fun call_to_recurse(
|   body: EggBody, called: EggCalledFun, return_type: EggType
| ): EggBody {
|   body.map(CallToRecurse { called, return_type })
| }
| struct CallToRecurse { called: EggCalledFun, return_type: EggType }
| fun map(expr: EggExpr, call_to_recurse: CallToRecurse): EggExpr {
|   var expr = expr.map_children(call_to_recurse)
|   if expr.resolve() is call_fun(call) then
|     if call.fun_ == call_to_recurse.called then
|       return recurse(call.args, call_to_recurse.return_type)
|   expr
| }

| Fills the body with concrete arguments for its parameters.
fun fill(body: EggBody, args: Slice[EggId], builder: &EggBodyBuilder): EggId {
  var mapping = map[EggId, EggId]().&
  for both in zip(body.params.iter(), args.iter()) do
    mapping.put(both.a, both.b)
  for old in body.children do {
    var new = old.map(Fill {}, builder, mapping)
    mapping.put(old, new)
  }
  body.returns.map(mapping)
}
fun fill(body: EggBody, arg: EggId, builder: &EggBodyBuilder): EggId {
  body.fill(list(arg).to_slice(), builder)
}
struct Fill {}
fun map(
  expr: EggId, fill: Fill, builder: &EggBodyBuilder, mapping: &Map[EggId, EggId]
): EggId {
  builder.push(expr.map_children(fill, builder, mapping))
}

| fun find_both_independent_of_locals(body: EggBody): Maybe[EggExpr] {
|   var independent = none[EggExpr]()
|   body.expr.visit(FindBothIndependentOfLocals {
|     locals = body.params, independent = independent.&
|   })
|   independent
| }
| struct FindBothIndependentOfLocals {
|   locals: Slice[Hole], independent: &Maybe[EggExpr]
| }
| fun visit(expr: EggExpr, finder: FindBothIndependentOfLocals) {
|   if expr.resolve() is both(both) then {
|     var is_independent = true
|     for captured in both.a.*.collect_captured() do
|       for id in finder.locals do
|         if captured == id then is_independent = false
|     if is_independent then {
|       finder.independent.* = some(both.a.*)
|       return {}
|     }
|   }
|   expr.visit_children(finder)
| }
| fun visit(body: EggBody, finder: FindBothIndependentOfLocals) {}
