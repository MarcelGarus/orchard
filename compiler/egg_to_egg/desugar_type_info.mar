import mod.mar

fun desugar_type_info(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  for fun_ in egg.funs do
    funs.&.put(fun_.key, fun_.value.map(DesugarTypeInfo { funs = funs.& }))
  Egg { funs, entry_point = egg.entry_point }
}

struct DesugarTypeInfo { funs: &Map[String, EggFun] }
fun map(
  id: EggId, desugar: DesugarTypeInfo,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(desugar, mapping)
  if expr is type_info(type) then
    builder.type_info_expr(type.resolve().type.unwrap())
  else
    builder.push(expr)
}

fun type_info_expr(builder: &EggBodyBuilder, type: EggType): EggId {
  var variant_and_payload =
    switch type.internal_kind()
    case variable panic("not monomorphized yet")
    case byte tuple("byte", builder.nothing())
    case int tuple("int", builder.nothing())
    case type tuple("type", builder.nothing())
    case box(inner_type) tuple("box", builder.type_info_expr(inner_type))
    case array(item_type) tuple("array", builder.type_info_expr(item_type))
    case never tuple("never", builder.nothing())
    case struct_(struct_)
      tuple(
        "struct",
        builder.array({
          var fields = list[EggId]()
          for field in struct_ do
            fields.&.push(builder.struct_(map(
              "name" -> builder.string(field.key),
              "type" -> builder.type_info_expr(field.value),
            )))
          fields.to_slice()
        }, type_type_info_fields),
      )
    case enum_(enum_)
      tuple(
        "enum",
        builder.array({
          var variants = list[EggId]()
          for variant in enum_ do
            variants.&.push(builder.struct_(map(
              "name" -> builder.string(variant.key),
              "type" -> builder.type_info_expr(variant.value),
            )))
            variants.to_slice()
        }, type_type_info_variants),
      )
    case lambda(lambda)
      tuple(
        "lambda",
        builder.struct_(map(
          "arguments" -> builder.array({
            var args = list[EggId]()
            for arg in lambda.args do args.&.push(builder.type_info_expr(arg))
            args.to_slice()
          }, type_type_info_lambda_args),
          "return_type" -> builder.type_info_expr(lambda.return_type),
        )),
      )
    case recursive(level) tuple("recursive", builder.int(level))

  builder.enum_(type_type_info, variant_and_payload.a, variant_and_payload.b)
}
