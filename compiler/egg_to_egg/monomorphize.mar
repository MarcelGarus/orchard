import mod.mar

fun specialize(fun_: EggFun, substitutions: Substitutions): EggFun {
  EggFun { body = fun_.body.specialize(substitutions, map[EggId, EggId]().&) }
}
fun specialize(
  body: EggBody, substitutions: Substitutions, mapping: &Map[EggId, EggId]
): EggBody {
  var builder = egg_body_builder().&
  for old in body.params do {
    var new = builder.param(
      old.resolve().param.unwrap().specialize(substitutions)
    )
    mapping.put(old, new)
  }
  for old in body.children do {
    var new = old.map(substitutions, builder, mapping)
    mapping.&.put(old, new)
  }
  builder.finish(mapping.get(body.returns))
}
fun map(
  id: EggId, substitutions: Substitutions,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  switch id.resolve()
  case param unreachable()
  case type(type) return builder.type(type.specialize(substitutions))
  case int {}
  case string {}
  case struct_ {}
  case enum_(enum_)
    return builder.enum_(enum_.type, enum_.variant, enum_.payload.map(mapping))
  case lambda {}
  case member {}
  case switch_(switch_)
    return builder.switch_(switch_.condition.map(mapping), switch_.type, {
      var cases = map[String, EggBody]()
      for case_ in switch_.cases do
        cases.&.put(case_.key, case_.value.map(substitutions, mapping))
      cases
    })
  case call_fun(call)
    return builder.call(
      call.fun_,
      call.substitutions.specialize(substitutions),
      call.args.map(mapping),
      call.return_type.specialize(substitutions),
    )
  case call_lambda {}
  case call_builtin(call)
    return builder.call(
      call.builtin,
      call.substitutions.specialize(substitutions),
      call.args.map(mapping),
    )
  case cast(cast)
    return builder.cast(
      cast.what.map(substitutions, builder, mapping),
      cast.type.specialize(substitutions),
    )
  case byte {}
  case lower_byte {}
  case byte_to_int {}
  case add {}
  case subtract {}
  case multiply {}
  case divide {}
  case modulo {}
  case and_ {}
  case or_ {}
  case xor {}
  case compare {}
  case box {}
  case unbox {}
  case array(array)
    return builder.array(
      array.items.map(mapping), array.item_type.specialize(substitutions)
    )
  case generate_array {}
  case array_get {}
  case array_set {}
  case array_slice {}
  case array_len {}
  case type_info {}
  case static_to_dynamic {}
  case dynamic_to_static(convert)
    return builder.dynamic_to_static(
      convert.dynamic.map(mapping), convert.static.specialize(substitutions)
    )
  case crash(crash)
    return builder.crash(
      crash.message.map(mapping), crash.type.specialize(substitutions)
    )
  case unreachable(type) return builder.unreachable(type)
  case recursive(rec)
    return builder.recursive(
      rec.initial.map(mapping), rec.body.map(substitutions, mapping)
    )
  case recurse(rec)
    return builder.recurse(
      rec.next.map(mapping), rec.type.specialize(substitutions)
    )

  builder.push(id.map_children(substitutions, builder, mapping))
}
