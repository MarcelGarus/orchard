import mod.mar

fun monomorphize(egg: Egg): Egg {
  var funs = map[String, EggFun]()
  var entry_point = egg.entry_point.monomorphize(no_substitutions, egg, funs.&)
  Egg { funs, entry_point }
}
fun monomorphize(
  signature: String, substitutions: Substitutions,
  egg: Egg, out: &Map[String, EggFun],
): String {
  var unspecialized_fun = egg.funs.get(signature)

  if substitutions.substitutions.is_not_empty() then
    signature = "{signature} with {substitutions}"
  if out.contains(signature) then return signature

  out.put(signature, uninitialized[EggFun]().*) | placeholder
  var specialized_fun = unspecialized_fun
    .specialize(substitutions) | specialize all types
    .map(Monomorphize { egg, funs = out }) | replace call_fun exprs by monoing
  out.put(signature, specialized_fun)
  signature
}
struct Monomorphize { egg: Egg, funs: &Map[String, EggFun] }
fun map(
  id: EggId, mono: Monomorphize,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  var expr = id.map_children(mono, mapping)
  return
    if expr is call_fun(call) then
      builder.call(
        call.fun_.monomorphize(call.substitutions, mono.egg, mono.funs),
        no_substitutions,
        call.args,
        call.return_type,
      )
    else builder.push(expr)
}

fun specialize(fun_: EggFun, substitutions: Substitutions): EggFun {
  EggFun { body = fun_.body.specialize(substitutions, map[EggId, EggId]().&) }
}
fun specialize(
  body: EggBody, substitutions: Substitutions, mapping: &Map[EggId, EggId]
): EggBody {
  body.map(substitutions, mapping)
}
fun map(
  body: EggBody, substitutions: Substitutions, mapping: &Map[EggId, EggId]
): EggBody {
  var builder = egg_body_builder().&
  for old in body.params do {
    var new = builder.param(
      old.resolve().param.unwrap().specialize(substitutions)
    )
    mapping.put(old, new)
  }
  for old in body.children do {
    var new = old.map(substitutions, builder, mapping)
    mapping.put(old, new)
  }
  builder.finish(mapping.get(body.returns))
}
fun map(
  id: EggId, substitutions: Substitutions,
  builder: &EggBodyBuilder, mapping: &Map[EggId, EggId],
): EggId {
  switch id.resolve()
  case param unreachable()
  case type(type) return builder.type(type.specialize(substitutions))
  case int {}
  case string {}
  case struct_ {}
  case enum_(enum_)
    return builder.enum_(
      enum_.type.specialize(substitutions),
      enum_.variant,
      enum_.payload.map(mapping),
    )
  case lambda {}
  case member {}
  case switch_(switch_)
    return builder.switch_(
      switch_.condition.map(mapping),
      switch_.type.specialize(substitutions),
      {
        var cases = map[String, EggBody]()
        for case_ in switch_.cases do
          cases.&.put(case_.key, case_.value.map(substitutions, mapping))
        cases
      },
    )
  case call_fun(call)
    return builder.call(
      call.fun_,
      call.substitutions.specialize(substitutions),
      call.args.map(mapping),
      call.return_type.specialize(substitutions),
    )
  case call_lambda {}
  case call_builtin(call)
    return builder.call(
      call.builtin,
      call.substitutions.specialize(substitutions),
      call.args.map(mapping),
    )
  case cast(cast)
    return builder.cast(
      cast.what.map(substitutions, builder, mapping),
      cast.type.specialize(substitutions),
    )
  case byte {}
  case lower_byte {}
  case byte_to_int {}
  case add {}
  case subtract {}
  case multiply {}
  case divide {}
  case modulo {}
  case and_ {}
  case or_ {}
  case xor {}
  case compare {}
  case unchecked_divide {}
  case unchecked_modulo {}
  case box {}
  case unbox {}
  case array(array)
    return builder.array(
      array.items.map(mapping), array.item_type.specialize(substitutions)
    )
  case generate_array {}
  case array_get {}
  case array_set {}
  case array_slice {}
  case array_len {}
  case unchecked_generate_non_empty_array {}
  case unchecked_array_get {}
  case unchecked_array_set {}
  case unchecked_array_slice {}
  case type_info {}
  case static_to_dynamic {}
  case dynamic_to_static(convert)
    return builder.dynamic_to_static(
      convert.dynamic.map(mapping), convert.static.specialize(substitutions)
    )
  case crash(crash)
    return builder.crash(
      crash.message.map(mapping), crash.type.specialize(substitutions)
    )
  case unreachable(type) return builder.unreachable(type)
  case recursive(rec)
    return builder.recursive(
      rec.initial.map(mapping), rec.body.map(substitutions, mapping)
    )
  case recurse(rec)
    return builder.recurse(
      rec.next.map(mapping), rec.type.specialize(substitutions)
    )

  builder.push(id.map_children(substitutions, mapping))
}
