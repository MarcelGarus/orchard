import mod.mar

fun expr(op: PuddingOp, type: EggType): PuddingExpr { PuddingExpr { op, type } }

fun body(params: Slice[Hole], expr: PuddingExpr): PuddingBody {
  PuddingBody { params, expr }
}
fun body(param: Hole, expr: PuddingExpr): PuddingBody {
  body(list(param).to_slice(), expr)
}

fun pudding_hole(hole: Hole): PuddingExpr {
  PuddingOp.hole(hole).expr(hole.type)
}
fun dup(hole: Hole): PuddingExpr {
  PuddingOp.dup(hole).expr(type_nothing)
}
fun drop(hole: Hole): PuddingExpr {
  PuddingOp.drop(hole).expr(type_nothing)
}
fun pudding_type(type: EggType): PuddingExpr {
  PuddingOp.type(type).expr(type_type)
}
fun pudding_byte(byte: Byte): PuddingExpr {
  PuddingOp.byte(byte).expr(type_byte)
}
fun pudding_int(int: Int): PuddingExpr { PuddingOp.int(int).expr(type_int) }
fun array(item_type: EggType, items: Slice[PuddingExpr]): PuddingExpr {
  PuddingOp.array(items).expr(type_array(item_type))
}
fun struct_(fields: Map[String, PuddingExpr]): PuddingExpr {
  var field_types = map[String, EggType]()
  for field in fields do field_types.&.put(field.key, field.value.type)
  PuddingOp.struct_(fields).expr(type_struct(field_types))
}
fun enum_(type: EggType, variant: String, payload: PuddingExpr): PuddingExpr {
  PuddingOp.enum_(PuddingEnum { variant, payload = payload.put_on_heap() })
    .expr(type)
}
fun lambda(type: EggType, function: String, closure: PuddingExpr): PuddingExpr {
  PuddingOp.lambda(PuddingLambda { function, closure = closure.put_on_heap() })
    .expr(type)
}
fun box(inner: PuddingExpr): PuddingExpr {
  PuddingOp.box(inner.put_on_heap()).expr(type_box(inner.type))
}
fun member(of: PuddingExpr, name: String): PuddingExpr {
  PuddingOp.member(PuddingMember { of = of.put_on_heap(), name })
    .expr(of.type.kind().struct_.unwrap().get(name))
}
fun switch_(
  condition: PuddingExpr, type: EggType, cases: Map[String, PuddingBody]
): PuddingExpr {
  PuddingOp.switch_(PuddingSwitch {
    condition = condition.put_on_heap(), cases
  }).expr(type)
}
fun call(
  fun_: String, args: Slice[PuddingExpr], return_type: EggType
): PuddingExpr {
  PuddingOp.call_fun(PuddingCallFun { fun_, args }).expr(return_type)
}
fun call(lambda: PuddingExpr, args: Slice[PuddingExpr]): PuddingExpr {
  PuddingOp.call_lambda(PuddingCallLambda {
    lambda = lambda.put_on_heap(), args
  }).expr(lambda.type.kind().lambda.unwrap().return_type)
}
fun both(ignored: PuddingExpr, result: PuddingExpr): PuddingExpr {
  PuddingOp.both(tuple(ignored.put_on_heap(), result.put_on_heap()))
    .expr(result.type)
}
fun let(def: PuddingExpr, body: PuddingBody): PuddingExpr {
  PuddingOp.let(PuddingLet {
    def = def.put_on_heap(), body = body.put_on_heap()
  }).expr(body.expr.type)
}
| fun lets(lets: Slice[Tuple2[Hole, PuddingExpr]], returns: PuddingExpr): PuddingExpr {
|   var result = returns
|   for child in lets.rev_iter() do result = let(child.a, child.b, result)
|   result
| }
fun lower_byte(int: PuddingExpr): PuddingExpr {
  PuddingOp.lower_byte(int.put_on_heap()).expr(type_byte)
}
fun byte_to_int(byte: PuddingExpr): PuddingExpr {
  PuddingOp.byte_to_int(byte.put_on_heap()).expr(type_int)
}
fun add(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.add_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun subtract(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.sub_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun multiply(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.mul_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun divide(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.div_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun modulo(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.mod_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun and_(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.and_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun or_(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.or_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun xor(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.xor_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun compare(a: PuddingExpr, b: PuddingExpr): PuddingExpr {
  PuddingOp.compare_ints(tuple(a.put_on_heap(), b.put_on_heap()))
    .expr(type_ordering)
}
fun unbox(box: PuddingExpr): PuddingExpr {
  PuddingOp.unbox(box.put_on_heap()).expr(box.type.kind().box.unwrap())
}
fun generate_array(length: PuddingExpr, generator: PuddingBody): PuddingExpr {
  PuddingOp.generate_array(PuddingGenerateArray {
    length = length.put_on_heap(), generator = generator.put_on_heap()
  }).expr(type_array(generator.expr.type))
}
fun array_get(array: PuddingExpr, index: PuddingExpr): PuddingExpr {
  PuddingOp.array_get(tuple(array.put_on_heap(), index.put_on_heap()))
    .expr(array.type.kind().array.unwrap())
}
fun array_set(array: PuddingExpr, index: PuddingExpr, item: PuddingExpr): PuddingExpr {
  PuddingOp.array_set(tuple(
    array.put_on_heap(), index.put_on_heap(), item.put_on_heap()
  )).expr(array.type)
}
fun array_slice(array: PuddingExpr, start: PuddingExpr, end: PuddingExpr): PuddingExpr {
  PuddingOp.array_slice(tuple(
    array.put_on_heap(), start.put_on_heap(), end.put_on_heap()
  )).expr(array.type)
}
fun array_len(array: PuddingExpr): PuddingExpr {
  PuddingOp.array_len(array.put_on_heap()).expr(type_int)
}
fun pudding_crash(type: EggType): PuddingExpr { PuddingOp.crash.expr(type) }
fun recursive(initial: Slice[PuddingExpr], body: PuddingBody): PuddingExpr {
  PuddingOp.recursive(PuddingRecursive { initial, body = body.put_on_heap() })
    .expr(body.expr.type)
}
fun recurse(args: Slice[PuddingExpr], type: EggType): PuddingExpr {
  PuddingOp.recurse(args).expr(type)
}
fun pudding_unreachable(type: EggType): PuddingExpr { PuddingOp.unreachable.expr(type) }

var pudding_nothing = struct_(map[String, PuddingExpr]())
var pudding_true = enum_(type_bool, "true", pudding_nothing)
var pudding_false = enum_(type_bool, "false", pudding_nothing)
fun pudding_string(string: String): PuddingExpr {
  var bytes = list[PuddingExpr]()
  for byte in string.bytes() do bytes.&.push(pudding_byte(byte))
  struct_(map("utf8_bytes" -> array(type_byte, bytes.to_slice())))
}
fun if_(condition: PuddingExpr, then_: PuddingExpr, else_: PuddingExpr): PuddingExpr {
  switch_(condition, then_.type, map(
    "true" -> body(hole(type_nothing), then_),
    "false" -> body(hole(type_nothing), else_),
  ))
}
fun switch_on_ordering(
  ordering: PuddingExpr, less: PuddingExpr, equal: PuddingExpr, greater: PuddingExpr
): PuddingExpr {
  switch_(ordering, less.type, map(
    "less" -> body(hole(type_nothing), less),
    "equal" -> body(hole(type_nothing), equal),
    "greater" -> body(hole(type_nothing), greater),
  ))
}
fun is_equal(ordering: PuddingExpr): PuddingExpr {
  switch_on_ordering(ordering, pudding_false, pudding_true, pudding_false)
}
fun is_greater_equal(ordering: PuddingExpr): PuddingExpr {
  switch_on_ordering(ordering, pudding_false, pudding_true, pudding_true)
}
fun is_greater(ordering: PuddingExpr): PuddingExpr {
  switch_on_ordering(ordering, pudding_false, pudding_false, pudding_true)
}
fun is_less(ordering: PuddingExpr): PuddingExpr {
  switch_on_ordering(ordering, pudding_true, pudding_false, pudding_false)
}
fun is_less_equal(ordering: PuddingExpr): PuddingExpr {
  switch_on_ordering(ordering, pudding_true, pudding_true, pudding_false)
}


fun put_dup(dag: &Dag[PuddingExpr], id: Id): Id {
  dag.put(PuddingOp.dup(id) $ type_never)
}
fun put_drop(dag: &Dag[PuddingExpr], id: Id): Id {
  dag.put(PuddingOp.drop(id) $ type_never)
}


