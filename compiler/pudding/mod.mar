| Program Using Dup and Drop Instructions to Neutralize Garbage  
|
| In this representation, we have explicit dup and drop instructions for
| tracking how many references to each value exist. Not all of them actually
| correspond to reference counting instructions as not all values require heap
| allocations.

import ../plum.mar
import builder.mar
import format.mar
| import run.mar

struct Pudding { entry_point: String, funs: Map[String, PuddingFun] }

struct PuddingId { id: Id }
fun ==(a: PuddingId, b: PuddingId): Bool { a.id == b.id  }
fun hash[H](hasher: H, id: PuddingId) { hasher.hash(id.id) }
fun resolve(id: PuddingId): PuddingExpr { pudding_dag.get(id.id) }

struct PuddingFun { body: PuddingBody }
struct PuddingBody {
  params: Slice[PuddingId], children: Slice[PuddingId], returns: PuddingId
}
struct PuddingExpr { op: PuddingOp, type: EggType }
enum PuddingOp {
  param,

  dup: PuddingId,
  drop: PuddingId,

  byte: Byte,
  lower_byte: PuddingId,
  byte_to_int: PuddingId,

  int: Int,
  add: Tuple2[PuddingId, PuddingId],
  subtract: Tuple2[PuddingId, PuddingId],
  multiply: Tuple2[PuddingId, PuddingId],
  divide: Tuple2[PuddingId, PuddingId],
  modulo: Tuple2[PuddingId, PuddingId],
  and_: Tuple2[PuddingId, PuddingId],
  or_:  Tuple2[PuddingId, PuddingId],
  xor: Tuple2[PuddingId, PuddingId],
  compare: Tuple2[PuddingId, PuddingId],

  struct_: Map[String, PuddingId],
  member: PuddingMember,

  enum_: PuddingEnum,
  switch_: PuddingSwitch,

  lambda: PuddingLambda,
  call_fun: PuddingCallFun,
  call_lambda: PuddingCallLambda,

  box: PuddingId,
  unbox: PuddingId,

  array: Slice[PuddingId],
  generate_array: PuddingGenerateArray,
  array_get: Tuple2[PuddingId, PuddingId],
  array_set: Tuple3[PuddingId, PuddingId, PuddingId],
  array_slice: Tuple3[PuddingId, PuddingId, PuddingId],
  array_len: PuddingId,

  type: EggType,

  crash: PuddingId,
  unreachable,

  | recursive: PuddingRecursive,
  | recurse: Slice[PuddingId],
}
struct PuddingMember { of: PuddingId, name: String }
struct PuddingEnum { variant: String, payload: PuddingId }
struct PuddingSwitch { condition: PuddingId, cases: Map[String, PuddingBody] }
struct PuddingLambda { function: String, closure: PuddingId }
struct PuddingCallFun { fun_: String, args: Slice[PuddingId] }
struct PuddingCallLambda { lambda: PuddingId, args: Slice[PuddingId] }
struct PuddingGenerateArray { length: PuddingId, generator: PuddingBody }
| struct PuddingRecursive { args: Slice[Hole], body: PuddingId }
