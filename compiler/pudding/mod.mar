| Program Using Dup and Drop Instructions to Neutralize Garbage  
|
| In this representation, we have explicit dup and drop instructions for
| tracking how many references to each value exist. Not all of them actually
| correspond to reference counting instructions as not all values require heap
| allocations.

import ../plum.mar
import builder.mar
import format.mar
| import run.mar

struct Pudding { entry_point: String, funs: Map[String, PuddingBody] }

struct PuddingBody { params: Slice[Hole], expr: PuddingExpr }
struct PuddingExpr { op: PuddingOp, type: EggType }
enum PuddingOp {
  hole: Hole,
  dup: Hole,
  drop: Hole,

  type: EggType,
  byte: Byte,
  int: Int,
  array: Slice[PuddingExpr],
  struct_: Map[String, PuddingExpr],
  enum_: PuddingEnum,
  lambda: PuddingLambda,
  box: &PuddingExpr,

  member: PuddingMember,
  switch_: PuddingSwitch,
  call_fun: PuddingCallFun,
  call_lambda: PuddingCallLambda,

  both: Tuple2[&PuddingExpr, &PuddingExpr],
  let: PuddingLet,

  lower_byte: &PuddingExpr,
  byte_to_int: &PuddingExpr,
  add_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  sub_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  mul_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  div_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  mod_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  and_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  or_ints:  Tuple2[&PuddingExpr, &PuddingExpr],
  xor_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  compare_ints: Tuple2[&PuddingExpr, &PuddingExpr],
  unbox: &PuddingExpr,
  generate_array: PuddingGenerateArray,
  array_get: Tuple2[&PuddingExpr, &PuddingExpr],
  array_set: Tuple3[&PuddingExpr, &PuddingExpr, &PuddingExpr],
  array_slice: Tuple3[&PuddingExpr, &PuddingExpr, &PuddingExpr],
  array_len: &PuddingExpr,
  crash,

  | recursive: PuddingRecursive,
  | recurse: Slice[PuddingExpr],

  unreachable,
}
struct PuddingEnum { variant: String, payload: &PuddingExpr }
struct PuddingLambda { function: String, closure: &PuddingExpr }
struct PuddingMember { of: &PuddingExpr, name: String }
struct PuddingSwitch {
  condition: &PuddingExpr, cases: Map[String, PuddingBody]
}
struct PuddingCallFun { fun_: String, args: Slice[PuddingExpr] }
struct PuddingCallLambda { lambda: &PuddingExpr, args: Slice[PuddingExpr] }
struct PuddingLet { def: &PuddingExpr, body: &PuddingBody }
struct PuddingGenerateArray { length: &PuddingExpr, generator: &PuddingBody }
struct PuddingRecursive { args: Slice[Hole], body: &PuddingExpr }
