import mod.mar

fun is_pure(expr: WaffleExpr): Bool {
  switch expr.kind
  case param false
  case padding true
  case byte true
  case int true
  case local true
  case aggregate(aggregate) {
    for part in aggregate do if not(part.is_pure()) then return false
    true
  }
  case member(member) member.of.is_pure()
  case switch_(switch_) {
    if not(switch_.byte.is_pure()) then return false
    false | TODO
    | for case_ in switch_.cases do case_.collect_referenced(dag, out)
  }
  case call false
  case call_indirect false
  case function_ptr true
  case add(args) args.is_pure()
  case sub(args) args.is_pure()
  case mul(args) args.is_pure()
  case div(args) args.is_pure()
  case mod(args) args.is_pure()
  case compare_zero(arg) arg.is_pure()
  case and_(args) args.is_pure()
  case or_(args)  args.is_pure()
  case xor(args)  args.is_pure()
  case malloc(size) size.is_pure()
  case free(args) args.is_pure()
  case load(ptr) ptr.is_pure()
  case store(store) {
    store.ptr.is_pure()
    store.value.is_pure()
  }
  case crash(args) args.is_pure()
}

fun collect_referenced(expr: WaffleExpr, dag: Dag[WaffleExpr], out: &Set[Id]) {
  switch expr.kind
  case param {}
  case padding {}
  case byte {}
  case int {}
  case local(id) out.put(id)
  case aggregate(aggregate)
    for part in aggregate do part.collect_referenced(dag, out)
  case member(member) member.of.collect_referenced(dag, out)
  case switch_(switch_) {
    switch_.byte.collect_referenced(dag, out)
    for case_ in switch_.cases do case_.collect_referenced(dag, out)
  }
  case call(call) call.args.collect_referenced(dag, out)
  case call_indirect(call) {
    call.function_ptr.collect_referenced(dag, out)
    call.args.collect_referenced(dag, out)
  }
  case function_ptr(signature) {}
  case add(args) args.collect_referenced(dag, out)
  case sub(args) args.collect_referenced(dag, out)
  case mul(args) args.collect_referenced(dag, out)
  case div(args) args.collect_referenced(dag, out)
  case mod(args) args.collect_referenced(dag, out)
  case compare_zero(arg) arg.collect_referenced(dag, out)
  case and_(args) args.collect_referenced(dag, out)
  case or_(args)  args.collect_referenced(dag, out)
  case xor(args)  args.collect_referenced(dag, out)
  case malloc(size) size.collect_referenced(dag, out)
  case free(args) args.collect_referenced(dag, out)
  case load(ptr) ptr.collect_referenced(dag, out)
  case store(store) {
    store.ptr.collect_referenced(dag, out)
    store.value.collect_referenced(dag, out)
  }
  case crash(args) args.collect_referenced(dag, out)
}
fun collect_referenced(body: WaffleBody, dag: Dag[WaffleExpr], out: &Set[Id]) {
  for local in body.locals do dag.get(local).collect_referenced(dag, out)
}

fun tree_shake(expr: WaffleExpr, dag: &Dag[WaffleExpr]): WaffleExpr {
  var kind =
    switch expr.kind
    case param unreachable()
    case padding(amount) WaffleExprKind.padding(amount)
    case byte(byte) WaffleExprKind.byte(byte)
    case int(int) WaffleExprKind.int(int)
    case local(local) WaffleExprKind.local(local)
    case aggregate(aggregate) {
      var parts = list[WaffleExpr]()
      for part in aggregate do parts.&.push(part.tree_shake(dag))
      WaffleExprKind.aggregate(parts.to_slice())
    }
    case member(member) {
      WaffleExprKind.member(WaffleMember {
        of = member.of.tree_shake(dag).put_on_heap(),
        offset = member.offset,
      })
    }
    case switch_(switch_) {
      var cases = list[WaffleBody]()
      for case_ in switch_.cases do cases.&.push(case_.tree_shake(dag))
      WaffleExprKind.switch_(WaffleSwitch {
        byte = switch_.byte.tree_shake(dag).put_on_heap(),
        cases = cases.to_slice(),
      })
    }
    case call(call) {
      WaffleExprKind.call(WaffleCall {
        function = call.function,
        args = call.args.tree_shake(dag).put_on_heap(),
      })
    }
    case call_indirect(call) {
      WaffleExprKind.call_indirect(WaffleCallIndirect {
        function_ptr = call.function_ptr.tree_shake(dag).put_on_heap(),
        args = call.args.tree_shake(dag).put_on_heap(),
      })
    }
    case function_ptr(signature) WaffleExprKind.function_ptr(signature)
    case add(args) WaffleExprKind.add(args.tree_shake(dag).put_on_heap())
    case sub(args) WaffleExprKind.sub(args.tree_shake(dag).put_on_heap())
    case mul(args) WaffleExprKind.mul(args.tree_shake(dag).put_on_heap())
    case div(args) WaffleExprKind.div(args.tree_shake(dag).put_on_heap())
    case mod(args) WaffleExprKind.mod(args.tree_shake(dag).put_on_heap())
    case compare_zero(arg)
      WaffleExprKind.compare_zero(arg.tree_shake(dag).put_on_heap())
    case and_(args)   WaffleExprKind.and_(args.tree_shake(dag).put_on_heap())
    case or_(args)    WaffleExprKind.or_(args.tree_shake(dag).put_on_heap())
    case xor(args)    WaffleExprKind.xor(args.tree_shake(dag).put_on_heap())
    case malloc(size) WaffleExprKind.malloc(size.tree_shake(dag).put_on_heap())
    case free(free)   WaffleExprKind.free(free.tree_shake(dag).put_on_heap())
    case load(ptr)    WaffleExprKind.load(ptr.tree_shake(dag).put_on_heap())
    case store(store) 
      WaffleExprKind.store(WaffleStore {
        ptr = store.ptr.tree_shake(dag).put_on_heap(),
        value = store.value.tree_shake(dag).put_on_heap(),
      })
    case crash(args) WaffleExprKind.crash(args.tree_shake(dag).put_on_heap())

  WaffleExpr { kind, size = expr.size, alignment = expr.alignment }
}

| Assumes parameters to be in the mapping.
fun tree_shake(body: WaffleBody, dag: &Dag[WaffleExpr]): WaffleBody {
  var referenced_later_on = set[Id]()
  var rev_locals = list[Id]()

  for local in body.locals.rev_iter() do {
    var expr = dag.get(local)

    if not(referenced_later_on.contains(local)) and expr.is_pure() then continue
    var expr = expr.tree_shake(dag)
    expr.collect_referenced(dag.*, referenced_later_on.&)
    dag.set(local, expr)
    rev_locals.&.push(local)
  }
  var locals = list[Id]()
  for id in rev_locals.to_slice().rev_iter() do locals.&.push(id)

  WaffleBody { locals = locals.to_slice(), returns = body.returns }
}
