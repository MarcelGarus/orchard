| Program Using Dup and Drop Instructions to Neutralize Garbage  

import plum.mar

struct Pudding { funs: Map[String, PuddingFun] }

struct PuddingFun {
  dag: Dag[PuddingExpr], captures: Maybe[Slice[Id]], body: PuddingBody
}
struct PuddingBody { params: Slice[Id], exprs: Slice[Id], returns: Id }
struct PuddingExpr { op: PuddingOp, type: PlumType }

enum PuddingOp {
  param,
  uninitialized,
  int: Int,
  string: String,
  type: PlumType,
  struct_: Map[String, Id],
  member: PuddingMember,
  enum_: PuddingEnum,
  switch_: PuddingSwitch,
  lambda: PuddingLambda,
  lambda_call: PuddingLambdaCall,
  call: PuddingCall,
  instruction: PuddingInstruction,
  dup: Id,
  drop: Id,
}
struct PuddingMember { of: Id, name: String }
struct PuddingSwitch { condition: Id, cases: Map[String, PuddingBody] }
struct PuddingEnum { name: String, value: Id }
struct PuddingLambda { function: String, captures: Slice[Id] }
struct PuddingLambdaCall { lambda: Id, args: Slice[Id] }
struct PuddingCall { function: String, args: Slice[Id] }
struct PuddingInstruction { instruction: Instruction, args: Slice[Id] }

| Constructing Pudding  

fun pudding(): Pudding { Pudding { funs = map[String, PuddingFun]() } }

fun $(op: PuddingOp, type: PlumType): _ { PuddingExpr { op, type } }

struct PuddingBodyBuilder {
  dag: &Dag[PuddingExpr], params: List[Id], exprs: List[Id]
}

fun body_builder(dag: &Dag[PuddingExpr]): PuddingBodyBuilder {
  PuddingBodyBuilder { dag, params = list[Id](), exprs = list[Id]() }
}
fun push_param(builder: &PuddingBodyBuilder, type: PlumType): Id {
  var id = builder.dag.put(PuddingOp.param $ type)
  builder.params.&.push(id)
  id
}
fun push(builder: &PuddingBodyBuilder, expr: PuddingExpr): Id {
  var id = builder.dag.put(expr)
  builder.exprs.&.push(id)
  id
}
fun get(builder: PuddingBodyBuilder, id: Id): PuddingExpr {
  builder.dag.get(id)
}
fun finish(builder: PuddingBodyBuilder, returns: Id): PuddingBody {
  PuddingBody {
    params = builder.params.to_slice(),
    exprs = builder.exprs.to_slice(),
    returns,
  }
}

fun return_type(fun_: PuddingFun): PlumType { fun_.get(fun_.body.returns).type }

| Writing Pudding  

fun write[W](writer: W, pudding: Pudding) {
  var first = true
  for fun_ in pudding.funs do {
    if first then first = false else writer."\n"
    writer."{fun_.key}:"
    if fun_.value.captures is some(captures) then {
      writer." (captures "
      for capture in captures do writer." {capture}"
      writer.")"
    }
    writer.write(fun_.value.body, fun_.value, 1)
  }
}
fun write[W](writer: W, body: PuddingBody, fun_: PuddingFun, indentation: Int) {
  for param in body.params do writer." {param}"
  writer."\n"
  for id in body.exprs do {
    var expr = fun_.dag.get(id)
    for i in 0..indentation do writer."  "
    writer."{id}: {expr.type} = "
    writer.write(expr.op, fun_, indentation)
    writer."\n"
  }
  for i in 0..indentation do writer."  "
  writer."{body.returns}"
}
fun write[W](writer: W, op: PuddingOp, fun_: PuddingFun, indentation: Int) {
  switch op
  case uninitialized writer."uninitialized"
  case int(int) writer."{int}"
  case string(string) writer."{string.debug()}"
  case type(type) writer."{type}"
  case param(param) writer."param {param}"
  case struct_(struct_) {
    writer."&"
    for field in struct_ do writer." {field.key}: {field.value}"
  }
  case member(member) writer."{member.of}.{member.name}"
  case enum_(enum_) writer."| {enum_.name} {enum_.value}"
  case switch_(switch_) {
    writer."switch {switch_.condition}"
    for case_ in switch_.cases do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  {case_.key}:"
      writer.write(case_.value, fun_, indentation + 2)
    }
  }
  case lambda(lambda) {
    writer."lambda [capturing"
    for capture in lambda.captures do writer." {capture}"
    writer."] {lambda.function}"
  }
  case lambda_call(call) {
    writer."call {call.lambda}"
    for arg in call.args do writer." {arg}"
  }
  case call(call) {
    writer."call \"{call.function}\""
    for arg in call.args do writer." {arg}"
  }
  case instruction(instruction) {
    writer."instruction {instruction.instruction}"
    for arg in instruction.args do writer." {arg}"
  }
  case dup(id) writer."dup {id}"
  case drop(id) writer."drop {id}"
}
