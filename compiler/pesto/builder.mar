import mod.mar

struct PestoBodyBuilder { param: PestoId, children: List[PestoId] }

fun pesto_body_builder(param: PestoType): PestoBodyBuilder {
  var param = create(PestoOp.param, param)
  PestoBodyBuilder { param, children = list[PestoId]() }
}
fun push(builder: &PestoBodyBuilder, op: PestoOp, type: PestoType): PestoId {
  var id = create(op, type)
  builder.children.&.push(id)
  id
}
fun finish(builder: PestoBodyBuilder, returns: PestoId): PestoBody {
  PestoBody {
    param = builder.param, children = builder.children.to_slice(), returns
  }
}
fun finish_with_nothing(builder: PestoBodyBuilder): PestoBody {
  builder.finish(builder.&.struct_(map[String, PestoId]()))
}
fun finish_with_crash(builder: PestoBodyBuilder, message: String): PestoBody {
  builder.finish(builder.&.crash(message))
}
fun finish_with_unreachable(
  builder: PestoBodyBuilder, type: PestoType
): PestoBody {
  builder.finish(builder.&.unreachable(type))
}

| Operations

fun byte(builder: &PestoBodyBuilder, byte: Byte): PestoId {
  builder.push(PestoOp.byte(byte), PestoType.byte)
}

fun lower_byte(builder: &PestoBodyBuilder, int: PestoId): PestoId {
  int.resolve().type == PestoType.int or panic("lower_byte expects int")
  builder.push(PestoOp.lower_byte(int), PestoType.byte)
}

fun byte_to_int(builder: &PestoBodyBuilder, byte: PestoId): PestoId {
  byte.resolve().type == PestoType.byte or panic("byte_to_int expects byte")
  builder.push(PestoOp.byte_to_int(byte), PestoType.int)
}

fun int(builder: &PestoBodyBuilder, int: Int): PestoId {
  builder.push(PestoOp.int(int), PestoType.int)
}

fun add(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("add on non-int")
  b.resolve().type == PestoType.int or panic("add on non-int")
  builder.push(PestoOp.add(tuple(a, b)), PestoType.int)
}

fun subtract(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("subtract on non-int")
  b.resolve().type == PestoType.int or panic("subtract on non-int")
  builder.push(PestoOp.subtract(tuple(a, b)), PestoType.int)
}

fun multiply(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("multiply on non-int")
  b.resolve().type == PestoType.int or panic("multiply on non-int")
  builder.push(PestoOp.multiply(tuple(a, b)), PestoType.int)
}

fun divide(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("divide on non-int")
  b.resolve().type == PestoType.int or panic("divide on non-int")
  builder.push(PestoOp.divide(tuple(a, b)), PestoType.int)
}

fun modulo(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("modulo on non-int: {a.resolve().debug()}")
  b.resolve().type == PestoType.int or panic("modulo on non-int: {b.resolve().debug()}")
  builder.push(PestoOp.modulo(tuple(a, b)), PestoType.int)
}

fun and_(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("and on non-int")
  b.resolve().type == PestoType.int or panic("and on non-int")
  builder.push(PestoOp.and_(tuple(a, b)), PestoType.int)
}

fun or_(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("or on non-int")
  b.resolve().type == PestoType.int or panic("or on non-int")
  builder.push(PestoOp.or_(tuple(a, b)), PestoType.int)
}

fun xor(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("xor on non-int")
  b.resolve().type == PestoType.int or panic("xor on non-int")
  builder.push(PestoOp.xor(tuple(a, b)), PestoType.int)
}

fun compare(builder: &PestoBodyBuilder, a: PestoId, b: PestoId): PestoId {
  a.resolve().type == PestoType.int or panic("compare on non-int")
  b.resolve().type == PestoType.int or panic("compare on non-int")
  builder.push(
    PestoOp.compare(tuple(a, b)),
    PestoType.enum_(map(
      "less" -> pesto_nothing_type,
      "greater" -> pesto_nothing_type,
      "equal" -> pesto_nothing_type,
    )),
  )
}

fun struct_(builder: &PestoBodyBuilder, fields: Map[String, PestoId]): PestoId {
  var field_types = map[String, PestoType]()
  for field in fields do
    field_types.&.put(field.key, field.value.resolve().type)
  var type = PestoType.struct_(field_types)
  builder.push(PestoOp.struct_(fields), type)
}

fun member(builder: &PestoBodyBuilder, of: PestoId, name: String): PestoId {
  var type = of.resolve().type.struct_.unwrap().get(name)
  builder.push(PestoOp.member(PestoMember { of, name }), type)
}

fun enum_(
  builder: &PestoBodyBuilder, variant: String, payload: PestoId, type: PestoType
): PestoId {
  builder.push(PestoOp.enum_(PestoEnum { variant, payload }), type)
}

fun switch_(
  builder: &PestoBodyBuilder, condition: PestoId, cases: Map[String, PestoBody]
): PestoId {
  var type = none[PestoType]()
  for case_ in cases do {
    var t = case_.value.returns.resolve().type
    if t is never then continue

    switch type
    case none type = some(t)
    case some(type) if type != t then panic("{type} and {t} are incompatible")
  }
  var type = type.unwrap()
  builder.push(PestoOp.switch_(PestoSwitch { condition, cases }), type)
}

fun function_ptr(builder: &PestoBodyBuilder, function: String): PestoId {
  builder.push(PestoOp.function_ptr(function), PestoType.ptr)
}

fun call(
  builder: &PestoBodyBuilder, function: String, args: PestoId,
  return_type: PestoType,
): PestoId {
  builder.push(PestoOp.call(PestoCall { function, args }), return_type)
}

fun call_indirect(
  builder: &PestoBodyBuilder, function: PestoId, args: PestoId,
  return_type: PestoType,
): PestoId {
  builder.push(
    PestoOp.call_indirect(PestoCallIndirect { function, args }), return_type
  )
}

fun new(builder: &PestoBodyBuilder, value: PestoId): PestoId {
  builder.push(PestoOp.new(PestoNew { value, refcount = 1 }), PestoType.ptr)
}

fun load(builder: &PestoBodyBuilder, ptr: PestoId, type: PestoType): PestoId {
  ptr.resolve().type == PestoType.ptr or
    panic("load of non-ptr {ptr.resolve().debug()}")
  builder.push(PestoOp.load(ptr), type)
}

fun free(builder: &PestoBodyBuilder, ptr: PestoId, type: PestoType): PestoId {
  ptr.resolve().type == PestoType.ptr or panic("free of non-ptr")
  builder.push(
    PestoOp.free(PestoFree { ptr, type }),
    pesto_nothing_type,
  )
}

fun get_refcount(builder: &PestoBodyBuilder, ptr: PestoId): PestoId {
  ptr.resolve().type == PestoType.ptr or panic("get refcount of non-ptr")
  builder.push(PestoOp.get_refcount(ptr), PestoType.int)
}

fun increment_refcount(builder: &PestoBodyBuilder, ptr: PestoId): PestoId {
  ptr.resolve().type == PestoType.ptr or panic("increment refcount of non-ptr")
  builder.push(PestoOp.increment_refcount(ptr), PestoType.int)
}

fun decrement_refcount(builder: &PestoBodyBuilder, ptr: PestoId): PestoId {
  ptr.resolve().type == PestoType.ptr or panic("decrement refcount of non-ptr")
  builder.push(PestoOp.decrement_refcount(ptr), PestoType.int)
}

fun new_buffer(builder: &PestoBodyBuilder, item_type: PestoType, len: PestoId): PestoId {
  len.resolve().type == PestoType.int or panic("new_buffer with non-int length")
  builder.push(
    PestoOp.new_buffer(PestoNewBuffer { item_type, len, refcount = 1 }),
    PestoType.ptr,
  )
}

fun get_buffer_len(builder: &PestoBodyBuilder, buffer: PestoId): PestoId {
  buffer.resolve().type == PestoType.ptr or panic("get_buffer_len of non-ptr")
  builder.push(PestoOp.get_buffer_len(buffer), PestoType.int)
}

fun load_buffer_item(
  builder: &PestoBodyBuilder, buffer: PestoId, item_type: PestoType, index: PestoId
): PestoId {
  buffer.resolve().type == PestoType.ptr or panic("load buffer item of non-ptr")
  builder.push(
    PestoOp.load_buffer_item(PestoLoadBufferItem {
      buffer, item_type, index
    }),
    item_type,
  )
}

fun store_buffer_item(
  builder: &PestoBodyBuilder, buffer: PestoId, index: PestoId, item: PestoId
): PestoId {
  var item_type = item.resolve().type
  builder.push(
    PestoOp.store_buffer_item(PestoStoreBufferItem {
      buffer, item_type, index, item
    }),
    pesto_nothing_type,
  )
}

fun store_buffer_bytes(
  builder: &PestoBodyBuilder, buffer: PestoId, bytes: Slice[Byte]
): PestoId {
  builder.push(
    PestoOp.store_buffer_bytes(PestoStoreBufferBytes { buffer, bytes }),
    pesto_nothing_type,
  )
}

fun free_buffer(
  builder: &PestoBodyBuilder, buffer: PestoId, item_type: PestoType
): PestoId {
  buffer.resolve().type == PestoType.ptr or panic("free_buffer of non-ptr")
  builder.push(
    PestoOp.free_buffer(PestoFreeBuffer { buffer, item_type }),
    pesto_nothing_type,
  )
}


fun crash(builder: &PestoBodyBuilder, message: PestoId): PestoId {
  builder.push(PestoOp.crash(message), PestoType.never)
}

fun unreachable(builder: &PestoBodyBuilder, type: PestoType): PestoId {
  builder.push(PestoOp.unreachable, type)
}

fun loop_(
  builder: &PestoBodyBuilder, initial: PestoId, body: PestoBody
): PestoId {
  builder.push(
    PestoOp.loop_(PestoLoop { initial, body }), body.returns.resolve().type
  )
}

fun continue_(
  builder: &PestoBodyBuilder, next: PestoId, type: PestoType
): PestoId {
  builder.push(PestoOp.continue_(next), type)
}

fun nothing(builder: &PestoBodyBuilder): PestoId {
  builder.struct_(map[String, PestoId]())
}
