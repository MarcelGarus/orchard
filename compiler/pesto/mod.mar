| Pointers, Enums, Structures, and Tamed Operations  
|
| A representation of the program where complex types have been replaced with
| simpler C-like types: (untyped) pointers, (associated) enums, and structures.
| In particular, lambdas have been removed.

import ../plum.mar
import builder.mar
import dag.mar
import format.mar
import run.mar

struct Pesto { entry_point: String, funs: Map[String, PestoFun] }

struct PestoFun { body: PestoBody }
struct PestoBody { param: PestoId, children: Slice[PestoId], returns: PestoId }
struct PestoExpr { op: PestoOp, type: PestoType }

enum PestoType {
  byte,
  int,
  ptr,
  struct_: Map[String, PestoType],
  enum_: Map[String, PestoType],
  never,
}

enum PestoOp {
  param,

  | byte stuff
  byte: Byte,
  lower_byte: PestoId,
  byte_to_int: PestoId,

  | int stuff
  int: Int,
  add: Tuple2[PestoId, PestoId],
  subtract: Tuple2[PestoId, PestoId],
  multiply: Tuple2[PestoId, PestoId],
  divide: Tuple2[PestoId, PestoId], | unchecked
  modulo: Tuple2[PestoId, PestoId], | unchecked
  and_: Tuple2[PestoId, PestoId],
  or_: Tuple2[PestoId, PestoId],
  xor: Tuple2[PestoId, PestoId],
  compare: Tuple2[PestoId, PestoId],

  | struct stuff
  struct_: Map[String, PestoId],
  member: PestoMember,

  | enum stuff
  enum_: PestoEnum,
  switch_: PestoSwitch,

  | function stuff
  function_ptr: String,
  call: PestoCall,
  call_indirect: PestoCallIndirect,

  | object stuff
  new: PestoNew,   | allocates the value on the heap, refcount 1
  load: PestoId,   | loads the pointer's memory (size determined by the type)
  free: PestoFree, | frees the pointer's memory, refcount should be 0
  get_refcount: PestoId,
  increment_refcount: PestoId, | returns the new count
  decrement_refcount: PestoId, | returns the new count

  | buffer stuff
  new_buffer: PestoNewBuffer,
  get_buffer_len: PestoId,
  load_buffer_item: PestoLoadBufferItem,
  store_buffer_item: PestoStoreBufferItem,
  store_buffer_bytes: PestoStoreBufferBytes, | assumes a Buffer(Byte)
  free_buffer: PestoFreeBuffer, | free's the buffer's memory, refcount should be 0

  | crashing
  crash: PestoId,

  | unreachable
  unreachable,

  | loop
  loop_: PestoLoop, 
  continue_: PestoId,
}
struct PestoMember { of: PestoId, name: String }
struct PestoEnum { variant: String, payload: PestoId }
struct PestoSwitch { condition: PestoId, cases: Map[String, PestoBody] }
struct PestoCall { function: String, args: PestoId }
struct PestoCallIndirect { function: PestoId, args: PestoId }
struct PestoFree { ptr: PestoId, type: PestoType }
struct PestoNew { value: PestoId, refcount: Int }
struct PestoNewBuffer { item_type: PestoType, len: PestoId, refcount: Int }
struct PestoLoadBufferItem {
  buffer: PestoId, item_type: PestoType, index: PestoId
}
struct PestoStoreBufferItem {
  buffer: PestoId, item_type: PestoType, index: PestoId, item: PestoId
}
struct PestoStoreBufferBytes { buffer: PestoId, bytes: Slice[Byte] }
struct PestoFreeBuffer { buffer: PestoId, item_type: PestoType }
struct PestoLoop { initial: PestoId, body: PestoBody }

fun ==(a: PestoType, b: PestoType): Bool {
  switch a
  case byte        b is byte
  case int         b is int
  case ptr         b is ptr
  case struct_(aa) if b is struct_(bb) then aa == bb else false
  case enum_(aa)   if b is enum_(bb)   then aa == bb else false
  case never       b is never
}

fun return_type(fun_: PestoFun): PestoType {
  fun_.body.returns.resolve().type
}
