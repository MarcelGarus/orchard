import mod.mar

fun pretty(id: PestoId, namespace: &Namespace): _ {
  PrettyPestoId { id, namespace }
}
struct PrettyPestoId { id: PestoId, namespace: &Namespace }
fun write[W](writer: W, pretty: PrettyPestoId) {
  writer."{pretty.namespace.get(pretty.id.id.index).styled(style_of_id)}"
  | writer."{":{pretty.id.id.index}".styled(style_of_id)}"
}

fun pretty(type: PestoType): _ { type.styled(style_of_type) }

fun write[W](writer: W, pesto: Pesto) {
  var first = true
  for fun_ in pesto.funs do {
    if first then first = false else writer."\n"
    writer."{pretty_signature_def(fun_.key)}"
    writer.write(fun_.value.body, namespace().&, indentation(1))
  }
}
fun write[W](writer: W, type: PestoType) {
  switch type
  case byte writer."byte"
  case int writer."int"
  case ptr writer."ptr"
  case struct_(fields) {
    writer."(&"
    for field in fields do writer." {field.key}: {field.value}"
    writer.")"
  }
  case enum_(variants) {
    writer."(|"
    for variant in variants do
      if variant.value == PestoType.struct_(map[String, PestoType]()) then
        writer." {variant.key}"
      else
        writer." {variant.key}: {variant.value}"
    writer.")"
  }
  case never writer."never"
}
fun write[W](
  writer: W, body: PestoBody, namespace: &Namespace, indentation: Indentation
) {
  writer." {pretty(body.param, namespace)} {pretty(body.param.resolve().type)}\n"
  for id in body.children do {
    var expr = id.resolve()
    writer."{indentation}{pretty(id, namespace)} = "
    writer.write(expr, namespace, indentation)
    writer."\n"
  }
  writer."{indentation}{pretty(body.returns, namespace)}
    '  {pretty(body.returns.resolve().type)}"
}
fun write[W](
  writer: W, expr: PestoExpr, namespace: &Namespace, indentation: Indentation
) {
  var type = expr.type
  switch expr.op
  case param writer."{pretty_op("param")}"
  case byte(byte) writer."{pretty_op("byte")} {byte}  {pretty(type)}"
  case lower_byte(int) writer."{pretty_op("lower byte")} {pretty(int, namespace)}  {pretty(type)}"
  case byte_to_int(byte)
    writer."{pretty_op("byte to int")} {pretty(byte, namespace)}  {pretty(type)}"
  case int(int) writer."{pretty_op("int")} {int}  {pretty(type)}"
  case add(args)
    writer."{pretty_op("add")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case subtract(args)
    writer."{pretty_op("subtract")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case multiply(args)
    writer."{pretty_op("multiply")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case divide(args)
    writer."{pretty_op("divide")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case modulo(args)
    writer."{pretty_op("modulo")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case and_(args)
    writer."{pretty_op("and")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case or_(args)
    writer."{pretty_op("or")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case xor(args)
    writer."{pretty_op("xor")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case compare(args)
    writer."{pretty_op("compare")}
      ' {pretty(args.a, namespace)} {pretty(args.b, namespace)}  {pretty(type)}"
  case struct_(fields) {
    writer."{pretty_op("&")}"
    for field in fields do
      writer." {field.key}: {pretty(field.value, namespace)}"
    writer."  {pretty(type)}"
  }
  case member(member)
    writer."{pretty_op("member")} {pretty(member.of, namespace)}.{member.name}  {pretty(type)}"
  case enum_(enum_)
    writer."{pretty_op("|")}
      ' {enum_.variant}: {pretty(enum_.payload, namespace)}  {pretty(type)}"
  case switch_(switch_) {
    writer."{pretty_op("switch")} {pretty(switch_.condition, namespace)}  {pretty(type)}"
    for case_ in switch_.cases do {
      writer."\n"
      writer."{indentation + 1}{case_.key} ->"
      writer.write(case_.value, namespace, indentation + 2)
    }
  }
  case function_ptr(fun_)
    writer."{pretty_op("function ptr")} {pretty_signature(fun_)}  {pretty(type)}"
  case call(call)
    writer."{pretty_op("call")}
      ' {pretty_signature(call.function)} {pretty(call.args, namespace)}  {pretty(type)}"
  case call_indirect(call)
    writer."{pretty_op("call indirect")}
      ' {pretty(call.function, namespace)} {pretty(call.args, namespace)}  {pretty(type)}"
  case new(new) writer."{pretty_op("new")} {pretty(new.value, namespace)}  {pretty(type)}"
  case load(value) writer."{pretty_op("load")} {pretty(value, namespace)}  {pretty(type)}"
  case free(free)
    writer."{pretty_op("free")} {pretty(free.ptr, namespace)}, which is a pointer to {free.type}  {pretty(type)}"
  case get_refcount(ptr)
    writer."{pretty_op("get refcount")} of {pretty(ptr, namespace)}  {pretty(type)}"
  case increment_refcount(ptr)
    writer."{pretty_op("increment refcount")} of {pretty(ptr, namespace)}  {pretty(type)}"
  case decrement_refcount(ptr)
    writer."{pretty_op("decrement refcount")} of {pretty(ptr, namespace)}  {pretty(type)}"
  case new_buffer(new)
    writer."{pretty_op("new buffer")}
      ' of {new.item_type} of length {pretty(new.len, namespace)}  {pretty(type)}"
  case get_buffer_len(buffer)
    writer."{pretty_op("length")} of {pretty(buffer, namespace)}  {pretty(type)}"
  case load_buffer_item(load)
    writer."{pretty_op("load")}
      ' {pretty(load.buffer, namespace)}[{pretty(load.index, namespace)}]  {pretty(type)}"
  case store_buffer_item(store)
    writer."{pretty_op("store")}
      ' {pretty(store.buffer, namespace)}[{pretty(store.index, namespace)}]
      ' = {pretty(store.item, namespace)}  {pretty(type)}"
  case store_buffer_bytes(store) {
    writer."{pretty_op("store")} {pretty(store.buffer, namespace)} <-"
    for byte in store.bytes do writer." {byte.radix(16)}"
    writer."  {pretty(type)}"
  }
  case free_buffer(free)
    writer."{pretty_op("free buffer")} {pretty(free.buffer, namespace)}  {pretty(type)}"
  case crash(message) writer."{pretty_op("crash")} {pretty(message, namespace)}  {pretty(type)}"
  case unreachable writer."{pretty_op("unreachable")}  {pretty(type)}"
  case loop_(loop_) {
    writer."{pretty_op("loop")}  {pretty(type)}\n
      '{indentation + 1}initial: {pretty(loop_.initial, namespace)}\n
      '{indentation + 1}next:"
    writer.write(loop_.body, namespace, indentation + 2)
  }
  case continue_(next)
    writer."{pretty_op("continue")} {pretty(next, namespace)}"
}
