| Converting Egg to Pesto  

import ../plum.mar
import array_builtins.mar
import builder.mar
import dup_drop_free.mar
import types.mar

fun to_pesto(egg: Egg): Pesto {
  var funs = map[String, PestoFun]()
  for fun_ in egg.funs do {
    | eprintln("Compiling {fun_.key}")
    funs.&.put(fun_.key, fun_.value.to_pesto(funs.&))
  }
  Pesto { entry_point = egg.entry_point, funs }
}

fun to_pesto(fun_: EggFun, funs: &Map[String, PestoFun]): PestoFun {
  var mapping = map[EggId, PestoId]()
  fun_.body.visit(ReserveIds { mapping = mapping.& })
  var body = fun_.body.to_pesto(
    Usages { map = map[PestoId, Int]() }.&, mapping, funs
  )
  PestoFun { body }
}
struct ReserveIds { mapping: &Map[EggId, PestoId] }
fun visit(id: EggId, reserve: ReserveIds) {
  if not(reserve.mapping.contains(id)) then
    reserve.mapping.put(id, create_pesto_placeholder())
  id.visit_children(reserve)
}

fun get(
  mapping: Map[EggId, PestoId], tuple: Tuple2[EggId, EggId]
): Tuple2[PestoId, PestoId] {
  tuple(mapping.get(tuple.a), mapping.get(tuple.b))
}

| Lowering into the Pesto is somewhat peculiar:
| - We treat every type as having a "reference count". When an expression is
|   created, its reference count is 1. If you want the expression to get cleaned
|   up, you need to drop it. If you want to use the expression multiple times,
|   you need to dup it.
| - Lowering into the Pesto is somewhat peculiar: We iterate the expressions
|   from the bottom (the end of functions) to the top (the start of functions).
|   This way, we can keep track of which expressions are used later on and
|   insert code for dropping values as soon as they are no longer used.

struct Usages { map: Map[PestoId, Int] }

fun used(usages: &Usages, id: PestoId, amount: Int) {
  var count = usages.map.get_maybe(id) or 0
  usages.map.&.put(id, count + amount)
}
fun used(usages: &Usages, id: PestoId) { usages.used(id, 1) }
fun get(usages: Usages, id: PestoId): Int { usages.map.get(id) }
fun remove(usages: &Usages, id: PestoId) { usages.map.remove(id) }


fun adjust_refcount(rev_body: &List[PestoId], id: PestoId, by: Int) {
  | fun dup(id: Id): Id { create(PestoOp.dup(id) $ type_never) }
  | fun drop(id: Id): Id { create(PestoOp.drop(id) $ type_never) }
  todo("adjust refcount")
  | rev_body.push(create(PestoOp.))
}


fun to_pesto(
  body: EggBody,
  usages: &Usages, mapping: Map[EggId, PestoId], funs: &Map[String, PestoFun],
): PestoBody {
  var rev_body = list[PestoId]()

  usages.used(mapping.get(body.returns))

  for id in body.children.rev_iter() do
    id.to_pesto(rev_body.&, usages, mapping, funs)

  var param_struct = create_pesto_placeholder()
  var param_types = map[String, PestoType]()
  for param in body.params.iter().enumerate() do {
    rev_body.&.adjust_refcount(param, usages.get(param.item) - 1)
    rev_body.&.push(update(
      param.item,
      PestoOp.member(PestoMember {
        of = param_struct, name = "{param.index}"
      }) $ param.item.type(),
    ))
    usages.remove(param.item)
    param_types.put("{param.index}", param.item.type().to_pesto())
  }

  update(param_struct, PestoOp.param $ type)

  PestoBody {
    param = param_struct,
    exprs = rev_body.to_slice().reversed(),
    returns = mapping.get(body.returns),
  }
}

fun to_pesto(
  id: EggId, rev_body: &List[PestoId], usages: &Usages,
  mapping: Map[EggId, PestoId], funs: &Map[String, PestoFun],
) {
  var expr = id.resolve()
  var type = id.type()
  var id = mapping.get(id)
  var pesto_type = type.to_pesto()

  switch expr
  case param unreachable()
  case case_param unreachable()
  case byte(byte) {
    usages.remove(id)
    rev_body.push(update(id, PestoOp.byte(byte) $ pesto_type))
  }
  case lower_byte(int) {
    var int = mapping.get(int)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.lower_byte(int) $ pesto_type))
    if usages.get(int) == 0 then usages.used(int)
  }
  case byte_to_int(byte) {
    var byte = mapping.get(byte)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.byte_to_int(byte) $ pesto_type))
    if usages.get(byte) == 0 then usages.used(byte)
  }
  case int(int) {
    usages.remove(id)
    rev_body.push(update(id, PestoOp.int(int) $ pesto_type))
  }
  case add(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.add(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case subtract(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.subtract(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case multiply(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.multiply(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case divide unreachable("checked divide")
  case unchecked_divide(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.divide(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case modulo unreachable("checked modulo")
  case unchecked_modulo(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.modulo(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case and_(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.and_(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case or_(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.or_(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case xor(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.xor(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case compare(args) {
    var args = mapping.get(args)
    usages.remove(id)
    rev_body.push(update(id, PestoOp.compare(args) $ pesto_type))
    if usages.get(args.a) == 0 then usages.used(args.a)
    if usages.get(args.b) == 0 then usages.used(args.b)
  }
  case struct_(struct_) {
    | We just propagate the usages to the fields. For example, if the struct is
    | used 2 times, it's as if every field was used two times more than it
    | actually was.
    var fields = map[String, PestoId]()
    for field in struct_ do fields.&.put(field.key, mapping.get(field.value))
    rev_body.push(update(id, PestoOp.struct_(fields) $ pesto_type))
    var count = usages.get(id)
    for field in fields do usages.used(field.value, count)
    usages.remove(id)
  }
  case member(member) {
    var of = mapping.get(member.of)
    if usages.get(of) == 0 then {
      | This is the last use of the struct. Make sure that the struct is kept
      | around to this position with a refcount of 1. Then just increment the
      | refcount of the accessed field by how often it's used and drop all the
      | other fields.
      usages.used(of)
      for field in member.of.type().kind().struct_.unwrap() do {
        if field.key == member.name then {
          rev_body.adjust_refcount(id, usages.get(id) - 1)
          usages.remove(id)
        } else {
          var member_expr = create_pesto_placeholder()
          rev_body.adjust_refcount(member_expr, -1)
          rev_body.push(update(
            member_expr,
            PestoOp.member(PestoMember { of, name = field.key })
              $ field.value.to_pesto(),
          ))
        }
      }
    } else {
      | The struct is used afterwards. Just increment the refcount of the
      | accessed field.
      rev_body.adjust_refcount(id, usages.get(id))
      usages.remove(id)
    }
    rev_body.push(update(
      id, PestoOp.member(PestoMember { of, name = member.name }) $ pesto_type
    ))
  }
  case enum_(enum_) {
    var variant = enum_.variant
    var payload = mapping.get(enum_.payload)
    var payload_type = type.kind().enum_.unwrap().get(variant).to_pesto()
    var needs_extra_boxing =
      type.internal_kind().enum_.unwrap().get(variant).is_unboxed_recursive(1)
    if needs_extra_boxing then {
      | This is a recursive enum variant that needs extra boxing. Move ownership
      | of the payload into the boxed enum by making it a responsibility of the
      | code before to give the payload one more refcount. Create a box with a
      | refcount of how often this enum is used later on.
      usages.used(payload)
      var boxed_payload = create_pesto_placeholder()
      rev_body.push(update(
        id,
        PestoOp.enum_(PestoEnum { variant, payload = boxed_payload })
          $ pesto_type
      ))
      rev_body.push(update(
        boxed_payload,
        PestoOp.new(PestoNew { value = payload, refcount = usages.get(id) })
          $ payload_type
      ))
      usages.remove(id)
    } else {
      | The enum payload does not require boxing. Make it the responsibility of
      | the code before to create the payload with a refcount that also covers
      | the uses of this enum value.
      usages.used(payload, usages.get(id))
      usages.remove(id)
      rev_body.push(update(
        id, PestoOp.enum_(PestoEnum { variant, payload }) $ pesto_type
      ))
    }
  }
  case switch_(switch_) {
    var condition = mapping.get(switch_.condition)

    | Lower the individual cases.
    var cases = map[String, Tuple2[PestoBody, Usages]]()
    for case_ in switch_.cases do {
      var variant = case_.key
      var case_ = case_.value
      var inner_usages = usages.copy()
      var payload_type =
        switch_.condition.type().kind().enum_.unwrap().get(variant)
      var needs_extra_boxing =
        type.internal_kind().enum_.unwrap().get(variant).is_unboxed_recursive(1)

      var rev_body = list[PestoId]()

      inner_usages.used(mapping.get(case_.returns))

      for id in case_.children.rev_iter() do
        id.to_pesto(rev_body.&, inner_usages, mapping, funs)

      var param =
        if case_.params.get_maybe(0) is some(binding) then {
          var binding_type = binding.type().to_pesto()
          var binding = mapping.get(binding)
          if needs_extra_boxing then {
            var param_expr = create_pesto_placeholder()
            rev_body.&.push(update(
              binding, PestoOp.load(param_expr) $ binding_type
            ))
            update(param_expr, PestoOp.param $ payload_type.to_pesto())
          } else
            update(binding, PestoOp.param $ payload_type.to_pesto())
        } else
          create(PestoOp.param $ payload_type.to_pesto())

      cases.&.put(variant, PestoBody {
        param,
        body = rev_body.to_slice().reversed(),
        returns = mapping.get(case_.returns),
      })
    }


    | TODO
    | Figure out the IDs that all branches need.
    for entry in needed_by_branches do
      for id in entry.value do usages.&.put(id)

    | If a branch doesn't use IDs that other branches use, drop those at the
    | start of the branch body.
    for case_ in cases do {
      var needed_by_this_branch = needed_by_branches.get(case_.key)
      var diff_to_other_branches = set[Id]()
      for id in usages do
        if not(needed_by_this_branch.contains(id)) then
          diff_to_other_branches.&.put(id)

      var drops = list(
        update_dup(case_.value.params.get(0)),
        update_drop(switch_.condition),
      )
      for id in diff_to_other_branches do drops.&.push(update_drop(id))

      cases.&.put(case_.key, PestoBody {
        params = case_.value.params,
        exprs = {drops + case_.value.exprs.to_list()}.to_slice(),
        returns = case_.value.returns,
      })
    }
    rev_body.push(update(
      id,
      PestoOp.switch_(PestoSwitch {
        condition = switch_.condition, cases
      }) $ pesto_type,
    ))
    usages.used(switch_.condition)
  }
  case lambda unreachable("inline lambda")
  case raw_lambda(lambda) {
    rev_body.push(update(
      id, PestoOp.lambda(PestoLambda {
        function = lambda.function, closure = lambda.closure
      }) $ pesto_type
    ))
    rev_body.require(lambda.closure, dag, usages)
  





    var closure_ptr = mapping.get(lambda.closure)
    var lambda_body_fun_ptr = builder.function_ptr(lambda.function)
    var free_fun_ptr = builder.function_ptr(
      compile_free_closure_fun(
        fun_.dag.type_of(lambda.closure).kind().box.unwrap(), pesto
      )
    )
    builder.struct_(map(
      "closure" -> closure_ptr,
      "body" -> lambda_body_fun_ptr,
      "free" -> free_fun_ptr,
    ))
  }
  case call_fun(call) {
    rev_body.push(update(
      id, PestoOp.call(PestoCall {
        callee = PestoCallee.fun_(signature), args = call.args
      }) $ pesto_type
    ))
    for arg in call.args do usages.used(arg)




    | TODO: adapt
    var args = map[String, Id]()
    for arg in call.args.iter().enumerate() do
      args.&.put("{arg.index}", mapping.get(arg.item))
    var args = builder.struct_(args)

    builder.call(signature, args, type)
  }
  case call_lambda(call) {
    rev_body.adjust_refcount(id, usages.get(id) - 1)
    rev_body.push(update(
      id, PestoOp.call(PestoCall {
        callee = PestoCallee.lambda(lambda), args = call.args
      }) $ pesto_type
    ))
    usages.remove(id)
    usages.used(lambda)
    for arg in call.args do usages.used(arg)



    var lambda = mapping.get(lambda)
    var closure_ptr = builder.member(lambda, "closure")
    var body_ptr = builder.member(lambda, "body")

    var args = map[String, Id]()
    for arg in call.args.iter().enumerate() do
      args.&.put("{arg.index}", mapping.get(arg.item))
    args.&.put("{call.args.len}", closure_ptr)
    var args = builder.struct_(args)

    builder.call_indirect(body_ptr, args, type)
  }
  case call_builtin unreachable("call builtin")
  case box(inner) {
    rev_body.push(update(
      id,
      PestoOp.new(PestoNew { value = inner, refcount = usages.get(id) }) $ pesto_type,
    ))
    usages.remove(id)
    usages.used(inner)
  }
  case unbox(box) {
    rev_body.adjust_refcount(id, usages.get(id))
    rev_body.push(update(id, PestoOp.unbox(box) $ pesto_type))
    usages.remove(id)
    if usages.get(box) == 0 then {
      | The box is not used afterwards. Drop it.
      rev_body.adjust_refcount(box, -1)
      usages.used(box)
    } else {
      | The box is used afterwards anyway, thus kept alive here. No need to
      | adjust the refcount.
    }


    var box = call.args.get(0)
          var box_type = fun_.dag.type_of(box)
          var inner_type = box_type.kind().box.unwrap()
          var inner = builder.load(mapping.get(box), inner_type.to_pesto())
          builder.dup(inner, inner_type, pesto)
          builder.drop(mapping.get(box), box_type, pesto)
          return inner
  }
  case array(items) {
    var buffer = create_pesto_placeholder()
    var zero = create_pesto_placeholder()
    var len = create_pesto_placeholder()

    rev_body.push(update(
      id,
      PestoOp.struct_(map(
        "buffer" -> buffer,
        "start" -> zero,
        "len" -> len,
      ))
    ))
    for item in items.iter().enumerate() do {
      var index = create_pesto_placeholder()
      rev_body.&.push(create(PestoOp.store_buffer_item(PestoStoreBufferItem {
        buffer, index, item = mapping.get(item.item)
      })))
      rev_body.push(create(index, PestoOp.int(item.index)))
    }
    rev_body.push(update(
      buffer,
      PestoOp.new_buffer(PestoNewBuffer {
        item_type = expr.type.kind().array.unwrap(),
        len,
        refcount = usages.get(id),
      })
    ))
    rev_body.push(update(len, PestoOp.int(items.len)))
    rev_body.push(update(zero, PestoOp.int(0)))

    usages.remove(id)
    for item in items do usages.used(item)
  }
  case generate_array unreachable("checked generate array")
  case unchecked_generate_non_empty_array(gen) {
    | TODO: compile
    | var len       = call.args.get(0)
    | var generator = call.args.get(1)
    | var item_type =
    |   fun_.dag.type_of(generator).kind().lambda.unwrap().return_type
    | return builder.call(
    |   compile_generate_array(item_type, pesto),
    |   builder.struct_(map(
    |     "len" -> mapping.get(len),
    |     "generator" -> mapping.get(generator),
    |   )),
    |   type,
    | )
    todo("generate array")
  }
  case array_len(args) {
    var array = call.args.get(0)
    var item_type = array.type().kind().array.unwrap()
    return builder.call(
      compile_array_len(item_type, pesto),
      builder.struct_(map("array" -> mapping.get(array))),
      PestoType.int,
    )
  } 
  case array_get unreachable("checked array get")
  case unchecked_array_get {
    var array = call.args.get(0)
    var index = call.args.get(1)
    var item_type = fun_.dag.type_of(array).kind().array.unwrap()
    return builder.call(
      compile_array_get(expr.type, pesto),
      builder.struct_(map(
        "array" -> mapping.get(array),
        "index" -> mapping.get(index),
      )),
      type,
    )
  }
  case array_set unreachable("checked array set")
  case unchecked_array_set {
    var array = call.args.get(0)
    var index = call.args.get(1)
    var item = call.args.get(2)
    return builder.call(
      compile_array_set(fun_.dag.type_of(item), pesto),
      builder.struct_(map(
        "array" -> mapping.get(array),
        "index" -> mapping.get(index),
        "item" -> mapping.get(item),
      )),
      pesto_array_type,
    )
  }
  case array_slice unreachable("checked array slice")
  case unchecked_array_slice {
    var array = call.args.get(0)
    var range = call.args.get(1)
    var item_type = fun_.dag.type_of(array).kind().array.unwrap()
    return builder.call(
      compile_array_slice(item_type, pesto),
      builder.struct_(map(
        "array" -> mapping.get(array),
        "range" -> mapping.get(range),
      )),
      pesto_array_type,
    )
  }
  case string unreachable("string should be desugared")
  case type(ty) rev_body.push(update(id, PestoOp.type(ty) $ pesto_type))
  case cast unreachable("cast should be desugared")
  case type_info unreachable("type_info should be desugared")
  case dynamic_to_static unreachable("dynamic_to_static should be desugared")
  case static_to_dynamic unreachable("static_to_dynamic should be desugared")
  case crash(arg) {
    rev_body.push(update(id, PestoOp.crash(mapping.get(arg))))
    usages.used(arg)
  }
  case unreachable {
    rev_body.push(update(id, PestoOp.unreachable))
  }
  case loop_ todo("loop")
  case continue_ todo("continue")
}
