| Tree of Abstract Code for Optimizations  
|
| A representation of code that is more suitable for optimizations.
|
| There's a fundamental tradeoff between debuggability and performance of code.
| If you want to debug your code or understand its behavior, please interpret
| the previous compiler stage (the Egg). This will give you exactly the behavior
| you specified in your code and it contains source code locations for all
| expressions.
| From this compiler stage onwards, we go for performance. The compiler is free
| to change the code however it likes as long as it maintains the observable
| effects of the program:
| 
| - If the program returned a value, it should still produce the same value.
| - If the program crashed, it should still crash.
| 
| Note that this specification of behavior does not include anything about
| memory consumption, internally used functions, or whether computations occur
| in the first place. This means, you should not rely on that. Even if a crash
| occurs, the call stack is not guaranteed to contain the functions you'd
| naively expect (or even a subset of them), so you can display a nice
| backtrace. Instead, you should interpret the previous compiler stage to find
| out why code crashed.
| This might seem harsh, but it gives the compiler freedom to do nice
| optimizations, including running code during compilation, inlining functions,
| or even changing the order that functions are called in (if both crash, that
| would change the stack trace if you could rely on it).
| 
| Unlike the Egg, the Taco is a strict tree, not just a DAG. Expressions are not
| connected via IDs, but are copied into wherever they are used. Having no IDs
| to worry about makes optimizations easier: They are just a mapping from one
| self-contained expression to another. It does lead to duplication, which will
| be removed in another stage.

import ../plum.mar
import builder.mar
import format.mar

struct Taco { entry_point: TacoCalledFun, funs: Map[String, TacoBody] }
struct TacoCalledFun { signature: String, substitutions: Substitutions }

struct TacoBody { params: Slice[Hole], expr: TacoExpr }
struct TacoExpr { op: TacoOp, type: EggType }
struct Hole { id: Int, type: EggType }
enum TacoOp {
  | A hole in an expression means that some concrete value will need to be
  | filled in here, provided by the outer environment. This hole is introduced
  | by i.e. function arguments or switch bindings.
  hole: Hole,

  | Expressions for the basic data structures.
  type: EggType,
  byte: Byte,
  int: Int,
  array: Slice[TacoExpr],
  struct_: Map[String, TacoExpr],
  enum_: TacoEnum,
  lambda: &TacoBody,
  box: &TacoExpr,

  | Expressions for navigating the data structures.
  member: TacoMember,
  switch_: TacoSwitch,
  call_fun: TacoCallFun,
  call_lambda: TacoCallLambda,

  | Has two children. Executes, but ignores the first one, and evaluates to the
  | second one. This is only useful if the first expression may panic.
  both: Tuple2[&TacoExpr, &TacoExpr],

  | A body where each of the expressions (except the last one) are also used to
  | fill a hole in the later scope. This essentially makes them into variables.
  let: Tuple2[&TacoExpr, &TacoBody],

  | Type-casts an expression to a compatible type.
  cast: &TacoExpr,

  | Byte-related builtins.
  lower_byte: &TacoExpr,
  byte_to_int: &TacoExpr,

  | Int-related builtins.
  add: Tuple2[&TacoExpr, &TacoExpr],
  subtract: Tuple2[&TacoExpr, &TacoExpr],
  multiply: Tuple2[&TacoExpr, &TacoExpr],
  divide: Tuple2[&TacoExpr, &TacoExpr],
  modulo: Tuple2[&TacoExpr, &TacoExpr],
  and_: Tuple2[&TacoExpr, &TacoExpr],
  or_: Tuple2[&TacoExpr, &TacoExpr],
  xor: Tuple2[&TacoExpr, &TacoExpr],
  compare: Tuple2[&TacoExpr, &TacoExpr],

  | Boxing-related builtins (the box builtin is already covered above).
  unbox: &TacoExpr,

  | Array-related builtins.
  generate_array: Tuple2[&TacoExpr, &TacoBody], | length, generator
  array_get: Tuple2[&TacoExpr, &TacoExpr], | array, index
  array_set: Tuple3[&TacoExpr, &TacoExpr, &TacoExpr], | array, index, item
  array_slice: Tuple3[&TacoExpr, &TacoExpr, &TacoExpr], | array, start, end
  array_len: &TacoExpr,

  | Crashes the VM.
  crash,

  | Type-stuff.
  type_info: &TacoExpr,
  static_to_dynamic: &TacoExpr,
  dynamic_to_static: &TacoExpr,

  | Inlined recursive functions become recursive expressions.
  recursive: Tuple2[Slice[TacoExpr], &TacoBody], | initial, body
  recurse: Slice[TacoExpr],

  | Marks code as unreachable. Code that definitely reaches this expression can
  | be optimized away. Note that this is different from crashing.
  unreachable,
}
struct TacoEnum { variant: String, payload: &TacoExpr }
struct TacoMember { of: &TacoExpr, name: String }
struct TacoSwitch { condition: &TacoExpr, cases: Map[String, TacoBody] }
struct TacoCallFun { fun_: TacoCalledFun, args: Slice[TacoExpr] }
struct TacoCallLambda { lambda: &TacoExpr, args: Slice[TacoExpr] }


fun black_hole(type: EggType): Hole { Hole { id = -1, type } }
fun is_black(hole: Hole): Bool { hole.id == -1 }

fun ==(a: Hole, b: Hole): Bool { a.id == b.id }
fun hash[H](hasher: H, hole: Hole) { hasher.hash(hole.id) }

fun ==(a: TacoExpr, b: TacoExpr): Bool {
  a.type == b.type and a.op == b.op
}
fun ==(a: TacoOp, b: TacoOp): Bool {
  switch a
  case hole(a)           if b is hole(b)           then a == b else false
  case type(a)           if b is type(b)           then a == b else false
  case byte(a)           if b is byte(b)           then a == b else false
  case int(a)            if b is int(b)            then a == b else false
  case array(a)          if b is array(b)          then a == b else false
  case struct_(a)        if b is struct_(b)        then a == b else false
  case enum_(a)          if b is enum_(b)          then a == b else false
  case lambda(a)         if b is lambda(b)         then a.* == b.* else false
  case box(a)            if b is box(b)            then a.* == b.* else false
  case member(a)         if b is member(b)         then a == b else false
  case switch_(a)        if b is switch_(b)        then a == b else false
  case call_fun(a)       if b is call_fun(b)       then a == b else false
  case call_lambda(a)    if b is call_lambda(b)    then a == b else false
  case both(a)           if b is both(b)           then a.a.* == b.a.* and a.b.* == b.b.* else false
  case let(a)            if b is let(b)            then a.a.* == b.a.* and a.b.* == b.b.* else false
  case cast(a)           if b is cast(b)           then a.* == b.* else false
  case lower_byte(a)     if b is lower_byte(b)     then a.* == b.* else false
  case byte_to_int(a)    if b is byte_to_int(b)    then a.* == b.* else false
  case add(a)            if b is add(b)            then a.a.* == b.a.* and a.b.* == b.b.* else false
  case subtract(a)       if b is subtract(b)       then a.a.* == b.a.* and a.b.* == b.b.* else false
  case multiply(a)       if b is multiply(b)       then a.a.* == b.a.* and a.b.* == b.b.* else false
  case divide(a)         if b is divide(b)         then a.a.* == b.a.* and a.b.* == b.b.* else false
  case modulo(a)         if b is modulo(b)         then a.a.* == b.a.* and a.b.* == b.b.* else false
  case and_(a)           if b is and_(b)           then a.a.* == b.a.* and a.b.* == b.b.* else false
  case or_(a)            if b is or_(b)            then a.a.* == b.a.* and a.b.* == b.b.* else false
  case xor(a)            if b is xor(b)            then a.a.* == b.a.* and a.b.* == b.b.* else false
  case compare(a)        if b is compare(b)        then a.a.* == b.a.* and a.b.* == b.b.* else false
  case unbox(a)          if b is unbox(b)          then a.* == b.* else false
  case generate_array(a) if b is generate_array(b) then a.a.* == b.a.* and a.b.* == b.b.* else false
  case array_get(a)      if b is array_get(b)      then a.a.* == b.a.* and a.b.* == b.b.* else false
  case array_set(a)      if b is array_set(b)      then a.a.* == b.a.* and a.b.* == b.b.* and a.c.* == b.c.* else false
  case array_slice(a)    if b is array_slice(b)    then a.a.* == b.a.* and a.b.* == b.b.* and a.c.* == b.c.* else false
  case array_len(a)      if b is array_len(b)      then a.* == b.* else false
  case crash             b is crash
  case type_info(a)      if b is type_info(b)      then a.* == b.* else false
  case static_to_dynamic(a) if b is static_to_dynamic(b) then a.* == b.* else false
  case dynamic_to_static(a) if b is dynamic_to_static(b) then a.* == b.* else false
  case recursive(a)      if b is recursive(b)      then a.a == b.a and a.b.* == a.b.* else false
  case recurse(a)        if b is recurse(b)        then a == b else false
  case unreachable(a)    b is unreachable
}
fun ==(a: TacoEnum, b: TacoEnum): Bool {
  a.variant == b.variant and a.payload.* == b.payload.*
}
fun ==(a: TacoMember, b: TacoMember): Bool {
  a.of.* == b.of.* and a.name == b.name
}
fun ==(a: TacoSwitch, b: TacoSwitch): Bool {
  a.condition.* == b.condition.* and a.cases == b.cases
}
fun ==(a: TacoCallFun, b: TacoCallFun): Bool {
  a.fun_ == b.fun_ and a.args == b.args
}
fun ==(a: TacoCalledFun, b: TacoCalledFun): Bool {
  a.signature == b.signature and
    a.substitutions.substitutions == b.substitutions.substitutions
}
fun ==(a: TacoCallLambda, b: TacoCallLambda): Bool {
  a.lambda.* == b.lambda.* and a.args == b.args
}
fun ==(a: TacoBody, b: TacoBody): Bool {
  a.params == b.params and a.expr == b.expr
}

fun =~=(a: TacoExpr, b: TacoExpr): Bool {
  a.type == b.type and a.op =~= b.op
}
fun =~=(a: TacoOp, b: TacoOp): Bool {
  switch a
  case hole(a)           if b is hole(b)           then a == b else false
  case type(a)           if b is type(b)           then a == b else false
  case byte(a)           if b is byte(b)           then a == b else false
  case int(a)            if b is int(b)            then a == b else false
  case array(a)          if b is array(b)          then a =~= b else false
  case struct_(a)        if b is struct_(b)        then a =~= b else false
  case enum_(a)          if b is enum_(b)          then a =~= b else false
  case lambda(a)         if b is lambda(b)         then a.* =~= b.* else false
  case box(a)            if b is box(b)            then a.* =~= b.* else false
  case member(a)         if b is member(b)         then a =~= b else false
  case switch_(a)        if b is switch_(b)        then a =~= b else false
  case call_fun(a)       if b is call_fun(b)       then a =~= b else false
  case call_lambda(a)    if b is call_lambda(b)    then a =~= b else false
  case both(a)           if b is both(b)           then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case let(a)            if b is let(b)            then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case cast(a)           if b is cast(b)           then a.* =~= b.* else false
  case lower_byte(a)     if b is lower_byte(b)     then a.* =~= b.* else false
  case byte_to_int(a)    if b is byte_to_int(b)    then a.* =~= b.* else false
  case add(a)            if b is add(b)            then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case subtract(a)       if b is subtract(b)       then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case multiply(a)       if b is multiply(b)       then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case divide(a)         if b is divide(b)         then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case modulo(a)         if b is modulo(b)         then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case and_(a)           if b is and_(b)           then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case or_(a)            if b is or_(b)            then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case xor(a)            if b is xor(b)            then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case compare(a)        if b is compare(b)        then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case unbox(a)          if b is unbox(b)          then a.* =~= b.* else false
  case generate_array(a) if b is generate_array(b) then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case array_get(a)      if b is array_get(b)      then a.a.* =~= b.a.* and a.b.* =~= b.b.* else false
  case array_set(a)      if b is array_set(b)      then a.a.* =~= b.a.* and a.b.* =~= b.b.* and a.c.* =~= b.c.* else false
  case array_slice(a)    if b is array_slice(b)    then a.a.* =~= b.a.* and a.b.* =~= b.b.* and a.c.* =~= b.c.* else false
  case array_len(a)      if b is array_len(b)      then a.* =~= b.* else false
  case crash             b is crash
  case type_info(a)      if b is type_info(b)      then a.* =~= b.* else false
  case static_to_dynamic(a) if b is static_to_dynamic(b) then a.* =~= b.* else false
  case dynamic_to_static(a) if b is dynamic_to_static(b) then a.* =~= b.* else false
  case recursive(a)      if b is recursive(b)      then a.a =~= b.a and a.b.* =~= a.b.* else false
  case recurse(a)        if b is recurse(b)        then a =~= b else false
  case unreachable(a)    b is unreachable
}
fun =~=[T](a: Slice[T], b: Slice[T]): Bool {
  for both in zip(a.iter(), b.iter()) do
    if not(both.a =~= both.b) then return false
  true
}
fun =~=(a: Hole, b: Hole): Bool { a == b }
fun =~=[T](a: Map[String, T], b: Map[String, T]): Bool {
  a.size == b.size or return false
  for entry in a do
    if b.get_maybe(entry.key) is some(b) then
      if not(entry.value =~= b) then return false
  true
}
fun =~=(a: TacoEnum, b: TacoEnum): Bool {
  a.variant == b.variant and a.payload.* =~= b.payload.*
}
fun =~=(a: TacoMember, b: TacoMember): Bool {
  a.of.* =~= b.of.* and a.name == b.name
}
fun =~=(a: TacoSwitch, b: TacoSwitch): Bool {
  a.condition.* =~= b.condition.* and a.cases =~= b.cases
}
fun =~=(a: TacoCallFun, b: TacoCallFun): Bool {
  a.fun_ == b.fun_ and a.args =~= b.args
}
fun =~=(a: TacoCallLambda, b: TacoCallLambda): Bool {
  a.lambda.* =~= b.lambda.* and a.args =~= b.args
}
fun =~=(a: TacoBody, b: TacoBody): Bool {
  a.params.len == b.params.len or return false
  var fillings = list[TacoExpr]()
  for param in a.params do fillings.&.push(taco_hole(param))
  a.expr =~= b.fill(fillings.to_slice())
}

fun map_children[M](expr: TacoExpr, mapper: M): TacoExpr {
  switch expr.op
  case hole expr
  case type expr
  case byte expr
  case int expr
  case array(items) TacoOp.array(items.map(mapper)).expr(expr.type)
  case struct_(struct_) {
    var fields = map[String, TacoExpr]()
    for field in struct_ do fields.&.put(field.key, field.value.map(mapper))
    struct_(fields)
  }
  case enum_(enum_) enum_(expr.type, enum_.variant, enum_.payload.map(mapper))
  case lambda(body) lambda(body.map(mapper))
  case box(inner) box(inner.map(mapper))
  case member(member) member(member.of.map(mapper), member.name)
  case switch_(switch_) {
    var condition = switch_.condition.map(mapper)
    var cases = map[String, TacoBody]()
    for case_ in switch_.cases do
      cases.&.put(case_.key, case_.value.map(mapper))
    switch_(condition, expr.type, cases)
  }
  case call_fun(call) call.fun_.call(call.args.map(mapper), expr.type)
  case call_lambda(call) call.lambda.map(mapper).call(call.args.map(mapper))
  case both(both) both(both.a.map(mapper), both.b.map(mapper))
  case let(let)
    let(let.b.params.get(0), let.a.map(mapper), let.b.expr.map(mapper))
  case cast(inner) cast(inner.map(mapper), expr.type)
  case lower_byte(int) lower_byte(int.map(mapper))
  case byte_to_int(byte) byte_to_int(byte.map(mapper))
  case add(args) add(args.a.map(mapper), args.b.map(mapper))
  case subtract(args) subtract(args.a.map(mapper), args.b.map(mapper))
  case multiply(args) multiply(args.a.map(mapper), args.b.map(mapper))
  case divide(args) divide(args.a.map(mapper), args.b.map(mapper))
  case modulo(args) modulo(args.a.map(mapper), args.b.map(mapper))
  case and_(args) and_(args.a.map(mapper), args.b.map(mapper))
  case or_(args) or_(args.a.map(mapper), args.b.map(mapper))
  case xor(args) xor(args.a.map(mapper), args.b.map(mapper))
  case compare(args) compare(args.a.map(mapper), args.b.map(mapper))
  case unbox(box) unbox(box.map(mapper))
  case generate_array(gen) generate_array(gen.a.map(mapper), gen.b.map(mapper))
  case array_get(args) array_get(args.a.map(mapper), args.b.map(mapper))
  case array_set(args)
    array_set(args.a.map(mapper), args.b.map(mapper), args.c.map(mapper))
  case array_slice(args)
    array_slice(args.a.map(mapper), args.b.map(mapper), args.c.map(mapper))
  case array_len(array) array_len(array.map(mapper))
  case crash expr
  case type_info(type) type_info(type.map(mapper))
  case static_to_dynamic(static) static_to_dynamic(static.map(mapper))
  case dynamic_to_static(dyn) dynamic_to_static(dyn.map(mapper), expr.type)
  case recursive(rec) recursive(rec.a.map(mapper), rec.b.map(mapper))
  case recurse(args) recurse(args.map(mapper), expr.type)
  case unreachable expr
}
fun map[M](exprs: Slice[TacoExpr], mapper: M): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in exprs do new.&.push(old.map(mapper))
  new.to_slice()
}
fallback fun map[M](body: TacoBody, mapper: M): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(mapper) }
}


fun visit_children[V](expr: TacoExpr, visitor: V) {
  switch expr.op
  case hole {}
  case type {}
  case byte {}
  case int {}
  case array(items) for item in items do item.visit(visitor)
  case struct_(fields) for field in fields do field.value.visit(visitor)
  case enum_(enum_) enum_.payload.visit(visitor)
  case lambda(body) body.visit(visitor)
  case box(inner) inner.visit(visitor)
  case member(member) member.of.visit(visitor)
  case switch_(switch_) {
    switch_.condition.visit(visitor)
    for case_ in switch_.cases do case_.value.visit(visitor)
  }
  case call_fun(call) call.args.visit(visitor)
  case call_lambda(call) {
    call.lambda.visit(visitor)
    call.args.visit(visitor)
  }
  case both(both) both.visit(visitor)
  case let(let) { let.a.visit(visitor)  let.b.visit(visitor) }
  case cast(inner) inner.visit(visitor)
  case lower_byte(int) int.visit(visitor)
  case byte_to_int(byte) byte.visit(visitor)
  case add(args) args.visit(visitor)
  case subtract(args) args.visit(visitor)
  case multiply(args) args.visit(visitor)
  case divide(args) args.visit(visitor)
  case modulo(args) args.visit(visitor)
  case and_(args) args.visit(visitor)
  case or_(args) args.visit(visitor)
  case xor(args) args.visit(visitor)
  case compare(args) args.visit(visitor)
  case unbox(box) box.visit(visitor)
  case generate_array(gen) { gen.a.visit(visitor)  gen.b.visit(visitor) }
  case array_get(args) args.visit(visitor)
  case array_set(args) args.visit(visitor)
  case array_slice(args) args.visit(visitor)
  case array_len(array) array.visit(visitor)
  case crash {}
  case type_info(type) type.visit(visitor)
  case static_to_dynamic(static) static.visit(visitor)
  case dynamic_to_static(dynamic) dynamic.visit(visitor)
  case recursive(rec) { rec.a.visit(visitor)  rec.b.visit(visitor) }
  case recurse(args) args.visit(visitor)
  case unreachable {}
}
fun visit[V](tuple: Tuple2[&TacoExpr, &TacoExpr], visitor: V) {
  tuple.a.visit(visitor)
  tuple.b.visit(visitor)
}
fun visit[V](tuple: Tuple3[&TacoExpr, &TacoExpr, &TacoExpr], visitor: V) {
  tuple.a.visit(visitor)
  tuple.b.visit(visitor)
  tuple.c.visit(visitor)
}
fun visit[V](exprs: Slice[TacoExpr], visitor: V) {
  for expr in exprs do expr.visit(visitor)
}


| All expressions that are either direct children or in a child body.
fun children(expr: TacoExpr): Slice[TacoExpr] {
  var children = list[TacoExpr]()
  expr.visit_children(GatherChildren { children = children.& })
  children.to_slice()
}
struct GatherChildren { children: &List[TacoExpr] }
fun visit(expr: TacoExpr, gather: GatherChildren) { gather.children.push(expr) }
fun visit(body: TacoBody, gather: GatherChildren) {
  gather.children.push(body.expr)
}


| All expressions that are direct children, skipping bodies.
fun children_not_in_bodies(expr: TacoExpr): Slice[TacoExpr] {
  var children = list[TacoExpr]()
  expr.visit_children(GatherChildren { children = children.& })
  children.to_slice()
}
struct GatherChildrenIgnoringBodies { children: &List[TacoExpr] }
fun visit(expr: TacoExpr, gather: GatherChildrenIgnoringBodies) {
  gather.children.push(expr)
}
fun visit(body: TacoBody, gather: GatherChildrenIgnoringBodies) {}


| Returns the child expressions that are guaranteed to be evaluated once when
| this expression is is evaluated once. For example, returns the fields of a
| struct expression, but does not return the inner expressions of lambdas or
| switch bodies.
fun direct_children(expr: TacoExpr): Slice[TacoExpr] {
  switch expr.op
  case hole {}
  case type {}
  case byte {}
  case int {}
  case array(items) items
  case struct_(fields) {
    var children = list[TacoExpr]()
    for field in fields do children.&.push(field.value)
    children.to_slice()
  }
  case enum_(enum_) list(enum_.payload.*).to_slice()
  case lambda list[TacoExpr]()
  case box(inner) list(inner).to_slice()
  case member(member) list(member.of.*).to_slice()
  case switch_(switch_) list(switch_.condition.*).to_slice()
  case call_fun(call) call.args
  case call_lambda(call) {
    var children = list(call.lambda)
    for arg in call.args do children.&.push(arg)
    children.to_slice()
  }
  case both(both) list(both.ignored.*, both.result.*).to_slice()
  case let(let) list(let.def.*, let.result.*).to_slice()
  case cast(inner) list(inner).to_slice()
  case lower_byte(int) list(int).to_slice()
  case byte_to_int(byte) list(byte).to_slice()
  case add(args) list(args.a.*, args.b.*).to_slice()
  case sub_ints(args) list(args.a.*, args.b.*).to_slice()
  case mul_ints(args) list(args.a.*, args.b.*).to_slice()
  case div_ints(args) list(args.a.*, args.b.*).to_slice()
  case mod_ints(args) list(args.a.*, args.b.*).to_slice()
  case and_ints(args) list(args.a.*, args.b.*).to_slice()
  case or_ints(args) list(args.a.*, args.b.*).to_slice()
  case xor_ints(args) list(args.a.*, args.b.*).to_slice()
  case compare_ints(args) list(args.a.*, args.b.*).to_slice()
  case unbox(box) list(box).to_slice()
  case generate_array(gen) list(gen.length.*).to_slice()
  case array_get(get) list(get.array.*, get.index.*).to_slice()
  case array_set(set) list(set.array.*, set.index.*, set.item.*).to_slice()
  case array_slice(slice) list(slice.array.*, slice.start.*, slice.end.*).to_slice()
  case array_len(array) list(array.*).to_slice()
  case crash {}
  case type_info(type) list(type.*).to_slice()
  case static_to_dynamic(static) list(static.*).to_slice()
  case dynamic_to_static(dynamic) list(dynamic.*).to_slice()
  case recursive(recursive) recursive.args.to_slice()
  case recurse(args) args
  case unreachable {}
}

| TODO: Think about what to do with this.

| fun hash[H](hasher: H, expr: TacoExpr) {
|   hasher.hash(expr.op.debug().format())
|   switch expr.op
|   case param {}
|   case id(id) hasher.hash(id)
|   case byte(byte) hasher.hash(byte)
|   case int(int) hasher.hash(int)
|   case array(items) for item in items do hasher.hash(item)
|   case struct_(fields)
|     for field in fields do {
|       hasher.hash(field.key)
|       hasher.hash(field.value)
|     }
|   case member(member) {
|     hasher.hash(member.of.*)
|     hasher.hash(member.name)
|   }
|   case enum_(enum_) {
|     hasher.hash(enum_.name)
|     hasher.hash(enum_.value.*)
|   }
|   case switch_(switch_) {
|     hasher.hash(switch_.condition.*)
|     var num = 0
|     for case_ in switch_.cases do {
|       num = num ^ case_.key.hash() + case_.value.hash()
|     }
|     hasher.hash(num)
|   }
|   case lambda(lambda) hasher.hash(lambda.*)
|   case call(call) {
|     switch call.callee
|     case lambda(lambda) hasher.hash(lambda.*)
|     case fun_(fun_) hasher.hash(fun_.signature)
|     case builtin(builtin) hasher.hash(builtin.debug().format())
|     for arg in call.args do hasher.hash(arg)
|   }
|   case recursive(recursive) {
|     for arg in recursive.args do hasher.hash(arg)
|     hasher.hash(recursive.body.*)
|   }
|   case recurse(args) for arg in args do hasher.hash(arg)
|   case cast(inner) hasher.hash(inner.*)
|   case type(type) hasher.hash(type)
| }
| fun hash[H](hasher: H, body: TacoBody) {
|   for param in body.params do hasher.hash(param)
|   for child in body.children do hasher.hash(child)
| }
