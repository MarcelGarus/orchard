import mod.mar

fun write[W](writer: W, egg: Taco) {
  var first = true
  for fun_ in egg.funs do {
    if first then first = false else writer."\n"
    writer.write(fun_.key, fun_.value)
  }
}
fun write[W](writer: W, signature: String, fun_: TacoFun) {
  var namespace = holes_namespace().&
  writer."{pretty_signature_def(signature)}"
  for param in fun_.params do writer." {format(param, namespace)}"
  writer." =\n"
  writer.write(fun_.body, namespace, indentation(1))
}

struct HolesNamespace { ids: List[Int] }
fun holes_namespace(): HolesNamespace { HolesNamespace { ids = list[Int]() } }
fun get_index(namespace: &HolesNamespace, id: Int): Int {
  for existing in namespace.ids.iter().enumerate() do
    if id == existing.item then return existing.index
  var index = namespace.ids.len
  namespace.ids.&.push(id)
  index
}
fun get(namespace: &HolesNamespace, id: Int): String {
  var index = namespace.get_index(id)
  var name = ""
  loop {
    var letter = #a + {{index % 26}.lower_byte()}
    index = index / 26
    name = "{letter}{name}"
    if index == 0 then break
    index = index - 1
  }
  name
}
fun format(hole: Hole, namespace: &HolesNamespace): String {
  namespace.get(hole.id).styled(style_of_id)
}


fun write[W](
  writer: W, expr: TacoExpr, namespace: &HolesNamespace, indentation: Indentation
) {
  var type = expr.type
  writer."{indentation}"
  switch expr.op
  case hole(hole) {
    if hole.is_black() then
      writer.write(" hole ".styled("40;37"))
    else
      writer."{pretty_op("hole")} {format(hole, namespace)}"
  }
  case type(type_) writer."{pretty_op("type")} {type_}"
  case byte(byte) writer."{pretty_op("byte")} {byte}"
  case int(int) writer."{pretty_op("int")} {int}"
  case array writer."{pretty_op("array")}"
  case struct_ {
    var keys = list[String]()
    for field in type.kind().struct_.unwrap() do keys.&.push(field.key)
    keys.to_slice().&.sort()

    writer."{pretty_op("&")}  {pretty(type)}"
    for field in zip(keys.to_slice().iter(), expr.children.iter()) do {
      writer."\n{indentation + 1}{field.a}:\n"
      writer.write(field.b, namespace, indentation + 2)
    }
    return {}
  }
  case enum_(name) writer."{pretty_op("|")} {name}:"
  case lambda(params) {
    writer."{pretty_op("lambda")}"
    for param in params do writer." {format(param, namespace)}"
  }
  case box writer."{pretty_op("box")}"
  case member(name) writer."{pretty_op("member")} {name}"
  case switch_(case_holes) {
    var condition = expr.children.first()
    var cases = expr.children.without_first()
    
    var keys = list[String]()
    for variant in condition.type.kind().enum_.unwrap() do
      keys.&.push(variant.key)
    keys.to_slice().&.sort()

    writer."{pretty_op("switch")}  {pretty(type)}\n"
    writer.write(condition, namespace, indentation + 1)
    for case_ in zip(zip(keys.iter(), case_holes.iter()), cases.iter()) do {
      writer."\n{indentation + 1}{case_.a.a} {format(case_.a.b, namespace)}:\n"
      writer.write(case_.b, namespace, indentation + 2)
    }
    return {}
  }
  case call_fun(fun_) {
    writer."{pretty_op("call")} {pretty_signature(fun_.signature)}"
    if fun_.substitutions.substitutions.is_not_empty() then
      writer." with {fun_.substitutions}"
    writer.""
  }
  case call_lambda writer."{pretty_op("call lambda")}"
  case body writer."{pretty_op("body")}"
  case cast(cast) writer."{pretty_op("cast")}"
  case lower_byte writer."{pretty_op("lower byte")}"
  case byte_to_int writer."{pretty_op("byte to int")}"
  case add_ints writer."{pretty_op("add")}"
  case sub_ints writer."{pretty_op("subtract")}"
  case mul_ints writer."{pretty_op("multiply")}"
  case div_ints writer."{pretty_op("divide")}"
  case mod_ints writer."{pretty_op("modulo")}"
  case and_ints writer."{pretty_op("bitwise and")}"
  case or_ints writer."{pretty_op("bitwise or")}"
  case xor_ints writer."{pretty_op("bitwise xor")}"
  case compare_ints writer."{pretty_op("compare ints")}"
  case unbox writer."{pretty_op("unbox")}"
  case generate_array writer."{pretty_op("generate array")}"
  case array_get writer."{pretty_op("get")}"
  case array_set writer."{pretty_op("set")}"
  case array_slice writer."{pretty_op("slice")}"
  case array_len writer."{pretty_op("length")}"
  case crash writer."{pretty_op("crash")}"
  case type_info writer."{pretty_op("type info")}"
  case static_to_dynamic writer."{pretty_op("static to dynamic")}"
  case dynamic_to_static writer."{pretty_op("dynamic to static")}"
  case unreachable writer."{pretty_op("unreachable")}"
  case recursive(holes) {
    var args = expr.children.without_last()
    var body = expr.children.last()
    writer."{pretty_op("recursive")}"
    for hole in holes do writer." {format(hole, namespace)}"
    writer."  {pretty(expr.type)}\n{indentation + 1}initial:"
    for arg in args do {
      writer."\n"
      writer.write(arg, namespace, indentation + 2)
    }
    writer."\n{indentation + 1}body:\n"
    writer.write(body, namespace, indentation + 2)
    return {}
  }
  case recurse writer."{pretty_op("recurse")}"
  case create_buffer writer."{pretty_op("create buffer")}"
  case buffer_get writer."{pretty_op("get")}"
  case buffer_set writer."{pretty_op("set")}"
  case buffer_len writer."{pretty_op("buffer length")}"
  case array_from_buffer writer."{pretty_op("array from buffer, start, end")}"
  case buffer_of_array writer."{pretty_op("buffer of array")}"
  case start_of_array writer."{pretty_op("start of array")}"
  case end_of_array writer."{pretty_op("end of array")}"

  writer."  {pretty(type)}"
  for child in expr.children do {
    writer."\n"
    writer.write(child, namespace, indentation + 1)
  }
}
