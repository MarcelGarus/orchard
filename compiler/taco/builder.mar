import mod.mar

var next_hole = 0
fun hole(type: EggType): Hole {
  var hole = Hole { id = next_hole, type }
  next_hole = next_hole + 1
  hole
}

fun expr(op: TacoOp, type: EggType): TacoExpr { TacoExpr { op, type } }

fun body(params: Slice[Hole], expr: TacoExpr): TacoBody {
  TacoBody { params, expr }
}
fun body(param: Hole, expr: TacoExpr): TacoBody {
  body(list(param).to_slice(), expr)
}

fun taco_hole(hole: Hole): TacoExpr { TacoOp.hole(hole).expr(hole.type) }
fun taco_type(type: EggType): TacoExpr { TacoOp.type(type).expr(type_type) }
fun taco_byte(byte: Byte): TacoExpr { TacoOp.byte(byte).expr(type_byte) }
fun taco_int(int: Int): TacoExpr { TacoOp.int(int).expr(type_int) }
fun array(item_type: EggType, items: Slice[TacoExpr]): TacoExpr {
  TacoOp.array(items).expr(type_array(item_type))
}
fun struct_(fields: Map[String, TacoExpr]): TacoExpr {
  var field_types = map[String, EggType]()
  for field in fields do field_types.&.put(field.key, field.value.type)
  TacoOp.struct_(fields).expr(type_struct(field_types))
}
fun enum_(type: EggType, variant: String, payload: TacoExpr): TacoExpr {
  TacoOp.enum_(TacoEnum { variant, payload = payload.put_on_heap() }).expr(type)
}
fun lambda(body: TacoBody): TacoExpr {
  var param_types = list[EggType]()
  for param in body.params do param_types.&.push(param.type)
  var type = type_lambda(param_types.to_slice(), body.expr.type)
  TacoOp.lambda(body.put_on_heap()).expr(type)
}
fun box(inner: TacoExpr): TacoExpr {
  TacoOp.box(inner.put_on_heap()).expr(type_box(inner.type))
}
fun member(of: TacoExpr, name: String): TacoExpr {
  TacoOp.member(TacoMember { of = of.put_on_heap(), name })
    .expr(of.type.kind().struct_.unwrap().get(name))
}
fun switch_(
  condition: TacoExpr, type: EggType, cases: Map[String, TacoBody]
): TacoExpr {
  TacoOp.switch_(TacoSwitch { condition = condition.put_on_heap(), cases })
    .expr(type)
}
fun call(
  fun_: TacoCalledFun, args: Slice[TacoExpr], return_type: EggType
): TacoExpr {
  TacoOp.call_fun(TacoCallFun { fun_, args }).expr(return_type)
}
fun call(lambda: TacoExpr, args: Slice[TacoExpr]): TacoExpr {
  TacoOp.call_lambda(TacoCallLambda { lambda = lambda.put_on_heap(), args })
    .expr(lambda.type.kind().lambda.unwrap().return_type)
}
fun both(ignored: TacoExpr, result: TacoExpr): TacoExpr {
  TacoOp.both(TacoBoth {
    ignored = ignored.put_on_heap(), result = result.put_on_heap()
  }).expr(result.type)
}
| TODO: remove
fun body(children: Slice[TacoExpr]): TacoExpr {
  var result = children.last()
  for child in children.without_last().rev_iter() do
    result = both(child, result)
  result
}
fun let(hole: Hole, def: TacoExpr, result: TacoExpr): TacoExpr {
  TacoOp.let(TacoLet {
    def = def.put_on_heap(), result = body(hole, result).put_on_heap()
  }).expr(result.type)
}
fun lets(lets: Slice[Tuple2[Hole, TacoExpr]], returns: TacoExpr): TacoExpr {
  var result = returns
  for child in lets.rev_iter() do result = let(child.a, child.b, result)
  result
}
fun cast(inner: TacoExpr, type: EggType): TacoExpr {
  TacoOp.cast(inner.put_on_heap()).expr(type)
}
fun lower_byte(int: TacoExpr): TacoExpr {
  TacoOp.lower_byte(int.put_on_heap()).expr(type_byte)
}
fun byte_to_int(byte: TacoExpr): TacoExpr {
  TacoOp.byte_to_int(byte.put_on_heap()).expr(type_int)
}
fun add(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.add_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun subtract(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.sub_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun multiply(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.mul_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun divide(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.div_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun modulo(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.mod_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun and_(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.and_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun or_(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.or_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun xor(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.xor_ints(tuple(a.put_on_heap(), b.put_on_heap())).expr(type_int)
}
fun compare(a: TacoExpr, b: TacoExpr): TacoExpr {
  TacoOp.compare_ints(tuple(a.put_on_heap(), b.put_on_heap()))
    .expr(type_ordering)
}
fun unbox(box: TacoExpr): TacoExpr {
  TacoOp.unbox(box.put_on_heap()).expr(box.type.kind().box.unwrap())
}
fun generate_array(length: TacoExpr, generator: TacoBody): TacoExpr {
  TacoOp.generate_array(TacoGenerateArray {
    length = length.put_on_heap(), generator = generator.put_on_heap()
  }).expr(type_array(generator.expr.type))
}
fun array_get(array: TacoExpr, index: TacoExpr): TacoExpr {
  TacoOp.array_get(tuple(array.put_on_heap(), index.put_on_heap()))
    .expr(array.type.kind().array.unwrap())
}
fun array_set(array: TacoExpr, index: TacoExpr, item: TacoExpr): TacoExpr {
  TacoOp.array_set(tuple(
    array.put_on_heap(), index.put_on_heap(), item.put_on_heap()
  )).expr(array.type)
}
fun array_slice(array: TacoExpr, start: TacoExpr, end: TacoExpr): TacoExpr {
  TacoOp.array_slice(tuple(
    array.put_on_heap(), start.put_on_heap(), end.put_on_heap()
  )).expr(array.type)
}
fun array_len(array: TacoExpr): TacoExpr {
  TacoOp.array_len(array.put_on_heap()).expr(type_int)
}
fun taco_crash(type: EggType): TacoExpr { TacoOp.crash.expr(type) }
fun type_info(type: TacoExpr): TacoExpr {
  TacoOp.type_info(type.put_on_heap()).expr(type_type)
}
fun static_to_dynamic(static: TacoExpr): TacoExpr {
  TacoOp.static_to_dynamic(static.put_on_heap()).expr(type_dynamic)
}
fun dynamic_to_static(dynamic: TacoExpr, type: EggType): TacoExpr {
  TacoOp.dynamic_to_static(dynamic.put_on_heap()).expr(type)
}
fun recursive(initial: Slice[TacoExpr], body: TacoBody): TacoExpr {
  TacoOp.recursive(TacoRecursive { initial, body = body.put_on_heap() })
    .expr(body.expr.type)
}
fun recurse(args: Slice[TacoExpr], type: EggType): TacoExpr {
  TacoOp.recurse(args).expr(type)
}
fun taco_unreachable(type: EggType): TacoExpr { TacoOp.unreachable.expr(type) }

var taco_nothing = struct_(map[String, TacoExpr]())
var taco_true = enum_(type_bool, "true", taco_nothing)
var taco_false = enum_(type_bool, "false", taco_nothing)
fun taco_string(string: String): TacoExpr {
  var bytes = list[TacoExpr]()
  for byte in string.bytes() do bytes.&.push(taco_byte(byte))
  struct_(map("utf8_bytes" -> array(type_byte, bytes.to_slice())))
}
fun if_(condition: TacoExpr, then_: TacoExpr, else_: TacoExpr): TacoExpr {
  switch_(condition, then_.type, map(
    "true" -> body(hole(type_nothing), then_),
    "false" -> body(hole(type_nothing), else_),
  ))
}
fun switch_on_ordering(
  ordering: TacoExpr, less: TacoExpr, equal: TacoExpr, greater: TacoExpr
): TacoExpr {
  switch_(ordering, less.type, map(
    "less" -> body(hole(type_nothing), less),
    "equal" -> body(hole(type_nothing), equal),
    "greater" -> body(hole(type_nothing), greater),
  ))
}
fun is_equal(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_false, taco_true, taco_false)
}
fun is_greater_equal(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_false, taco_true, taco_true)
}
fun is_greater(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_false, taco_false, taco_true)
}
fun is_less(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_true, taco_false, taco_false)
}
fun is_less_equal(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_true, taco_true, taco_false)
}
