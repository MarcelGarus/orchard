import mod.mar

var next_hole = 0
fun hole(type: EggType): Hole {
  var hole = Hole { id = next_hole, type }
  next_hole = next_hole + 1
  hole
}

fun expr(op: TacoOp, children: Slice[TacoExpr], type: EggType): TacoExpr {
  TacoExpr { op, children, type }
}
fun expr(op: TacoOp, type: EggType): TacoExpr {
  op.expr(empty_slice[TacoExpr](), type)
}

fun taco_hole(hole: Hole): TacoExpr { expr(TacoOp.hole(hole), hole.type) }
fun taco_type(type: EggType): TacoExpr { expr(TacoOp.type(type), type_type) }
fun taco_byte(byte: Byte): TacoExpr { expr(TacoOp.byte(byte), type_byte) }
fun taco_int(int: Int): TacoExpr { expr(TacoOp.int(int), type_int) }
fun array(item_type: EggType, items: Slice[TacoExpr]): TacoExpr {
  expr(TacoOp.array, items, type_array(item_type))
}
fun struct_(fields: Map[String, TacoExpr]): TacoExpr {
  var field_types = map[String, EggType]()
  for field in fields do field_types.&.put(field.key, field.value.type)

  var keys = list[String]()
  for field in fields do keys.&.push(field.key)
  keys.to_slice().&.sort()

  var field_values = list[TacoExpr]()
  for key in keys do field_values.&.push(fields.get(key))

  expr(TacoOp.struct_, field_values.to_slice(), type_struct(field_types))
}
fun enum_(type: EggType, name: String, value: TacoExpr): TacoExpr {
  expr(TacoOp.enum_(name), list(value).to_slice(), type)
}
fun lambda(params: Slice[Hole], body: TacoExpr): TacoExpr {
  var param_types = list[EggType]()
  for param in params do param_types.&.push(param.type)
  var type = type_lambda(param_types.to_slice(), body.type)
  expr(TacoOp.lambda(params), list(body).to_slice(), type)
}
fun box(inner: TacoExpr): TacoExpr {
  expr(TacoOp.box, list(inner).to_slice(), type_box(inner.type))
}
fun member(of: TacoExpr, name: String): TacoExpr {
  expr(
    TacoOp.member(name),
    list(of).to_slice(),
    of.type.kind().struct_.unwrap().get(name),
  )
}
fun switch_(
  condition: TacoExpr, type: EggType, cases: Map[String, Tuple2[Hole, TacoExpr]]
): TacoExpr {
  var keys = list[String]()
  for case_ in cases do keys.&.push(case_.key)
  keys.to_slice().&.sort()

  var holes = list[Hole]()
  var children = list(condition)
  for key in keys do {
    var case_ = cases.get(key)
    holes.&.push(case_.a)
    children.&.push(case_.b)
  }

  expr(TacoOp.switch_(holes.to_slice()), children.to_slice(), type)
}
fun call(
  fun_: TacoCalledFun, args: Slice[TacoExpr], return_type: EggType
): TacoExpr {
  expr(TacoOp.call_fun(fun_), args, return_type)
}
fun call(lambda: TacoExpr, args: Slice[TacoExpr]): TacoExpr {
  expr(
    TacoOp.call_lambda,
    {
      var children = list(lambda)
      for arg in args do children.&.push(arg)
      children.to_slice()
    },
    lambda.type.kind().lambda.unwrap().return_type,
  )
}
fun body(children: Slice[TacoExpr]): TacoExpr {
  expr(TacoOp.body, children, children.last().type)
}
fun body(
  lets: Slice[Tuple2[Hole, TacoExpr]], returns: TacoExpr
): TacoExpr {
  var holes = list[Hole]()
  var children = list[TacoExpr]()
  for child in lets do {
    holes.&.push(child.a)
    children.&.push(child.b)
  }
  children.&.push(returns)
  expr(TacoOp.let_body(holes.to_slice()), children.to_slice(), returns.type)
}
fun cast(inner: TacoExpr, type: EggType): TacoExpr {
  expr(TacoOp.cast, list(inner).to_slice(), type)
}
fun lower_byte(int: TacoExpr): TacoExpr {
  expr(TacoOp.lower_byte, list(int).to_slice(), type_byte)
}
fun byte_to_int(byte: TacoExpr): TacoExpr {
  expr(TacoOp.byte_to_int, list(byte).to_slice(), type_int)
}
fun add(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.add_ints, list(a, b).to_slice(), type_int)
}
fun subtract(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.sub_ints, list(a, b).to_slice(), type_int)
}
fun multiply(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.mul_ints, list(a, b).to_slice(), type_int)
}
fun divide(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.div_ints, list(a, b).to_slice(), type_int)
}
fun modulo(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.mod_ints, list(a, b).to_slice(), type_int)
}
fun and_(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.and_ints, list(a, b).to_slice(), type_int)
}
fun or_(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.or_ints, list(a, b).to_slice(), type_int)
}
fun xor(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.xor_ints, list(a, b).to_slice(), type_int)
}
fun compare(a: TacoExpr, b: TacoExpr): TacoExpr {
  expr(TacoOp.compare_ints, list(a, b).to_slice(), type_ordering)
}
fun unbox(box: TacoExpr): TacoExpr {
  expr(TacoOp.unbox, list(box).to_slice(), box.type.kind().box.unwrap())
}
fun generate_array(
  length: TacoExpr, index: Hole, generator: TacoExpr
): TacoExpr {
  expr(
    TacoOp.generate_array(index),
    list(length, generator).to_slice(),
    type_array(generator.type),
  )
}
fun array_get(array: TacoExpr, index: TacoExpr): TacoExpr {
  expr(
    TacoOp.array_get,
    list(array, index).to_slice(),
    array.type.kind().array.unwrap(),
  )
}
fun array_set(array: TacoExpr, index: TacoExpr, item: TacoExpr): TacoExpr {
  expr(TacoOp.array_set, list(array, index, item).to_slice(), array.type)
}
fun array_slice(array: TacoExpr, start: TacoExpr, end: TacoExpr): TacoExpr {
  expr(TacoOp.array_slice, list(array, start, end).to_slice(), array.type)
}
fun array_len(array: TacoExpr): TacoExpr {
  expr(TacoOp.array_len, list(array).to_slice(), type_int)
}
fun taco_crash(type: EggType): TacoExpr { expr(TacoOp.crash, type) }
fun type_info(type: TacoExpr): TacoExpr {
  expr(TacoOp.type_info, list(type).to_slice(), type_type)
}
fun static_to_dynamic(static: TacoExpr): TacoExpr {
  expr(TacoOp.static_to_dynamic, list(static).to_slice(), type_dynamic)
}
fun dynamic_to_static(dynamic: TacoExpr, type: EggType): TacoExpr {
  expr(TacoOp.dynamic_to_static, list(dynamic).to_slice(), type)
}
fun recursive(
  holes: Slice[Hole], args: Slice[TacoExpr], body: TacoExpr
): TacoExpr {
  var children = list[TacoExpr]()
  for arg in args do children.&.push(arg)
  children.&.push(body)
  expr(TacoOp.recursive(holes), children.to_slice(), body.type)
}
fun recurse(args: Slice[TacoExpr], type: EggType): TacoExpr {
  expr(TacoOp.recurse, args, type)
}
fun taco_unreachable(type: EggType): TacoExpr { expr(TacoOp.unreachable, type) }

var taco_nothing = struct_(map[String, TacoExpr]())
var taco_true = enum_(type_bool, "true", taco_nothing)
var taco_false = enum_(type_bool, "false", taco_nothing)
fun taco_string(string: String): TacoExpr {
  var bytes = list[TacoExpr]()
  for byte in string.bytes() do bytes.&.push(taco_byte(byte))
  struct_(map("utf8_bytes" -> array(type_byte, bytes.to_slice())))
}
fun if_(condition: TacoExpr, then_: TacoExpr, else_: TacoExpr): TacoExpr {
  switch_(condition, then_.type, map(
    "true" -> tuple(hole(type_nothing), then_),
    "false" -> tuple(hole(type_nothing), else_),
  ))
}
fun switch_on_ordering(
  ordering: TacoExpr, less: TacoExpr, equal: TacoExpr, greater: TacoExpr
): TacoExpr {
  switch_(ordering, less.type, map(
    "less" -> tuple(hole(type_nothing), less),
    "equal" -> tuple(hole(type_nothing), equal),
    "greater" -> tuple(hole(type_nothing), greater),
  ))
}
fun is_equal(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_false, taco_true, taco_false)
}
fun is_greater_equal(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_false, taco_true, taco_true)
}
fun is_greater(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_false, taco_false, taco_true)
}
fun is_less(ordering: TacoExpr): TacoExpr {
  switch_on_ordering(ordering, taco_true, taco_false, taco_false)
}
