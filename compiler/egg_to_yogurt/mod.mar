| Convert Egg to Yogurt  

import ../plum.mar
import dynamic.mar
import builder.mar
import cast.mar
import context.mar
import type_info.mar

fun to_yogurt(egg: Egg, entry_signature: String): Result[Yogurt, Error] {
  var main = egg.funs.get_maybe(entry_signature) or
    return error[Yogurt, Error](error(
      "Entry point {entry_signature.debug()} doesn't exist.", invalid_src
    ))
  var yogurt = yogurt(entry_signature)
  main.compile(
    entry_signature,
    Substitutions { substitutions = map[String, EggType]() },
    YogurtContext { stack = list[String]().&, egg, yogurt = yogurt.& }.&,
  )?
  ok[Yogurt, Error](yogurt)
}

fun compile(
  fun_: EggFun, signature: String,
  substitutions: Substitutions, context: &YogurtFunContext,
): Result[String, Error] {
  var compilation = context.start_compiling({
    var b = string_builder().&
    b."{signature}"
    if substitutions.substitutions.size > 0 then {
      b." with"
      var first = true
      for substitution in substitutions.substitutions do {
        if first then first = false else b.","
        b." {substitution.key} = {substitution.value}"
      }
    }
    b.to_string()
  }) or(signature) return ok[String, Error](signature)

  var mapping = map[Id, Id]() | Egg Id to Yogurt Id
  var dag = dag[YogurtExpr]()
  var body = fun_.body
    .compile(mapping.&, dag.&, fun_.dag, substitutions, context)?
  var fun_ = YogurtFun { dag, body }

  ok[String, Error](compilation.done(fun_))
}

struct YogurtFunContext {
  mapping: &Map[Id, YogurtExpr],
  dag: &Dag[YogurtExpr],
  egg_dag: Dag[EggExpr],
  substitutions: Substitutions,
  global: &YogurtGlobalContext,
}

| Assumes that mappings for the parameters exist.
fun compile(
  egg_body: EggBody, context: YogurtFunContext
): Result[YogurtBody, Error] {
  var body = body_builder(dag).&
  for egg_id in egg_body.params do
    mapping.put(
      egg_id, body.param(egg_dag.type_of(egg_id).specialize(substitutions))
    )

  for egg_id in egg_body.children do
    mapping.put(egg_id, egg_dag.get(egg_id).compile(context)?)

  var body = body.finish(mapping.get(egg_body.returns))
  ok[YogurtBody, Error](body)
}
fun compile(
  expr: EggExpr, context: YogurtFunContext
): Result[YogurtExpr, Error] {
  var substitutions = context.substitutions
  var type = expr.type.specialize(substitutions)

  switch expr.op
  case param unreachable()
  case id(id) mapping.get(id)
  case int(int) yogurt_int(int)
  case string(string) yogurt_string(string)
  case struct_(struct_) {
    var fields = map[String, YogurtExpr]()
    for field in struct_ do
      fields.&.put(field.key, field.value.compile(context))
    struct_(fields)
  }
  case member(member) member.of.compile(context).member(member.name)
  case enum_(enum_) enum_(type, enum_.name, enum_.value.compile(context))
  case switch_(switch_)
    switch_.condition.compile(context).switch_(type, {
      var cases = map[String, YogurtBody]()
      for case_ in switch_.cases do
        cases.&.put(case_.key, case_.value.compile(context)?)
      cases
    })
  case lambda(lambda) lambda(lambda.compile(context))
  case call(call) {
    var args = list[YogurtExpr]()
    for arg in call.args do args.compile(context)
    var args = args.to_slice()

    switch call.callee
    case lambda(lambda) lambda.compile(context).call(args)
    case fun_(matching_fun) {
      var signature = matching_fun.signature
      var merged_substitutions =
        matching_fun.substitutions.specialize(substitutions)
      var fun_ = context.egg.funs.get(signature)
      compile(fun_, signature, merged_substitutions, context.global)?
        .call(args, type)
    }
    case builtin(matching_builtin) {
      var merged_substitutions =
        matching_builtin.substitutions.specialize(substitutions)
      var yogurt_builtin =
        switch matching_builtin.builtin
        case lower_byte YogurtBuiltin.lower_byte
        case byte_to_int YogurtBuiltin.byte_to_int
        case add_ints YogurtBuiltin.add_ints
        case sub_ints YogurtBuiltin.sub_ints
        case mul_ints YogurtBuiltin.mul_ints
        case div_ints YogurtBuiltin.div_ints
        case mod_ints YogurtBuiltin.mod_ints
        case and_ints YogurtBuiltin.and_ints
        case or_ints YogurtBuiltin.or_ints
        case xor_ints YogurtBuiltin.xor_ints
        case compare_ints YogurtBuiltin.compare_ints
        case box YogurtBuiltin.box
        case unbox YogurtBuiltin.unbox
        case generate_array YogurtBuiltin.generate_array
        case array_get YogurtBuiltin.array_get
        case array_set YogurtBuiltin.array_set
        case array_slice YogurtBuiltin.array_slice
        case array_len YogurtBuiltin.array_len
        case call
          return ok[YogurtExpr, Error](
            args.get(0).call(empty_slice[YogurtExpr]())
          )
        case crash YogurtBuiltin.crash
        case type_of
          return ok[YogurtExpr, Error](yogurt_type(call.args.get(0).type))
        case type_info {
          var type =
            matching_builtin.substitutions.substitutions.get("arg_0")
              .specialize(substitutions)
          return ok[YogurtExpr, Error](type_info(type))
        }
        case static_to_dynamic
          return ok[YogurtExpr, Error](
            call.args.get(0).static_to_dynamic(context.global)
          )
        case dynamic_to_static {
          var type = merged_substitutions.substitutions.get("arg_1")
          return ok[YogurtExpr, Error](
            call.args.get(0).dynamic_to_static(type, context.global)
          )
        }

      yogurt_builtin.yogurt_call(args, type)
    }
  }
  case cast(what)
    what.compile(context).yogurt_cast(
      what.type.specialize(substitutions),
      expr.type.specialize(substitutions),
      context,
    )
  case type(type_value) yogurt_type(type_value.specialize(substitutions))
  .ok[YogurtExpr, Error]()
}

fun captured_variables(expr: EggExpr, dag: Dag[EggExpr]): Slice[Id] {
  var ignore = set[Id]()
  var captured = list[Id]()
  expr.collect_captured(ignore.&, captured.&, dag)
  captured.to_slice()
}
fun collect_captured(id: Id, ignore: &Set[Id], captured: &List[Id]) {
  if not(ignore.contains(id)) then {
    captured.push(id)
    ignore.put(id)
  }
}
fun collect_captured(
  body: EggBody, ignore: &Set[Id], captured: &List[Id], dag: Dag[EggExpr]
) {
  for param in body.params do ignore.put(param)
  for child in body.children do {
    dag.get(child).collect_captured(ignore, captured, dag)
    ignore.put(child)
  }
  body.returns.collect_captured(ignore, captured)
}
fun collect_captured(
  expr: EggExpr, ignore: &Set[Id], captured: &List[Id], dag: Dag[EggExpr]
) {
  switch expr.op
  case param unreachable()
  case int {}
  case string {}
  case struct_(struct_)
    for field in struct_ do field.value.collect_captured(ignore, captured)
  case member(member) member.of.collect_captured(ignore, captured)
  case enum_(enum_) enum_.value.collect_captured(ignore, captured)
  case switch_(switch_) {
    switch_.condition.collect_captured(ignore, captured)
    for case_ in switch_.cases do
      case_.value.collect_captured(ignore, captured, dag)
  }
  case lambda(lambda) lambda.collect_captured(ignore, captured, dag)
  case call(call) {
    for arg in call.args do arg.collect_captured(ignore, captured)
    switch call.callee
    case lambda(lambda) lambda.collect_captured(ignore, captured)
    case fun_ {}
    case builtin {}
  }
  case cast(other) other.collect_captured(ignore, captured)
  case type {}
}
