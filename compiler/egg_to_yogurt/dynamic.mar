import mod.mar

fun static_to_dynamic(
  body: &YogurtBodyBuilder, value: Id, type: EggType, context: &YogurtContext
): Id {
  var fun_ = compile_static_to_dynamic_fun(type, context)
  body.call_fun(fun_, list(value).to_slice(), type_dynamic.compile())
}
fun compile_static_to_dynamic_fun(
  type: EggType, context: &YogurtContext
): String {
  var type = type.canonicalize()
  type.is_self_contained() or
    panic("type is not self-contained:\n{type.indented()}")

  var compilation = context.start_compiling("{type} to dynamic")
    or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var param = body.param(type.compile())
  var returns = compile_static_to_dynamic_fun_body(type, body, param, context)

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(returns) })
}
fun compile_static_to_dynamic_fun_body(
  type: EggType, body: &YogurtBodyBuilder, value: Id, context: &YogurtContext
): Id {
  switch type.extend_one_level()
  case var_ panic("type var in compile to dynamic")
  case primitive(primitive) {
    var name = primitive.name
    if name == "Int" then body.enum_(type_dynamic.compile(), "int", value)
    else if name == "Byte" then
      body.enum_(type_dynamic.compile(), "byte", value)
    else if name == "Array" then {
      var len = body.array_len(value)
      var lambda = body.lambda(
        type_lambda(list(type_int).to_slice(), type_dynamic).compile(),
        compile_array_items_to_dynamic_fun(primitive.args.get(0), context),
        body.closure(value),
      )
      var array = body.generate_array(
        len, lambda, type_array(type_dynamic).compile()
      )
      body.enum_(type_dynamic.compile(), "array", array)
    } else
      panic("unknown primitive type {type}")
  }
  case never body.unreachable(type_dynamic.compile())
  case struct_(field_types)
    body.enum_(type_dynamic.compile(), "struct", {
      var dynamic_fields = list[Id]()
      for field in field_types do {
        var name = field.key
        var field_type = field.value

        var field_value = body.member(value, name, field_type.compile())
        var field_dynamic_value =
          body.static_to_dynamic(field_value, field_type, context)

        dynamic_fields.&.push(body.struct_(type_dynamic_field.compile(), map(
          "name" -> body.string(name),
          "value" -> field_dynamic_value,
        )))
      }
      body.array(type_dynamic_fields.compile(), dynamic_fields.to_slice())
    })
  case enum_(variant_types)
    body.enum_(type_dynamic.compile(), "enum", {
      body.switch_(value, type_dynamic_variant.compile(), {
        var cases = map[String, YogurtBody]()
        for variant in variant_types do {
          var name = variant.key
          var variant_type = variant.value

          var body = body_builder(body.dag).&
          var payload_value = body.param(variant_type.compile())
          var payload_dynamic =
            body.static_to_dynamic(payload_value, variant_type, context)

          var name_and_value = body.struct_(type_dynamic_variant.compile(), map(
            "name" -> body.string(name),
            "value" -> payload_dynamic,
          ))
          cases.&.put(name, body.finish(name_and_value))
        }
        cases
      })
    })
  case lambda body.enum_(type_dynamic.compile(), "lambda", body.nothing())
  case recursive unreachable()
}
fun compile_array_items_to_dynamic_fun(
  item_type: EggType, context: &YogurtContext
): String {
  var item_type = item_type.canonicalize() | TODO: assume/check that type is canonicalized
  item_type.is_self_contained() or
    panic("type is not self-contained:\n{item_type.indented()}")

  var compilation =
    context.start_compiling("converting array item of {item_type} to dynamic")
      or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var index = body.param(item_type.compile())
  var closure = body.param(
    YogurtType.closure(type_array(item_type).compile().put_on_heap())
  )
  var array = body.get_closure(closure, type_array(item_type).compile())
  var item = body.array_get(array, index, item_type.compile())
  var converted = body.static_to_dynamic(item, item_type, context)

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(converted) })
}

fun dynamic_to_static(
  body: &YogurtBodyBuilder, value: Id, type: EggType, context: &YogurtContext
): Id {
  var fun_ = compile_dynamic_to_static_fun(type, context)
  body.call_fun(fun_, list(value).to_slice(), type.compile())
}
fun compile_dynamic_to_static_fun(
  type: EggType, context: &YogurtContext
): String {
  var type = type.canonicalize()
  type.is_self_contained() or
    panic("type is not self-contained:\n{type.indented()}")

  var compilation =
    context.start_compiling("dynamic to {type}") or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var value = body.param(type_dynamic.compile())
  var result =
    switch type.extend_one_level()
    case var_ panic("type var in compile to dynamic")
    case primitive(primitive) {
      var name = primitive.name
      if name == "Int" then
        body.switch_(value, type.compile(), {
          var cases = map[String, YogurtBody]()
          for entry in type_dynamic.extend_one_level().enum_.unwrap() do {
            var name = entry.key
            var payload_type = entry.value.canonicalize()
            var body = body_builder(body.dag).&
            var payload = body.param(payload_type.compile())
            var result =
              if name == "int"
              then payload
              else body.crash(
                "dynamic to static failed (expected int, got {name})",
                type_never.compile(),
              )
            cases.&.put(name, body.finish(result))
          }
          cases
        })
      else if name == "Byte" then
        body.switch_(value, type.compile(), {
          var cases = map[String, YogurtBody]()
          for entry in type_dynamic.extend_one_level().enum_.unwrap() do {
            var name = entry.key
            var payload_type = entry.value.canonicalize()
            var body = body_builder(body.dag).&
            var payload = body.param(payload_type.compile())
            var result =
              if name == "byte"
              then payload
              else body.crash(
                "dynamic to static failed (expected Byte)", type_never.compile()
              )
            cases.&.put(name, body.finish(result))
          }
          cases
        })
      else if name == "Array" then {
        todo("array to static")
      } else
        panic("unknown primitive type {type}")
    }
    case never body.crash("tried to build Never from Dynamic", type.compile())
    case struct_(field_types)
      body.switch_(value, type.compile(), {
        var cases = map[String, YogurtBody]()
        for entry in type_dynamic.extend_one_level().enum_.unwrap() do {
          var name = entry.key
          var payload_type = entry.value.canonicalize()
          var body = body_builder(body.dag).&
          var payload = body.param(payload_type.compile())
          var result =
            if name == "struct" then
              body.struct_(type.compile(), {
                var fields = map[String, Id]()
                for field in field_types do {
                  var name = field.key
                  var field_type = field.value
                  var field = body.find_field_in_array(
                    payload, body.string(name), context
                  )
                  var field = body.dynamic_to_static(field, field_type, context)
                  fields.&.put(name, field)
                }
                fields
              })
            else
              body.crash(
                "dynamic to static failed (expected struct)", type.compile()
              )
          cases.&.put(name, body.finish(result))
        }
        cases
      })
    case enum_(variant_types) {
      todo("enum to static")
    }
    case lambda
      body.crash("tried to create lambda from dynamic", type.compile())
    case recursive unreachable()

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
fun find_field_in_array(
  body: &YogurtBodyBuilder, array: Id, name: Id, context: &YogurtContext
): Id {
  body.call_fun(
    compile_find_field_in_array_fun(context),
    list(array, name, body.int(0)).to_slice(),
    type_dynamic.compile(),
  )
}
| Finds the value of a field in an (Array (& name: String value: Dynamic))
fun compile_find_field_in_array_fun(context: &YogurtContext): String {
  var compilation =
    context.start_compiling(
      "find field in (Array (& name: String value: Dynamic))"
    ) or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var array = body.param(type_dynamic_fields.compile())
  var name = body.param(type_string.compile())
  var index = body.param(type_int.compile())

  var len = body.array_len(array)
  var result = body.switch_(
    body.compare_ints(index, len),
    type_dynamic.compile(),
    map(
      "less" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        var field = body.array_get(array, index, type_dynamic_field.compile())
        var field_name = body.member(field, "name", type_string.compile())
        var matches = body.compare_strings(name, field_name, context)
        body.finish(body.switch_(matches, type_dynamic.compile(), map(
          "true" -> {
            var body = body_builder(body.dag).&
            body.param(type_nothing.compile())
            body.finish(body.member(field, "value", type_dynamic.compile()))
          },
          "false" -> {
            var body = body_builder(body.dag).&
            body.param(type_nothing.compile())
            body.finish(body.call_fun(
              compile_find_field_in_array_fun(context),
              list(array, name, body.add_ints(index, body.int(1))).to_slice(),
              type_dynamic.compile(),
            ))
          }
        )))
      },
      "equal" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.crash("field not in struct", type_dynamic.compile()))
      },
      "greater" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.unreachable(type_dynamic.compile()))
      },
    ),
  )

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
fun compare_strings(
  body: &YogurtBodyBuilder, a: Id, b: Id, context: &YogurtContext
): Id {
  body.call_fun(
    compile_compare_strings_fun(context),
    list(a, b).to_slice(),
    type_bool.compile(),
  )
}
fun compile_compare_strings_fun(context: &YogurtContext): String {
  var compilation =
    context.start_compiling("compare strings") or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var a = body.param(type_string.compile())
  var b = body.param(type_string.compile())

  var a_bytes = body.member(a, "utf8_bytes", type_array(type_byte).compile())
  var b_bytes = body.member(b, "utf8_bytes", type_array(type_byte).compile())

  var result = body.switch_(
    body.compare_ints(body.array_len(a_bytes), body.array_len(b_bytes)),
    type_bool.compile(),
    map(
      "less" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.enum_(type_bool.compile(), "false", body.nothing()))
      },
      "equal" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.call_fun(
          compile_compare_strings_rec_fun(context),
          list(a_bytes, b_bytes, body.int(0)).to_slice(),
          type_bool.compile(),
        ))
      },
      "greater" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.enum_(type_bool.compile(), "false", body.nothing()))
      },
    ),
  )

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
fun compile_compare_strings_rec_fun(context: &YogurtContext): String {
  var compilation =
    context.start_compiling("compare strings rec")
      or(signature) return signature

  var dag = dag[YogurtExpr]().&
  var body = body_builder(dag).&

  var a = body.param(type_array(type_byte).compile())
  var b = body.param(type_array(type_byte).compile())
  var index = body.param(type_int.compile())

  var result = body.switch_(
    body.compare_ints(index, body.array_len(a)),
    type_bool.compile(),
    map(
      "less" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.switch_(
          body.compare_ints(
            body.byte_to_int(body.array_get(a, index, YogurtType.byte)),
            body.byte_to_int(body.array_get(b, index, YogurtType.byte)),
          ),
          type_bool.compile(),
          map(
            "less" -> {
              var body = body_builder(body.dag).&
              body.param(type_nothing.compile())
              body.finish(body.enum_(
                type_bool.compile(), "false", body.nothing()
              ))
            },
            "equal" -> {
              var body = body_builder(body.dag).&
              body.param(type_nothing.compile())
              var result = body.call_fun(
                compile_compare_strings_rec_fun(context),
                list(a, b, body.add_ints(index, body.int(1))).to_slice(),
                type_bool.compile(),
              )
              body.finish(result)
            },
            "greater" -> {
              var body = body_builder(body.dag).&
              body.param(type_nothing.compile())
              body.finish(body.enum_(
                type_bool.compile(), "false", body.nothing()
              ))
            },
          ),
        ))
      },
      "equal" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.enum_(
          type_bool.compile(), "true", body.nothing()
        ))
      },
      "greater" -> {
        var body = body_builder(body.dag).&
        body.param(type_nothing.compile())
        body.finish(body.unreachable(type_bool.compile()))
      },
    ),
  )

  compilation.done(YogurtFun { dag = dag.*, body = body.finish(result) })
}
