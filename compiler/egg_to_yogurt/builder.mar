import mod.mar

struct YogurtBodyBuilder {
  dag: &Dag[YogurtExpr], params: List[Id], children: List[Id]
}

fun body_builder(dag: &Dag[YogurtExpr]): _ {
  YogurtBodyBuilder { dag, params = list[Id](), children = list[Id]() }
}
fun param(type: EggType): Id {
  var id = body.dag.&.put(YogurtExpr { op = YogurtOp.param, type })
  body.params.&.push(id)
  id
}
fun push(op: YogurtOp, type: EggType): Id {
  var id = body.dag.&.put(YogurtExpr { op, type })
  body.children.&.push(id)
  id
}
fun get(body: YogurtBodyBuilder, id: Id): YogurtExpr { body.dag.get(id) }
fun type_of(body: YogurtBodyBuilder, id: Id): EggType {
  body.dag.type_of(id)
}
fun finish(body: YogurtBodyBuilder, id: Id): YogurtBody {
  YogurtBody {
    params = body.params.to_slice(),
    children = body.children.to_slice(),
    returns = id,
  }
}

fun typed(op: YogurtOp, type: EggType): YogurtExpr { YogurtExpr { op, type } }

fun yogurt_id(id: Id, type: EggType): YogurtExpr { YogurtOp.id(id).typed(type) }
fun yogurt_byte(byte: Byte): YogurtExpr { YogurtOp.byte(byte).typed(type_byte) }
fun yogurt_int(int: Int): YogurtExpr { YogurtOp.int(int).typed(type_int) }
fun array(item_type: EggType, items: Slice[YogurtExpr]): YogurtExpr {
  YogurtOp.array(items).typed(type_array(item_type))
}
fun yogurt_string(string: String): YogurtExpr {
  var bytes = list[YogurtExpr]()
  for byte in string.bytes() do bytes.&.push(yogurt_byte(byte))
  yogurt_array(type_byte, bytes)
}
fun struct_(fields: Map[String, YogurtExpr]): YogurtExpr {
  var field_types = map[String, EggType]()
  for field in fields do field_types.&.put(field.key, field.value.type)
  YogurtOp.struct_(fields).typed(type_struct(field_types))
}
fun member(of: YogurtExpr, name: String): YogurtExpr {
  YogurtOp.member(YogurtMember { of = of.put_on_heap(), name })
    .typed(of.type.kind().struct_.unwrap().get(name))
}
fun enum_(type: EggType, name: String, value: YogurtExpr): YogurtExpr {
  YogurtOp.enum_(YogurtEnum { name, value }).typed(type)
}
fun switch_(
  condition: YogurtExpr, type: EggType, cases: Map[String, YogurtBody]
): YogurtExpr {
  YogurtOp.switch_(YogurtSwitch {
    condition = condition.put_on_heap(), cases
  }).typed(type)
}
fun lambda(body: YogurtBody, dag: Dag[YogurtExpr]): YogurtExpr {
  var arg_types = todo()
  YogurtOp.lambda(body.put_on_heap()).typed(arg_types)
}
fun call(
  callee: YogurtCallee, args: Slice[YogurtExpr], return_type: EggType
): YogurtExpr {
  YogurtOp.call(YogurtCall { callee, args }).typed(return_type)
}
fun call(lambda: YogurtExpr, args: Slice[YogurtExpr]): YogurtExpr {
  call(YogurtCallee.lambda(lambda.put_on_heap()), args, return_type)
}
fun call(
  fun_: String, args: Slice[YogurtExpr], return_type: EggType
): YogurtExpr {
  call(YogurtCallee.fun_(fun_), args, return_type)
}
fun call(
  builtin: YogurtBuiltin, args: Slice[YogurtExpr], return_type: EggType
): YogurtExpr {
  call(YogurtCallee.builtin(builtin), args, return_type)
}
fun add(a: YogurtExpr, b: YogurtExpr): YogurtExpr {
  YogurtBuiltin.add_ints.call(list(a, b).to_slice(), type_int)
}
fun array_get(array: YogurtExpr, index: YogurtExpr): YogurtExpr {
  YogurtBuiltin.array_get.call(
    list(array, index).to_slice(),
    array.type.kind().array.unwrap(),
  )
}
fun array_len(array: YogurtExpr): YogurtExpr {
  YogurtBuiltin.array_len.call(list(array).to_slice(), type_int)
}
fun box(inner: YogurtExpr): YogurtExpr {
  YogurtBuiltin.box.call(list(inner).to_slice(), type_box(inner.type))
}
fun unbox(box: YogurtExpr): YogurtExpr {
  YogurtBuiltin.unbox.call(
    list(box).to_slice(), box.type.kind().box.unwrap()
  )
}
fun byte_to_int(byte: YogurtExpr): YogurtExpr {
  YogurtBuiltin.byte_to_int.call(list(byte).to_slice(), type_int)
}
fun generate_array(length: YogurtExpr, generator: YogurtExpr): YogurtExpr {
  YogurtBuiltin.generate_array.call(
    list(length, generator).to_slice(),
    type_array(body.type_of(generator).kind().lambda.unwrap().return_type),
  )
}
fun compare_ints(a: YogurtExpr, b: YogurtExpr): YogurtExpr {
  YogurtBuiltin.compare_ints.call(list(a, b).to_slice(), type_ordering)
}
fun crash(message: YogurtExpr, type: EggType): YogurtExpr {
  YogurtBuiltin.crash.call(list(message).to_slice(), type)
}
fun yogurt_crash(message: String, type: EggType): YogurtExpr {
  crash(yogurt_string(message), type)
}
fun yogurt_unreachable(type: EggType): YogurtExpr {
  yogurt_crash("unreachable", type)
}
fun yogurt_type(type: EggType): YogurtExpr {
  YogurtOp.type(type).typed(type_type)
}
var yogurt_nothing = yogurt_struct(map[String, YogurtExpr]())
var yogurt_true = enum_(type_bool, "true", yogurt_nothing)
var yogurt_false = enum_(type_bool, "false", yogurt_nothing)

fun body(
  dag: Dag[YogurtExpr], params: Slice[EggType], returns: YogurtExpr
): YogurtBody {
  var body = dag.body_builder().&
  for param in params do body.param(param)
  body.finish(returns)
}
fun body_accepting_nothing(
  dag: Dag[YogurtExpr], returns: YogurtExpr
): YogurtBody {
  dag.body(list(type_nothing).to_slice(), returns)
}
