import mod.mar

fun tree_shake(body: PestoBody): PestoBody {
  | We go through the body from the bottom to the top, tracking which locals are
  | referenced later in the body. This way, when we encounter an expression, we
  | know immediately whether we can throw it away.
  var referenced_later_on = set[PestoId]()
  referenced_later_on.&.put(body.returns)

  var rev_children = list[PestoId]()
  for id in body.children.rev_iter() do {
    if not(referenced_later_on.contains(id)) and id.is_pure_biased() then
      continue

    for referenced in id.captured() do referenced_later_on.&.put(referenced)
    rev_children.&.push(id)
  }
  var children = list[PestoId]()
  for id in rev_children.to_slice().rev_iter() do children.&.push(id)

  PestoBody {
    param = body.param, children = children.to_slice(), returns = body.returns
  }
}

fun is_pure_biased(id: PestoId): Bool {
  switch id.resolve()
  case param true
  case byte true
  case lower_byte true
  case byte_to_int true
  case int true
  case add true
  case subtract true
  case multiply true
  case divide true
  case modulo true
  case and_ true
  case or_ true
  case xor true
  case compare true
  case struct_ true
  case member true
  case enum_ true
  case switch_ true
  case function_ptr true
  case call false
  case call_indirect false
  case new true
  case load true
  case free false
  case get_refcount true
  case increment_refcount false
  case decrement_refcount false
  case new_buffer true
  case get_buffer_len true
  case load_buffer_item true
  case store_buffer_item false
  case store_buffer_bytes false
  case free_buffer false
  case crash false
  case unreachable true
  case loop_ false
  case continue_ false
}
