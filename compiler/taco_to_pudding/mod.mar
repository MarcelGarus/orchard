| Converting Taco to Pudding  
|
| IDs in the Taco and Pudding are the same. Generally, the Pudding is also
| very similar to the Taco in terms of abstraction. The only difference is
| that it contains additional dup/drop instructions for incrementing and
| decrementing the reference counts of values.
| Every value in the Pudding is reference counted. Later on, some of the
| reference counting operations are simplified (for example, if a type doesn't
| require any heap allocations, no reference counting occurs because it is
| always copied).

import ../plum.mar

fun to_pudding(taco: Taco): Pudding {
  if taco.entry_point.substitutions.substitutions.is_not_empty() then
    panic("entry point not monomorphized")
  var entry_point = taco.entry_point.signature
  var funs = map[String, PuddingBody]()
  for fun_ in taco.funs do {
    | eprintln("Compiling {fun_.key}")
    funs.&.put(fun_.key, fun_.value.to_pudding(funs.&))
  }
  Pudding { entry_point, funs }
}

| TODO: inline
fun to_pudding(body: TacoBody, funs: &Map[String, PuddingBody]): PuddingBody {
  var expr = body.expr.to_pudding(funs)

  for param in body.params do {
    | TODO: Count how often then the param is used.
    | 0: drop it
    | 1: do nothing
    | >1: dup it
  }

  PuddingBody { params = body.params, expr }
}

fun to_pudding(expr: TacoExpr, funs: &Map[String, PuddingBody]): PuddingExpr {
  switch expr.op
  case hole(hole) pudding_hole(hole)
  case type(type) pudding_type(type)
  case byte(byte) pudding_byte(byte)
  case int(int) pudding_int(int)
  case array(array) {
    var items = list[PuddingExpr]()
    for item in array do items.&.push(item.to_pudding(funs))
    array(expr.type.kind().array.unwrap(), items.to_slice())
  }
  case struct_(struct_) {
    var fields = map[String, PuddingExpr]()
    for field in struct_ do
      fields.&.put(field.key, field.value.to_pudding(funs))
    struct_(fields)
  }
  case enum_(enum_)
    enum_(expr.type, enum_.variant, enum_.payload.to_pudding(funs))
  case lambda(lambda) {
    | Compile the lambda into a stand-alone function that accepts a closure as
    | an additional first argument.
    var signature = "lambda-{hole(type_nothing).id}"
    var captured = lambda.expr.collect_captured()
    var closure_arg = box(struct_({
      var fields = map[String, PuddingExpr]()
      for captured in captured.iter().enumerate() do
        fields.&.put("{captured.index}", pudding_hole(captured.item))
      fields
    }))
    var closure_param = hole(closure_arg.type)
    funs.put(signature, body(
      {
        var params = list(closure_param)
        for param in lambda.params do params.&.push(param)
        params.to_slice()
      },
      {
        | TODO: dup/drop args as necessary
        var unboxed_closure = hole(closure_param.type.kind().box.unwrap())
        var fillings = map[Hole, TacoExpr]()
        for captured in captured.iter().enumerate() do
          fillings.&.put(
            captured.item, taco_hole(unboxed_closure).member("{captured.index}")
          )
        let(
          unbox(pudding_hole(closure_param)),
          body(unboxed_closure, lambda.expr.fill(fillings).to_pudding(funs)),
        )
      }
    ))
    lambda(expr.type, signature, closure_arg)
  }
  case box(inner) box(inner.to_pudding(funs))
  case member(member) member.of.to_pudding(funs).member(member.name)
  case switch_(switch_) {
    var cases = map[String, PuddingBody]()
    for case_ in switch_.cases do
      cases.&.put(case_.key, case_.value.to_pudding(funs))
    switch_(switch_.condition.to_pudding(funs), expr.type, cases)
  }
  case call_fun(call) {
    if call.fun_.substitutions.substitutions.is_not_empty() then
      panic("call not monomorphized")
    var args = list[PuddingExpr]()
    for arg in call.args do args.&.push(arg.to_pudding(funs))
    call.fun_.signature.call(args.to_slice(), expr.type)
  }
  case call_lambda(call) {
    var args = list[PuddingExpr]()
    for arg in call.args do args.&.push(arg.to_pudding(funs))
    call.lambda.to_pudding(funs).call(args.to_slice())
  }
  case both(both)
    both(both.ignored.to_pudding(funs), both.result.to_pudding(funs))
  case let(let) {
    | TODO: check how often the definition is used in the result
    | if needed_later_on.contains(id) then
    |   needed_later_on.remove(id)
    | else
    |   rev_body.&.push(dag.put_drop(id))
    let(let.def.to_pudding(funs), let.result.to_pudding(funs))
  }
  case cast panic("cast not desugared")
  case lower_byte(arg) lower_byte(arg.to_pudding(funs))
  case byte_to_int(arg) byte_to_int(arg.to_pudding(funs))
  case add_ints(args) add(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case sub_ints(args) subtract(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case mul_ints(args) multiply(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case div_ints(args) divide(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case mod_ints(args) modulo(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case and_ints(args) and_(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case or_ints(args) or_(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case xor_ints(args) xor(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case compare_ints(args)
    compare(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case unbox(arg) unbox(arg.to_pudding(funs))
  case generate_array(gen)
    generate_array(gen.length.to_pudding(funs), gen.generator.to_pudding(funs))
  case array_get(args)
    array_get(args.a.to_pudding(funs), args.b.to_pudding(funs))
  case array_set(args)
    array_set(
      args.a.to_pudding(funs), args.b.to_pudding(funs), args.c.to_pudding(funs)
    )
  case array_slice(args)
    array_set(
      args.a.to_pudding(funs), args.b.to_pudding(funs), args.c.to_pudding(funs)
    )
  case array_len(arg) array_len(arg.to_pudding(funs))
  case crash pudding_crash(expr.type)
  case type_info panic("type_info not desugared")
  case static_to_dynamic panic("static_to_dynamic not desugared")
  case dynamic_to_static panic("dynamic_to_static not desugared")
  case recursive(recursive) {
    var signature = "recursive-{hole(type_nothing).id}"
    var captured = recursive.body.collect_captured()
    funs.put(signature, body(
      {
        var params = list[Hole]()
        for captured in captured do params.&.push(captured)
        for param in recursive.body.params do params.&.push(param)
        params.to_slice()
      },
      recursive.body.expr.to_pudding(funs),
    ))
    signature.call({
      var args = list[PuddingExpr]()
      for captured in captured do args.&.push(pudding_hole(captured))
      for arg in recursive.initial do args.&.push(arg.to_pudding(funs))
      args.to_slice()
    }, expr.type)
  }
  case recurse pudding_unreachable(expr.type)
  case unreachable pudding_unreachable(expr.type)
}
