| Converting Taco to Pudding  
|
| IDs in the Taco and Pudding are the same. Generally, the Pudding is also
| very similar to the Taco in terms of abstraction. The only difference is
| that it contains additional dup/drop instructions for incrementing and
| decrementing the reference counts of values.
| Every value in the Pudding is reference counted. Later on, some of the
| reference counting operations are simplified (for example, if a type doesn't
| require any heap allocations, no reference counting occurs because it is
| always copied).

import ../plum.mar

fun to_pudding(taco: Taco): Pudding {
  if taco.entry_point.substitutions.substitutions.is_not_empty() then
    panic("entry point not monomorphized")
  var entry_point = taco.entry_point.signature
  var funs = map[String, PuddingBody]()
  for fun_ in taco.funs do {
    | eprintln("Compiling {fun_.key}")
    funs.&.put(
      fun_.key,
      fun_.value.to_pudding(ToPuddingContext {
        funs = funs.&, recursive = none[OngoingRecursive]()
      }),
    )
  }
  Pudding { entry_point, funs }
}

struct ToPuddingContext {
  funs: &Map[String, PuddingBody], recursive: Maybe[OngoingRecursive]
}
struct OngoingRecursive { signature: String, captured: Slice[Hole] }

| TODO: inline
fun to_pudding(body: TacoBody, context: ToPuddingContext): PuddingBody {
  var expr = body.expr.to_pudding(context)

  for param in body.params do {
    | TODO: Count how often then the param is used.
    | 0: drop it
    | 1: do nothing
    | >1: dup it
  }

  PuddingBody { params = body.params, expr }
}

fun to_pudding(expr: TacoExpr, context: ToPuddingContext): PuddingExpr {
  switch expr.op
  case hole(hole) pudding_hole(hole)
  case type(type) pudding_type(type)
  case byte(byte) pudding_byte(byte)
  case int(int) pudding_int(int)
  case array(array) {
    var items = list[PuddingExpr]()
    for item in array do items.&.push(item.to_pudding(context))
    array(expr.type.kind().array.unwrap(), items.to_slice())
  }
  case struct_(struct_) {
    var fields = map[String, PuddingExpr]()
    for field in struct_ do
      fields.&.put(field.key, field.value.to_pudding(context))
    struct_(fields)
  }
  case enum_(enum_)
    enum_(expr.type, enum_.variant, enum_.payload.to_pudding(context))
  case lambda(lambda) {
    | Compile the lambda into a stand-alone function that accepts a closure as
    | an additional first argument.
    var signature = "lambda-{hole(type_nothing).id}"
    var captured = lambda.expr.collect_captured()
    var closure_arg = box(struct_({
      var fields = map[String, PuddingExpr]()
      for captured in captured.iter().enumerate() do
        fields.&.put("{captured.index}", pudding_hole(captured.item))
      fields
    }))
    var closure_param = hole(closure_arg.type)
    context.funs.put(signature, body(
      {
        var params = list(closure_param)
        for param in lambda.params do params.&.push(param)
        params.to_slice()
      },
      {
        | TODO: dup/drop args as necessary
        var unboxed_closure = hole(closure_param.type.kind().box.unwrap())
        var fillings = map[Hole, TacoExpr]()
        for captured in captured.iter().enumerate() do
          fillings.&.put(
            captured.item, taco_hole(unboxed_closure).member("{captured.index}")
          )
        let(
          unbox(pudding_hole(closure_param)),
          body(unboxed_closure, lambda.expr.fill(fillings).to_pudding(context)),
        )
      }
    ))
    lambda(expr.type, signature, closure_arg)
  }
  case box(inner) box(inner.to_pudding(context))
  case member(member) member.of.to_pudding(context).member(member.name)
  case switch_(switch_) {
    var cases = map[String, PuddingBody]()
    for case_ in switch_.cases do
      cases.&.put(case_.key, case_.value.to_pudding(context))
    switch_(switch_.condition.to_pudding(context), expr.type, cases)
  }
  case call_fun(call) {
    if call.fun_.substitutions.substitutions.is_not_empty() then
      panic("call not monomorphized")
    var args = list[PuddingExpr]()
    for arg in call.args do args.&.push(arg.to_pudding(context))
    call.fun_.signature.call(args.to_slice(), expr.type)
  }
  case call_lambda(call) {
    var args = list[PuddingExpr]()
    for arg in call.args do args.&.push(arg.to_pudding(context))
    call.lambda.to_pudding(context).call(args.to_slice())
  }
  case both(both) both(both.a.to_pudding(context), both.b.to_pudding(context))
  case let(let) {
    | TODO: check how often the definition is used in the result
    | if needed_later_on.contains(id) then
    |   needed_later_on.remove(id)
    | else
    |   rev_body.&.push(dag.put_drop(id))
    let(let.a.to_pudding(context), let.b.to_pudding(context))
  }
  case cast panic("cast not desugared")
  case lower_byte(arg) lower_byte(arg.to_pudding(context))
  case byte_to_int(arg) byte_to_int(arg.to_pudding(context))
  case add(args) add(args.a.to_pudding(context), args.b.to_pudding(context))
  case subtract(args) subtract(args.a.to_pudding(context), args.b.to_pudding(context))
  case multiply(args) multiply(args.a.to_pudding(context), args.b.to_pudding(context))
  case divide(args) divide(args.a.to_pudding(context), args.b.to_pudding(context))
  case modulo(args) modulo(args.a.to_pudding(context), args.b.to_pudding(context))
  case and_(args) and_(args.a.to_pudding(context), args.b.to_pudding(context))
  case or_(args) or_(args.a.to_pudding(context), args.b.to_pudding(context))
  case xor(args) xor(args.a.to_pudding(context), args.b.to_pudding(context))
  case compare(args)
    compare(args.a.to_pudding(context), args.b.to_pudding(context))
  case unchecked_divide(args) divide(args.a.to_pudding(context), args.b.to_pudding(context))
  case unchecked_modulo(args) modulo(args.a.to_pudding(context), args.b.to_pudding(context))
  case unbox(arg) unbox(arg.to_pudding(context))
  case generate_array(gen)
    generate_array(gen.a.to_pudding(context), gen.b.to_pudding(context))
  case array_get(args)
    array_get(args.a.to_pudding(context), args.b.to_pudding(context))
  case array_set(args)
    array_set(
      args.a.to_pudding(context),
      args.b.to_pudding(context),
      args.c.to_pudding(context),
    )
  case array_slice(args)
    array_set(
      args.a.to_pudding(context),
      args.b.to_pudding(context),
      args.c.to_pudding(context),
    )
  case array_len(arg) array_len(arg.to_pudding(context))
  case unchecked_generate_non_empty_array(gen)
    generate_array(
      gen.a.to_pudding(context), gen.b.to_pudding(context)
    )
  case unchecked_array_get(args)
    array_get(args.a.to_pudding(context), args.b.to_pudding(context))
  case unchecked_array_set(args)
    array_set(
      args.a.to_pudding(context),
      args.b.to_pudding(context),
      args.c.to_pudding(context),
    )
  case unchecked_array_slice(args)
    array_set(
      args.a.to_pudding(context),
      args.b.to_pudding(context),
      args.c.to_pudding(context),
    )
  case crash pudding_crash(expr.type)
  case type_info panic("type_info not desugared")
  case static_to_dynamic panic("static_to_dynamic not desugared")
  case dynamic_to_static panic("dynamic_to_static not desugared")
  case recursive(rec) {
    var signature = "recursive-{hole(type_nothing).id}"
    var captured = rec.b.collect_captured()
    context.funs.put(signature, body(
      {
        var params = list[Hole]()
        for captured in captured do params.&.push(captured)
        for param in rec.b.params do params.&.push(param)
        params.to_slice()
      },
      rec.b.expr.to_pudding(ToPuddingContext {
        funs = context.funs,
        recursive = some(OngoingRecursive { signature, captured }),
      }),
    ))
    signature.call({
      var args = list[PuddingExpr]()
      for captured in captured do args.&.push(pudding_hole(captured))
      for arg in rec.a do args.&.push(arg.to_pudding(context))
      args.to_slice()
    }, expr.type)
  }
  case recurse(args) {
    var recursive = context.recursive.unwrap()
    var full_args = list[PuddingExpr]()
    for captured in recursive.captured do full_args.&.push(pudding_hole(captured))
    for arg in args do full_args.&.push(arg.to_pudding(context))
    recursive.signature.call(full_args.to_slice(), expr.type)
  }
  case unreachable pudding_unreachable(expr.type)
}
