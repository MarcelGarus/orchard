import mod.mar

fun choose_optimization_order(egg: Egg, entry_point: String): Slice[String] {
  var order = list[String]()
  var stack = list[String]()
  entry_point.choose_optimization_order(egg, order.&, stack.&)
  order.to_slice()
}

fun choose_optimization_order(
  signature: String, egg: Egg, out: &List[String], stack: &List[String]
) {
  if out.iter().&.contains(signature) then return {}
  if stack.iter().&.contains(signature) then return {}
  stack.push(signature)
  var fun_ = egg.funs.get(signature)
  fun_.body.choose_optimization_order(egg, out, stack)
  out.push(signature)
  stack.pop().ignore()
}

fun choose_optimization_order(
  body: EggBody, egg: Egg, out: &List[String], stack: &List[String]
) {
  for id in body.children do
    id.get().choose_optimization_order(egg, out, stack)
  body.returns.choose_optimization_order(egg, out, stack)
}

fun choose_optimization_order(
  expr: EggExpr, egg: Egg, out: &List[String], stack: &List[String]
) {
  switch expr.op
  case param {}
  case id {}
  case byte {}
  case int {}
  case array(array)
    for item in array do item.choose_optimization_order(egg, out, stack)
  case struct_(struct_)
    for field in struct_ do
      field.value.choose_optimization_order(egg, out, stack)
  case member(member) member.of.choose_optimization_order(egg, out, stack)
  case enum_(enum_) enum_.value.choose_optimization_order(egg, out, stack)
  case switch_(switch_) {
    switch_.condition.choose_optimization_order(egg, out, stack)
    for case_ in switch_.cases do
      case_.value.choose_optimization_order(egg, out, stack)
  }
  case lambda(lambda) lambda.choose_optimization_order(egg, out, stack)
  case call(call) {
    switch call.callee
    case lambda(lambda) lambda.choose_optimization_order(egg, out, stack)
    case fun_(called)
      called.signature.choose_optimization_order(egg, out, stack)
    case builtin {}

    for arg in call.args do arg.choose_optimization_order(egg, out, stack)
  }
  case loop_(loop_) {
    for arg in loop_.args do arg.choose_optimization_order(egg, out, stack)
    loop_.body.choose_optimization_order(egg, out, stack)
  }
  case continue_(args)
    for arg in args do arg.choose_optimization_order(egg, out, stack)
  case cast(inner) inner.choose_optimization_order(egg, out, stack)
  case type {}
}
