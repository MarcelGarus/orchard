import mod.mar

fun optimized_call(
  builtin: EggCalledBuiltin, args: Slice[EggExpr], type: EggType,
  context: OptimizeEggExprContext,
): EggExpr {
  eprintln("Optimizing call of {builtin.builtin.debug()}")
  switch builtin.builtin
  case lower_byte
    if args.get(0).op is int(int) then return egg_byte(int.lower_byte())
  case byte_to_int
    if args.get(0).op is byte(byte) then return egg_int(byte.to_int())
  case add_ints {
    var a = args.get(0)
    var b = args.get(1)
    if a.op is int(a) then if a == 0 then return b
    if b.op is int(b) then if b == 0 then return a
    if a.op is int(a) then if b.op is int(b) then return egg_int(a + b)
  }
  case sub_ints {
    var a = args.get(0)
    var b = args.get(1)
    if b.op is int(b) then if b == 0 then return a
    if a.op is int(a) then if b.op is int(b) then return egg_int(a - b)
  }
  case mul_ints {
    var a = args.get(0)
    var b = args.get(1)
    if a.op is int(a) then if a == 1 then return b
    if b.op is int(b) then if b == 1 then return a
    if a.op is int(a) then if b.op is int(b) then return egg_int(a * b)
  }
  case div_ints {
    var a = args.get(0)
    var b = args.get(1)
    if b.op is int(b) then if b == 1 then return a
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return egg_int(a / b)
  }
  case mod_ints {
    var a = args.get(0)
    var b = args.get(1)
    if b.op is int(b) then if b == 1 then return egg_int(0)
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return egg_int(a % b)
  }
  case and_ints {
    var a = args.get(0)
    var b = args.get(1)
    if a.op is int(a) then if a == 0 then return egg_int(0)
    if b.op is int(b) then if b == 0 then return egg_int(0)
    if a.op is int(a) then if a == -1 then return b
    if b.op is int(b) then if b == -1 then return a
    if a.op is int(a) then if b.op is int(b) then return egg_int(a & b)
  }
  case or_ints {
    var a = args.get(0)
    var b = args.get(1)
    if a.op is int(a) then if a == 0 then return b
    if b.op is int(b) then if b == 0 then return a
    if a.op is int(a) then if a == -1 then return egg_int(-1)
    if b.op is int(b) then if b == -1 then return egg_int(-1)
    if a.op is int(a) then if b.op is int(b) then return egg_int(or(a, b))
  }
  case xor_ints {
    var a = args.get(0)
    var b = args.get(1)
    if a.op is int(a) then if b.op is int(b) then return egg_int(a ^ b)
  }
  case compare_ints {
    var a = args.get(0)
    var b = args.get(1)
    if a.op is int(a) then if b.op is int(b) then {
      var symbol =
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater"
      return enum_(type, symbol, egg_nothing)
    }
  }
  case box {}
  case unbox {
    var box = args.get(0)
    if box.op is call(call) then
      if call.callee is builtin(builtin) then
        if builtin.builtin is box then
          return call.args.get(0)
  }
  case generate_array {
    var len = args.get(0)
    var generator = args.get(1)
    var item_type = generator.type.kind().lambda.unwrap().return_type
    if len.op is int(len) then if len <= 10 then {
      var items = list[EggExpr]()
      for index in 0..len do
        items.&.push(
          generator.optimized_call(list(egg_int(index)).to_slice(), context)
        )
      return array(item_type, items.to_slice())
    }
  }
  case array_get {
    var array = args.get(0)
    var index = args.get(1)
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then return items.get(index)
  }
  case array_set {
    var array = args.get(0)
    var index = args.get(1)
    var item  = args.get(2)
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then {
        var new_items = list[EggExpr]()
        for item in items do new_items.&.push(item)
        new_items.&.set(index, item)
        return array(type, new_items.to_slice())
      }
  }
  case array_slice {
    var array = args.get(0)
    var range = args.get(1)
    if array.op is array(items) then if range.op is struct_(range) then {
      var start = range.get("start")
      var end = range.get("end")
      if start.op is int(start) then if end.op is int(end) then {
        if (0..items.len).contains(start) and (0..items.len).contains(end)
        then return array(type, items.subslice(start..end))
      }
    }
  }
  case array_len {
    var array = args.get(0)
    if array.op is array(items) then return egg_int(items.len)
    if array.op is call(call) then
      if call.callee is builtin(builtin) then
        if builtin.builtin is generate_array then
          return call.args.get(0)
  }
  case call return args.get(0).call(empty_slice[EggExpr]())
  case type_of return egg_type(args.get(0).type)
  default {}

  builtin.call(args, type)
}
