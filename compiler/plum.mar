import ../../martinaise/stdlib.mar
import module.mar
import error.mar
import formatting.mar
import type.mar
import builtins.mar
import string_to_bacon.mar
import bacon.mar
import bacon_to_toast.mar
import toast.mar
import toast_to_egg.mar
import egg.mar
import egg_to_yogurt.mar
import yogurt.mar
import yogurt_to_waffle.mar
import memory_layout.mar
import waffle.mar
import waffle_to_byte_code.mar
import vm.mar

| Compiler Stages:
| - Bacon
| - Toast
| - Egg
| - Yogurt
| - Waffle
| - Byte Code

fun main(): Never {
  eprintln("Welcome to the Plum compiler!")

  var byte_code = module("workspace/test").compile() or(error) {
    stderr."Oh no! An error occurred:\n\n{error}\n"
    exit(1)
  }

  | println("Byte Code:")
  | for i in 0..200 do {
  |   var address = byte_code + {i * stride_size_of[ByteCodeInstruction]()}
  |   stdout."{address} | {address.to_reference[ByteCodeInstruction]().*}\n"
  | }

  var result = byte_code.call(list(
    16#33.lower_byte(), 16#33.lower_byte(), 16#33.lower_byte(), 16#33.lower_byte(),
    16#33.lower_byte(), 16#33.lower_byte(), 16#33.lower_byte(), 16#33.lower_byte(),
  ).to_slice())

  var result = result.data.to_reference[Int]().*
  print("Result: {result.radix(16)}")
  | for byte in result do print(" {byte}")
  println()

  exit(0)
}

fun compile(module: Module): Result[Address, Error] {
  var toasts = map[Module, Toast]()
  module.parse_toasts(toasts.&)?
  var egg = toasts.to_egg(module)?
  eprintln("Egg:\n{egg}")
  var yogurt = egg.to_yogurt()?
  var waffle = yogurt.to_waffle()
  var byte_code = waffle.to_byte_code()
  ok[Address, Error](byte_code)
}
fun parse_toasts(
  module: Module, out: &Map[Module, Toast]
): Result[Nothing, Error] {
  if out.contains(module) then return ok[Nothing, Error]({})

  var content = none[String]()
  for path in module.file_paths() do {
    var bytes = read_file(path) or continue
    content = some(bytes.to_string())
    break
  }
  var content = content or
    return error[Nothing, Error](error("Couldn't read file", invalid_src()))

  var bacon = content.to_bacon()
  var toast = bacon.to_toast()?
  out.put(module, toast)

  for def in toast.defs do
    if def is import_(import_) then {
      var imported =
        module.resolve_import(import_.module) or(error)
          return error[Nothing, Error](error(error, invalid_src()))
      imported.parse_toasts(out)?
    }
  ok[Nothing, Error]({})
}
