| Well-Aligned Form of Fixed-Layout Expressions  
|
| This compiler stage is pretty low-level. It's no longer graph based, but
| mainly tree based â€“ as a preparation for lowering to stack-based byte code.
| Types no longer exist. Instead, each expression corresponds to a slice of
| bytes. For expressions to be compatible (such as branches of a switch), they
| just have to have the same length.
| Structs have been converted into runs of expressions (shown using curly
| braces). Enums have been converted into tagged unions.
|
| main Int: @0:8
|   | Creating and accessing a struct.
|   | foo = & x: @0 y: 42   | & y: Int x: Int
|   | foo.y
|   @1 = {@0 42:8}.8:8
|   | Creating and switching on an enum.
|   | foo: Bool = True
|   | foo
|   | % True: Some 5
|   |   False: None
|   @2 = {1:1}.0:1 %
|     0 -> {padding:8 0:1}
|     1 -> {5:8 1:1}

import ../plum.mar
import builder.mar
import dag.mar
import format.mar
import properties.mar
import run.mar

struct Waffle { entry_point: String, funs: Map[String, WaffleFun] }

| Here, functions have implicit parameters: The local @0 is guaranteed to exist
| and contain the parameters when the function starts executing.
struct WaffleFun { body: WaffleBody }
struct WaffleBody { locals: Slice[WaffleId], returns: WaffleExpr }

struct WaffleId { id: Id }

fun ==(a: WaffleId, b: WaffleId): Bool { a.id == b.id }
fun hash[H](hasher: &H, id: WaffleId) { hasher.hash(id.id) }

enum WaffleExpr {
  param: WaffleParam,
  padding: Int, | amount
  local: WaffleId,

  | byte stuff
  byte: Byte, | 8 bits
  lower_byte: &WaffleExpr,
  byte_to_int: &WaffleExpr,

  | int stuff
  int: Int,  | 64 bits
  add: &WaffleExpr,
  subtract: &WaffleExpr,
  multiply: &WaffleExpr,
  divide: &WaffleExpr,
  modulo: &WaffleExpr,
  and_: &WaffleExpr,
  or_: &WaffleExpr,
  xor: &WaffleExpr,
  compare_zero: &WaffleExpr,

  | struct stuff
  aggregate: Slice[WaffleExpr],
  member: WaffleMember,

  | enum stuff
  switch_: WaffleSwitch,

  | calls
  call: WaffleCall,
  call_indirect: WaffleCallIndirect,
  function_ptr: String,

  | memory stuff
  malloc: &WaffleExpr,
  free: &WaffleExpr,
  load: WaffleLoad,
  store: WaffleStore,
  store_bytes: WaffleStoreBytes,

  | diverging stuff
  crash: &WaffleExpr,
  unreachable,

  | loopy stuff
  loop_: WaffleLoop,
  continue_: WaffleContinue,
}
struct WaffleParam { size: Int, alignment: Int }
struct WaffleMember { of: &WaffleExpr, offset: Int, size: Int, alignment: Int }
struct WaffleSwitch { byte: &WaffleExpr, cases: Slice[WaffleBody] }
struct WaffleCall {
  function: String, args: &WaffleExpr, size: Int, alignment: Int
}
struct WaffleCallIndirect {
  function_ptr: &WaffleExpr, args: &WaffleExpr, size: Int, alignment: Int
}
struct WaffleLoad { ptr: &WaffleExpr, size: Int, alignment: Int }
struct WaffleStore { ptr: &WaffleExpr, value: &WaffleExpr }
struct WaffleStoreBytes { ptr: &WaffleExpr, bytes: Slice[Byte] }
struct WaffleLoop { param: WaffleId, initial: &WaffleExpr, body: &WaffleBody }
struct WaffleContinue { next: &WaffleExpr, size: Int, alignment: Int }
