| Less Instructions because of Merged Expressions  
|
| In this representation, we have deduplicated expensive expressions. For
| example, if a function calls another one twice with the same arguments, we
| will actually only call it once and then use the result twice.

import ../plum.mar
import builder.mar

struct Lime { entry_point: String, funs: Map[String, LimeFun] }

struct LimeFun { params: Slice[Hole], body: LimeExpr }
struct LimeExpr { op: LimeOp, type: EggType }
enum LimeOp {
  hole: Hole,

  type: EggType,
  byte: Byte,
  int: Int,
  array: Slice[LimeExpr],
  struct_: Map[String, LimeExpr],
  enum_: LimeEnum,
  lambda: LimeLambda,
  box: &LimeExpr,

  member: LimeMember,
  switch_: LimeSwitch,
  call_fun: LimeCallFun,
  call_lambda: LimeCallLambda,

  body: LimeBody,

  lower_byte: &LimeExpr,
  byte_to_int: &LimeExpr,
  add_ints: Tuple2[&LimeExpr, &LimeExpr],
  sub_ints: Tuple2[&LimeExpr, &LimeExpr],
  mul_ints: Tuple2[&LimeExpr, &LimeExpr],
  div_ints: Tuple2[&LimeExpr, &LimeExpr],
  mod_ints: Tuple2[&LimeExpr, &LimeExpr],
  and_ints: Tuple2[&LimeExpr, &LimeExpr],
  or_ints:  Tuple2[&LimeExpr, &LimeExpr],
  xor_ints: Tuple2[&LimeExpr, &LimeExpr],
  compare_ints: Tuple2[&LimeExpr, &LimeExpr],
  unbox: &LimeExpr,
  crash,
  generate_array: LimeGenerateArray,
  array_get: Tuple2[&LimeExpr, &LimeExpr],
  array_set: Tuple3[&LimeExpr, &LimeExpr, &LimeExpr],
  array_slice: Tuple3[&LimeExpr, &LimeExpr, &LimeExpr],
  array_len: &LimeExpr,

  loop_: LimeLoop,
  continue_: Slice[LimeExpr],

  unreachable,
}
struct LimeEnum { name: String, value: &LimeExpr }
struct LimeLambda { signature: String, closure: &LimeExpr }
struct LimeMember { of: &LimeExpr, name: String }
struct LimeSwitch { condition: &LimeExpr, cases: Map[String, LimeCase] }
struct LimeCase { payload: Hole, body: LimeExpr }
struct LimeCallFun { fun_: String, args: Slice[LimeExpr] }
struct LimeCallLambda { lambda: &LimeExpr, args: Slice[LimeExpr] }
struct LimeBody { inner: Slice[Tuple2[Hole, LimeExpr]], returns: &LimeExpr }
struct LimeGenerateArray { length: &LimeExpr, index: Hole, generate: &LimeExpr }
struct LimeLoop {
  holes: Slice[Hole], initial: Slice[LimeExpr], body: &LimeExpr
}


fun write[W](writer: W, lime: Lime) {
  var first = true
  for fun_ in lime.funs do {
    if first then first = false else writer."\n"
    writer.write(fun_.key, fun_.value)
  }
}
fun write[W](writer: W, signature: String, fun_: LimeFun) {
  var namespace = holes_namespace().&
  writer."{pretty_signature_def(signature)}"
  for param in fun_.params do writer." {format(param, namespace)}"
  writer." =\n"
  writer.write(fun_.body, namespace, indentation(1))
}
fun write[W](
  writer: W, expr: LimeExpr,
  namespace: &HolesNamespace, indentation: Indentation,
) {
  writer."{indentation}"
  var type = expr.type
  switch expr.op
  case hole(hole) writer."{pretty_op("hole")} {format(hole, namespace)}  {pretty(type)}"
  case type(type_) writer."{pretty_op("type")} {type_}  {pretty(type)}"
  case byte(byte) writer."{pretty_op("byte")} {byte}  {pretty(type)}"
  case int(int) writer."{pretty_op("int")} {int}  {pretty(type)}"
  case array(array) {
    writer."{pretty_op("array")}  {pretty(type)}"
    for item in array do {
      writer."\n"
      writer.write(item, namespace, indentation + 1)
    }
  }
  case struct_(struct_) {
    writer."{pretty_op("&")}  {pretty(type)}"
    for field in struct_ do {
      writer."\n{indentation + 1}{field.key}:\n"
      writer.write(field.value, namespace, indentation + 2)
    }
  }
  case enum_(enum_) {
    writer."{pretty_op("|")} {enum_.name}:  {pretty(type)}\n"
    writer.write(enum_.value.*, namespace, indentation + 1)
  }
  case lambda(lambda) {
    writer."{pretty_op("lambda")} {pretty_signature(lambda.signature)}  {pretty(type)}\n"
    writer.write(lambda.closure.*, namespace, indentation + 1)
  }
  case box(inner) {
    writer."{pretty_op("box")}  {pretty(type)}\n"
    writer.write(inner.*, namespace, indentation + 1)
  }
  case member(member) {
    writer."{pretty_op("member")} {member.name}  {pretty(type)}\n"
    writer.write(member.of.*, namespace, indentation + 1)
  }
  case switch_(switch_) {
    writer."{pretty_op("switch")}  {pretty(type)}\n"
    writer.write(switch_.condition.*, namespace, indentation + 1)
    for case_ in switch_.cases do {
      writer."
        '\n{indentation + 1}{case_.key}
        ' {format(case_.value.payload, namespace)}:\n"
      writer.write(case_.value.body, namespace, indentation + 2)
    }
  }
  case call_fun(fun_) {
    writer."{pretty_op("call")} {pretty_signature(fun_.fun_)}  {pretty(type)}"
    for arg in fun_.args do {
      writer."\n"
      writer.write(arg, namespace, indentation + 1)
    }
  }
  case call_lambda(call) {
    writer."{pretty_op("call lambda")}  {pretty(type)}\n"
    writer.write(call.lambda.*, namespace, indentation + 1)
    for arg in call.args do {
      writer."\n"
      writer.write(arg, namespace, indentation + 1)
    }
  }
  case body(body) {
    writer."{pretty_op("body")}"
    for inner in body.inner do {
      writer."\n{indentation + 1}{format(inner.a, namespace)} =\n"
      writer.write(inner.b, namespace, indentation + 2)
    }
    writer."\n"
    writer.write(body.returns.*, namespace, indentation + 1)
  }
  case lower_byte(int) {
    writer."{pretty_op("lower byte")}  {pretty(type)}\n"
    writer.write(int.*, namespace, indentation + 1)
  }
  case byte_to_int(byte) {
    writer."{pretty_op("byte to int")}  {pretty(type)}\n"
    writer.write(byte.*, namespace, indentation + 1)
  }
  case add_ints(args) {
    writer."{pretty_op("add")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case sub_ints(args) {
    writer."{pretty_op("subtract")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case mul_ints(args) {
    writer."{pretty_op("multiply")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case div_ints(args) {
    writer."{pretty_op("divide")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case mod_ints(args) {
    writer."{pretty_op("modulo")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case and_ints(args) {
    writer."{pretty_op("bitwise and")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case or_ints(args) {
    writer."{pretty_op("bitwise or")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case xor_ints(args) {
    writer."{pretty_op("bitwise xor")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case compare_ints(args) {
    writer."{pretty_op("compare")}  {pretty(type)}\n"
    writer.write(args.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(args.b.*, namespace, indentation + 1)
  }
  case unbox(box) {
    writer."{pretty_op("unbox")}  {pretty(type)}\n"
    writer.write(box.*, namespace, indentation + 1)
  }
  case generate_array(generate) {
    writer."{pretty_op("generate array")} {format(generate.index, namespace)}\n"
    writer.write(generate.length.*, namespace, indentation + 1)
    writer."\n"
    writer.write(generate.generate.*, namespace, indentation + 1)
  }
  case array_get(get) {
    writer."{pretty_op("get")}\n"
    writer.write(get.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(get.b.*, namespace, indentation + 1)
  }
  case array_set(set) {
    writer."{pretty_op("set")}\n"
    writer.write(set.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(set.b.*, namespace, indentation + 1)
    writer."\n"
    writer.write(set.c.*, namespace, indentation + 1)
  }
  case array_slice(slice) {
    writer."{pretty_op("slice")}\n"
    writer.write(slice.a.*, namespace, indentation + 1)
    writer."\n"
    writer.write(slice.b.*, namespace, indentation + 1)
    writer."\n"
    writer.write(slice.c.*, namespace, indentation + 1)
  }
  case array_len(array) {
    writer."{pretty_op("length")}  {pretty(type)}\n"
    writer.write(array.*, namespace, indentation + 1)
  }
  case crash writer."{pretty_op("crash")}"
  case unreachable writer."{pretty_op("unreachable")}"
  case loop_(loop_) {
    writer."{pretty_op("loop")}"
    for hole in loop_.holes do writer." {format(hole, namespace)}"
    writer."  {pretty(expr.type)}\n{indentation + 1}initial:"
    for arg in loop_.initial do {
      writer."\n"
      writer.write(arg, namespace, indentation + 2)
    }
    writer."\n{indentation + 1}body:\n"
    writer.write(loop_.body.*, namespace, indentation + 2)
  }
  case continue_(args) {
    writer."{pretty_op("continue")}"
    for arg in args do {
      writer."\n"
      writer.write(arg, namespace, indentation + 1)
    }
  }
}
