import mod.mar

fun desugar_casts(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  for fun_ in taco.funs do
    funs.&.put(fun_.key, fun_.value.map(DesugarCasts { funs = funs.& }))
  Taco { funs, entry_point = taco.entry_point }
}
struct DesugarCasts { funs: &Map[String, TacoBody] }
fun map(expr: TacoExpr, desugar: DesugarCasts): TacoExpr {
  var expr = expr.map_children(desugar)
  if expr.op is cast(inner) then
    return TacoCalledFun {
      signature = compile_cast_fun(inner.type, expr.type, desugar.funs),
      substitutions = no_substitutions,
    }.call(list(inner.*).to_slice(), expr.type)
  expr
}

fun compile_cast_fun(
  from: EggType, to: EggType, funs: &Map[String, TacoBody]
): String {
  var signature = "cast {from} to {to}"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[TacoBody]().*) | placeholder

  var value = hole(from)
  funs.put(signature, TacoBody {
    params = list(value).to_slice(),
    expr = {
      if from.internal_kind() is never then taco_unreachable(to)
      else if from == to then taco_hole(value) | This cast is the identity fun!
      else
        switch to.kind()
        case type unreachable()
        case byte unreachable()
        case int unreachable()
        case array(to_item_type) {
          var index = hole(type_int)
          generate_array(
            taco_hole(value).array_len(),
            body(
              index,
              taco_hole(value)
                .array_get(taco_hole(index))
                .cast(to_item_type)
                .map(DesugarCasts { funs }),
            ),
          )
        }
        case struct_(to_field_types)
          struct_({
            var to_fields = map[String, TacoExpr]()
            for field in to_field_types do
              to_fields.&.put(
                field.key,
                taco_hole(value)
                  .member(field.key)
                  .cast(field.value)
                  .map(DesugarCasts { funs }),
              )
            to_fields
          })
        case enum_(to_variant_types) {
          var from_variant_types = from.kind().enum_.unwrap()
          var cases = map[String, TacoBody]()
          for variant in from_variant_types do {
            var from_payload_type = variant.value
            var to_payload_type = to_variant_types.get(variant.key)
            var hole = hole(from_payload_type)
            cases.&.put(
              variant.key,
              body(
                hole,
                taco_hole(hole)
                  .cast(to_payload_type)
                  .map(DesugarCasts { funs }),
              ),
            )
          }
          switch_(taco_hole(value), to, cases)
        }
        case lambda(to_lambda_type) {
          var from_lambda_type = from.kind().lambda.unwrap()

          var outer_params = list[Hole]()
          for param in to_lambda_type.args do
            outer_params.&.push(hole(param))

          lambda(body(
            outer_params.to_slice(),
            taco_hole(value)
              .call({
                var inner_params = list[TacoExpr]()
                for param in outer_params.iter().enumerate() do
                  inner_params.&.push(
                    taco_hole(param.item)
                      .cast(from_lambda_type.args.get(param.index))
                      .map(DesugarCasts { funs })
                  )
                inner_params.to_slice()
              })
              .cast(to_lambda_type.return_type)
              .map(DesugarCasts { funs }),
          ))
        }
        default panic("casting {from} to {to} is not supported")
    }
  })
  signature
}
