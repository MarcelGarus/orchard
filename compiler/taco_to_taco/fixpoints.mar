| What the heck are fixpoints?  
| 
| Hi, future me! If you're confused (again): I want to optimize recursive
| functions, but inlining them naively results in compiler hangs. So, I
| introduced recursive expressions in the Taco: Expressions that can contain a
| recurse expression to "jump back out" and evaluate again. Consider this code:
| 
| sum iterator: (Iterator Int) -> Int =
|   iterator .fold 0 \ a: Int b: Int -> a .+ b
|
| fold iterator: (Iterator a) initial_state: s folder: (\ s a -> s) -> s =
|   iterator.next
|   % empty -> initial_state
|     more: (& item rest) -> rest .fold (folder initial_state item) folder
| 
| The sum function uses fold, but we want to create a specialized version of the
| fold function tailor-made to its usage in sum. Inline it! However, it's
| recursive and we don't want to inline it again and again and again. So, I
| create a recursive expression:
| 
| The Taco contains recursive expressions so that recursive functions can be
| inlined and analyzed and optimized within the concrete context they are used
| in. Take this recursive expression, which may be the result of summing up an
| (Iterator Int):
|
| sum a =
|   recursive b c d        (Int)
|     hole a               (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|     int 0                (Int)
|     lambda e f           (\ (Int) (Int) -> (Int))
|       add                (Int)
|         hole e           (Int)
|         hole f           (Int)
|     switch               (Int)
|       call lambda        (| empty: (&) more: (& item: (Int) rest: (\ -> (^3))))
|         hole b           (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|       empty m:
|         hole c           (Int)
|       more g:
|         recurse          (Int)
|           member rest    (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|             hole g       (& item: (Int) rest: (\ -> (| empty: (&) more: (^3))))
|           call lambda    (Int)
|             hole d       (\ (Int) (Int) -> (Int))
|             hole c       (Int)
|             member item  (Int)
|               hole g     (& item: (Int) rest: (\ -> (| empty: (&) more: (^3))))
|           hole d         (\ (Int) (Int) -> (Int))
| 
| This recursive expression varies over three holes (b, c, d), so it contains
| three initial values for these as well the body. The recurse expression then
| provides new values for those holes. You might notice that the third hole is
| always the lambda adding two numbers. That's a fixpoint!

import mod.mar

fun find_fixpoints(
  body: TacoExpr, params: Slice[Hole], args: Slice[TacoExpr],
  context: OptimizeTacoContext,
): Slice[TacoExpr] {
  eprintln("Finding fixpoints")
  var namespace = holes_namespace()
  | eprintln("Initial args:")
  | for arg in args do {
  |   stderr.write(arg, namespace.&, indentation(1))
  |   eprintln()
  | }

  var candidate = args
  loop {
    | eprintln("Analyzing recursions")
    var recurses =
      body.fill(params, candidate.unblacken())
        .optimize(context)
        .find_recurses()
    var new = candidate
    for recurse in recurses do {
      | eprintln("  Recursion:")
      | for arg in recurse.children do {
      |   stderr.write(arg, namespace.&, indentation(2))
      |   eprintln()
      | }
      for both in zip(new.iter(), recurse.children.iter()) do {
        eprintln("Unioning")
        stderr.write(both.a, namespace.&, indentation(1))
        eprintln()
        stderr.write(both.b, namespace.&, indentation(1))
        eprintln()
        stderr.write(union(both.a, both.b), namespace.&, indentation(1))
        eprintln()
      }
      new = union(new, recurse.children) | TODO: Make children self-contained
    }
    if new == candidate then break
    candidate = new
    | eprintln("New candidate:")
    | for arg in new do {
    |   stderr.write(arg, namespace.&, indentation(1))
    |   eprintln()
    | }
    | eprintln()
  }
  | eprintln("Fixpoints:")
  | for arg in candidate do {
  |   stderr.write(arg, namespace.&, indentation(1))
  |   eprintln()
  | }
  | eprintln()
  candidate
}

fun unblacken(exprs: Slice[TacoExpr]): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in exprs do new.&.push(old.unblacken())
  new.to_slice()
}
fun unblacken(expr: TacoExpr): TacoExpr {
  if expr.op is hole(hole) then if hole.is_black() then
    return taco_hole(hole(expr.type))
  expr(expr.op, expr.children.unblacken(), expr.type)
}

fun find_recurses(expr: TacoExpr): Slice[TacoExpr] {
  var recurses = list[TacoExpr]()
  expr.collect_recurses(recurses.&)
  recurses.to_slice()
}
fun collect_recurses(expr: TacoExpr, out: &List[TacoExpr]) {
  if expr.op is recurse then out.push(expr)
  if expr.op is recursive then
    for child in expr.children.without_last() do child.collect_recurses(out)
  else
    for child in expr.children do child.collect_recurses(out)
}

fun union(a: Slice[TacoExpr], b: Slice[TacoExpr]): Slice[TacoExpr] {
  var all = list[TacoExpr]()
  for both in zip(a.iter(), b.iter()) do all.&.push(union(both.a, both.b))
  all.to_slice()
}
fun union(a: TacoExpr, b: TacoExpr): TacoExpr {
  if a.op is hole(hole) then if hole.is_black() then return a
  if b.op is hole(hole) then if hole.is_black() then return b

  | if a.op is recursive then return union(a.wrap_around(), b)
  | if b.op is recursive then return union(a, b.wrap_around())

  if a.op is hole(a) then if b.op is hole(b) then
    if a == b then return taco_hole(a)
  if a.op is type(a) then if b.op is type(b) then
    if a == b then return taco_type(a)
  if a.op is int(a) then if b.op is int(b) then
    if a == b then return taco_int(a)
  if a.op is byte(a) then if b.op is byte(b) then
    if a == b then return taco_byte(a)
  if a.op is array then if b.op is array then
    if a.children.len == b.children.len then
      return array(a.type, union(a.children, b.children))
  if a.op is struct_ then if b.op is struct_ then
    return expr(TacoOp.struct_, union(a.children, b.children), a.type)
  if a.op is enum_(a_name) then if b.op is enum_(b_name) then
    if a_name == b_name then
      return enum_(
        a.type, a_name, union(a.children.get(0), b.children.get(0))
      )
  if a.op is lambda(a_holes) then if b.op is lambda(b_holes) then {
    var a_body = a.children.get(0)
    var b_body = b.children.get(0).fill({
      var fillings = map[Hole, TacoExpr]()
      for both in zip(a_holes.iter(), b_holes.iter()) do
        fillings.&.put(both.a, taco_hole(both.b))
      fillings
    })
    if a_body == b_body then return a
  }
  if a.op is box then if b.op is box then
    return box(union(a.children.get(0), b.children.get(0)))

  taco_hole(black_hole(a.type))
}

fun values_for_black_holes(
  exprs: Slice[TacoExpr], fixpoints: Slice[TacoExpr]
): Slice[TacoExpr] {
  var out = list[TacoExpr]()
  exprs.values_for_black_holes(fixpoints, out.&)
  out.to_slice()
}
fun values_for_black_holes(
  exprs: Slice[TacoExpr], fixpoints: Slice[TacoExpr], out: &List[TacoExpr]
) {
  for both in zip(exprs.iter(), fixpoints.iter()) do
    both.a.values_for_black_holes(both.b, out)
}
fun values_for_black_holes(
  expr: TacoExpr, fixpoint: TacoExpr, out: &List[TacoExpr]
) {
  if fixpoint.op is hole(hole) then if hole.is_black() then
    return out.&.push(expr)
  expr.children.values_for_black_holes(fixpoint.children, out)
}

fun fill_black_holes(
  fixpoints: Slice[TacoExpr], fillings: Slice[Hole]
): Slice[TacoExpr] {
  fixpoints.fill_black_holes(fillings.iter().&)
}
fun fill_black_holes[I](
  fixpoints: Slice[TacoExpr], fillings: &Iter[Hole, I]
): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in fixpoints do new.&.push(old.fill_black_holes(fillings))
  new.to_slice()
}
fun fill_black_holes[I](
  fixpoint: TacoExpr, fillings: &Iter[Hole, I]
): TacoExpr {
  if fixpoint.op is hole(hole) then if hole.is_black() then
    return taco_hole(fillings.next().unwrap())
  expr(fixpoint.op, fixpoint.children.fill_black_holes(fillings), fixpoint.type)
}

fun replace_recurses(expr: TacoExpr, fixpoints: Slice[TacoExpr]): TacoExpr {
  if expr.op is recurse then
    return recurse(expr.children.values_for_black_holes(fixpoints), expr.type)
  if expr.op is recursive then {
    var args = expr.children.without_last()
    var body = expr.children.last()
    var children = list[TacoExpr]()
    for arg in args do children.&.push(arg.replace_recurses(fixpoints))
    children.&.push(body)
    expr(expr.op, children.to_slice(), expr.type)
  } else
    expr(expr.op, expr.children.replace_recurses(fixpoints), expr.type)
}
fun replace_recurses(
  exprs: Slice[TacoExpr], fixpoints: Slice[TacoExpr]
): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in exprs do new.&.push(old.replace_recurses(fixpoints))
  new.to_slice()
}

fun wrap_around(expr: TacoExpr): TacoExpr {
  if not(expr.op is recursive) then panic("can only wrap recursives")
  var holes = expr.op.recursive.unwrap()
  var args = expr.children.without_last()
  var body = expr.children.last()
  body.fill(holes, args).replace_recurses(holes, body)
}
fun replace_recurses(expr: TacoExpr, holes: Slice[Hole], body: TacoExpr): TacoExpr {
  if expr.op is recurse then
    return recursive(holes, expr.children, body) | TODO: what if an arg recurses?
  var children = list[TacoExpr]()
  for child in expr.children do children.&.push(child.replace_recurses(holes, body))
  expr(expr.op, children.to_slice(), expr.type)
}
