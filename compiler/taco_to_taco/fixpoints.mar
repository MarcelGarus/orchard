| What the heck are fixpoints?  
| 
| Hi, future me! If you're confused (again): I want to optimize recursive
| functions, but inlining them naively results in compiler hangs. So, I
| introduced recursive expressions in the Taco: Expressions that can contain a
| recurse expression to "jump back out" and evaluate again. Consider this code:
| 
| sum iterator: (Iterator Int) -> Int =
|   iterator .fold 0 \ a: Int b: Int -> a .+ b
|
| fold iterator: (Iterator a) initial_state: s folder: (\ s a -> s) -> s =
|   iterator.next
|   % empty -> initial_state
|     more: (& item rest) -> rest .fold (folder initial_state item) folder
| 
| The sum function uses fold, but we want to create a specialized version of the
| fold function tailor-made to its usage in sum. Inline it! However, it's
| recursive and we don't want to inline it again and again and again. So, I
| create a recursive expression:
| 
| The Taco contains recursive expressions so that recursive functions can be
| inlined and analyzed and optimized within the concrete context they are used
| in. Take this recursive expression, which may be the result of summing up an
| (Iterator Int):
|
| sum a =
|   recursive b c d        (Int)
|     hole a               (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|     int 0                (Int)
|     lambda e f           (\ (Int) (Int) -> (Int))
|       add                (Int)
|         hole e           (Int)
|         hole f           (Int)
|     switch               (Int)
|       call lambda        (| empty: (&) more: (& item: (Int) rest: (\ -> (^3))))
|         hole b           (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|       empty m:
|         hole c           (Int)
|       more g:
|         recurse          (Int)
|           member rest    (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|             hole g       (& item: (Int) rest: (\ -> (| empty: (&) more: (^3))))
|           call lambda    (Int)
|             hole d       (\ (Int) (Int) -> (Int))
|             hole c       (Int)
|             member item  (Int)
|               hole g     (& item: (Int) rest: (\ -> (| empty: (&) more: (^3))))
|           hole d         (\ (Int) (Int) -> (Int))
| 
| This recursive expression varies over three holes (b, c, d), so it contains
| three initial values for these as well the body. The recurse expression then
| provides new values for those holes. You might notice that the third hole is
| always the lambda adding two numbers. That's a fixpoint!

import mod.mar

fun find_fixpoints(
  body: TacoExpr, params: Slice[Hole], args: Slice[TacoExpr],
  context: OptimizeTacoContext,
): Slice[TacoExpr] {
  | eprintln("Finding fixpoints")
  | var namespace = holes_namespace()
  | eprintln("Initial args:")
  | for arg in args do {
  |   stderr.write(arg, namespace.&, indentation(1))
  |   eprintln()
  | }
  | eprintln("Body:")
  | stderr.write(body, namespace.&, indentation(1))
  | eprintln()

  var candidate = args
  loop {
    | eprintln("Analyzing recursions")
    var recurses =
      body.fill(params, candidate.unblacken())
        .optimize(context)
        .find_recurses()
    var new = candidate
    for recurse in recurses do {
      | eprintln("  Recursion:")
      | for arg in recurse.children do {
      |   stderr.write(arg, namespace.&, indentation(2))
      |   eprintln()
      | }

      | for both in zip(new.iter(), recurse.children.iter()) do {
      |   eprintln("Unioning")
      |   stderr.write(both.a, namespace.&, indentation(1))
      |   eprintln()
      |   stderr.write(both.b, namespace.&, indentation(1))
      |   eprintln()
      |   stderr.write(union(both.a, both.b), namespace.&, indentation(1))
      |   eprintln()
      | }
      new = union(new, recurse.children) | TODO: Make children self-contained?
    }
    if new == candidate then break
    candidate = new
    | eprintln("New candidate:")
    | for arg in new do {
    |   stderr.write(arg, namespace.&, indentation(1))
    |   eprintln()
    | }
    | eprintln()
  }
  | eprintln("Fixpoints:")
  | for arg in candidate do {
  |   stderr.write(arg, namespace.&, indentation(1))
  |   eprintln()
  | }
  | eprintln()
  candidate
}

fun unblacken(exprs: Slice[TacoExpr]): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in exprs do new.&.push(old.unblacken())
  new.to_slice()
}
fun unblacken(expr: TacoExpr): TacoExpr {
  if expr.op is hole(hole) then if hole.is_black() then
    return taco_hole(hole(expr.type))
  expr(expr.op, expr.children.unblacken(), expr.type)
}

fun find_recurses(expr: TacoExpr): Slice[TacoExpr] {
  var recurses = list[TacoExpr]()
  expr.collect_recurses(recurses.&)
  recurses.to_slice()
}
fun collect_recurses(expr: TacoExpr, out: &List[TacoExpr]) {
  if expr.op is recurse then out.push(expr)
  if expr.op is recursive then
    for child in expr.children.without_last() do child.collect_recurses(out)
  else
    for child in expr.children do child.collect_recurses(out)
}

fun union(a: Slice[TacoExpr], b: Slice[TacoExpr]): Slice[TacoExpr] {
  var all = list[TacoExpr]()
  for both in zip(a.iter(), b.iter()) do all.&.push(union(both.a, both.b))
  all.to_slice()
}
fun union(a: TacoExpr, b: TacoExpr): TacoExpr {
  if a == b then return a

  if a.op is hole(hole) then if hole.is_black() then return a
  if b.op is hole(hole) then if hole.is_black() then return b

  | if a.op is recursive then return union(a.wrap_around(), b)
  | if b.op is recursive then return union(a, b.wrap_around())

  if a.op is hole(a) then if b.op is hole(b) then
    if a == b then return taco_hole(a)
  if a.op is type(a) then if b.op is type(b) then
    if a == b then return taco_type(a)
  if a.op is byte(a) then if b.op is byte(b) then
    if a == b then return taco_byte(a)
  if a.op is int(a) then if b.op is int(b) then
    if a == b then return taco_int(a)
  if a.op is array then if b.op is array then
    if a.children.len == b.children.len then
      return array(a.type, union(a.children, b.children))
  if a.op is struct_ then if b.op is struct_ then
    return expr(TacoOp.struct_, union(a.children, b.children), a.type)
  if a.op is enum_(a_name) then if b.op is enum_(b_name) then
    if a_name == b_name then
      return enum_(
        a.type, a_name, union(a.children.get(0), b.children.get(0))
      )
  if a.op is lambda(a_holes) then if b.op is lambda(b_holes) then {
    var a_body = a.children.get(0)
    var b_body = b.children.get(0).fill({
      var fillings = map[Hole, TacoExpr]()
      for both in zip(a_holes.iter(), b_holes.iter()) do
        fillings.&.put(both.a, taco_hole(both.b))
      fillings
    })
    if a_body == b_body then return a
  }
  if a.op is box then if b.op is box then
    return box(union(a.children.get(0), b.children.get(0)))

  taco_hole(black_hole(a.type))
}

| | Simplifies the expression given that we know that it doesn't crash.
| fun not_crashing(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
|   var children = list[TacoExpr]()
|   for child in expr.children do children.&.push(child.not_crashing(context))
|   var children = children.to_slice()

|   switch expr.op
|   case switch_(holes) {
|     var condition = children.first()
|     var cases = children.without_first()
|     var new_holes = list[Hole]()
|     var new_cases = list[TacoExpr]()
|     for both in zip(holes.iter(), cases.iter()) do
|       if not(both.b.definitely_crashes()) then {
|         new_holes.&.push(both.a)
|         new_cases.&.push(both.b.not_crashing(context))
|       }
|     if new_cases.len == 0 then return taco_crash(expr.type)
|     if new_cases.len == 1 then
|       return new_cases.get(0)
|         .fill(map(new_holes.get(0) -> condition))
|         .optimize(context)
|         .not_crashing(context)
|     return expr(
|       TacoOp.switch_(new_holes.to_slice()),
|       (list(condition) + new_cases).to_slice(),
|       expr.type
|     )
|   }
|   case body return expr.children.last().not_crashing(context)
|   default {}

|   expr(expr.op, children, expr.type)
| }

fun values_for_black_holes(
  exprs: Slice[TacoExpr], fixpoints: Slice[TacoExpr]
): Slice[TacoExpr] {
  | eprintln("values for black holes")
  | for expr in exprs do {
  |   stderr.write(expr, holes_namespace().&, indentation(1))
  |   eprintln()
  | }
  var out = list[TacoExpr]()
  for both in zip(exprs.iter(), fixpoints.iter()) do
    both.a.values_for_black_holes(both.b, out.&)
  out.to_slice()

  | eprintln("values for black holes")
  | for expr in out do {
  |   stderr.write(expr, holes_namespace().&, indentation(1))
  |   eprintln()
  | }
  out.to_slice()
}
fun values_for_black_holes(
  expr: TacoExpr, fixpoint: TacoExpr, out: &List[TacoExpr]
) {
  switch fixpoint.op
  case hole(hole)
    if hole.is_black() then return out.push(expr)
  case type {}
  case byte {}
  case int {}
  case array {
    for item in fixpoint.children.iter().enumerate() do
      values_for_black_holes(
        expr.array_get(taco_int(item.index)), item.item, out
      )
  }
  case struct_ {
    var keys = list[String]()
    for field in fixpoint.type.kind().struct_.unwrap() do keys.&.push(field.key)
    keys.to_slice().&.sort()

    for key in keys.iter().enumerate() do
      values_for_black_holes(
        expr.member(key.item), fixpoint.children.get(key.index), out
      )
  }
  case enum_(name) {
    var variant_types = fixpoint.type.kind().enum_.unwrap()
    var target_type = variant_types.get(name)

    var keys = list[String]()
    for variant in variant_types do keys.&.push(variant.key)
    keys.to_slice().&.sort()

    var cases = map[String, Tuple2[Hole, TacoExpr]]()
    for variant in variant_types do {
      var hole = hole(variant.value)
      cases.&.put(
        variant.key,
        tuple(
          hole,
          if variant.key == name
          then taco_hole(hole)
          else taco_unreachable(target_type),
        ),
      )
    }

    values_for_black_holes(
      switch_(expr, target_type, cases), fixpoint.children.get(0), out
    )
  }
  case lambda {}
  case box values_for_black_holes(unbox(expr), fixpoint.children.get(0), out)
  default
    if fixpoint.contains_black_hole() then
      panic("Unknown fixpoint {fixpoint.debug()}")

  | if fixpoint.op is hole(hole) then if hole.is_black() then
  |   return out.&.push(expr)
  | expr.children.values_for_black_holes(fixpoint.children, out)
}
fun contains_black_hole(expr: TacoExpr): Bool {
  if expr.op is hole(hole) then if hole.is_black() then return true
  for child in expr.children do if child.contains_black_hole() then return true
  false
}

fun fill_black_holes(
  fixpoints: Slice[TacoExpr], fillings: Slice[Hole]
): Slice[TacoExpr] {
  fixpoints.fill_black_holes(fillings.iter().&)
}
fun fill_black_holes[I](
  fixpoints: Slice[TacoExpr], fillings: &Iter[Hole, I]
): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in fixpoints do new.&.push(old.fill_black_holes(fillings))
  new.to_slice()
}
fun fill_black_holes[I](
  fixpoint: TacoExpr, fillings: &Iter[Hole, I]
): TacoExpr {
  if fixpoint.op is hole(hole) then if hole.is_black() then
    return taco_hole(fillings.next().unwrap())
  expr(fixpoint.op, fixpoint.children.fill_black_holes(fillings), fixpoint.type)
}

fun replace_recurses(expr: TacoExpr, fixpoints: Slice[TacoExpr]): TacoExpr {
  if expr.op is recurse then
    return recurse(expr.children.values_for_black_holes(fixpoints), expr.type)
  if expr.op is recursive then {
    var args = expr.children.without_last()
    var body = expr.children.last()
    var children = list[TacoExpr]()
    for arg in args do children.&.push(arg.replace_recurses(fixpoints))
    children.&.push(body)
    expr(expr.op, children.to_slice(), expr.type)
  } else
    expr(expr.op, expr.children.replace_recurses(fixpoints), expr.type)
}
fun replace_recurses(
  exprs: Slice[TacoExpr], fixpoints: Slice[TacoExpr]
): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in exprs do new.&.push(old.replace_recurses(fixpoints))
  new.to_slice()
}

fun wrap_around(expr: TacoExpr): TacoExpr {
  if not(expr.op is recursive) then panic("can only wrap recursives")
  var holes = expr.op.recursive.unwrap()
  var args = expr.children.without_last()
  var body = expr.children.last()
  body.fill(holes, args).wrap_rec(holes, body)
}
fun wrap_rec(expr: TacoExpr, holes: Slice[Hole], body: TacoExpr): TacoExpr {
  if expr.op is recurse then
    return recursive(holes, expr.children, body) | TODO: what if an arg recurses?
  var children = list[TacoExpr]()
  for child in expr.children do children.&.push(child.wrap_rec(holes, body))
  expr(expr.op, children.to_slice(), expr.type)
}
