| What the heck are fixpoints?  
| 
| Hi, future me! If you're confused (again): I want to optimize recursive
| functions, but inlining them naively results in compiler hangs. So, I
| introduced recursive expressions in the Taco: Expressions that can contain a
| recurse expression to "jump back out" and evaluate again. Consider this code:
| 
| sum iterator: (Iterator Int) -> Int =
|   iterator .fold 0 \ a: Int b: Int -> a .+ b
|
| fold iterator: (Iterator a) initial_state: s folder: (\ s a -> s) -> s =
|   iterator.next
|   % empty -> initial_state
|     more: (& item rest) -> rest .fold (folder initial_state item) folder
| 
| The sum function uses fold, but we want to create a specialized version of the
| fold function tailor-made to its usage in sum. Inline it! However, it's
| recursive and we don't want to inline it again and again and again. So, I
| create a recursive expression:
| 
| The Taco contains recursive expressions so that recursive functions can be
| inlined and analyzed and optimized within the concrete context they are used
| in. Take this recursive expression, which may be the result of summing up an
| (Iterator Int):
|
| sum a =
|   recursive                (Int)
|     initial:
|       hole a               (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|       int 0                (Int)
|       lambda b c           (\ (Int) (Int) -> (Int))
|         add                (Int)
|           hole b           (Int)
|           hole c           (Int)
|     body d e f:
|       switch               (Int)
|         call lambda        (| empty: (&) more: (& item: (Int) rest: (\ -> (^3))))
|           hole d           (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|         empty m:
|           hole e           (Int)
|         more g:
|           recurse          (Int)
|             member rest    (\ -> (| empty: (&) more: (& item: (Int) rest: (^3))))
|               hole g       (& item: (Int) rest: (\ -> (| empty: (&) more: (^3))))
|             call lambda    (Int)
|               hole f       (\ (Int) (Int) -> (Int))
|               hole e       (Int)
|               member item  (Int)
|                 hole g     (& item: (Int) rest: (\ -> (| empty: (&) more: (^3))))
|             hole f         (\ (Int) (Int) -> (Int))
|
| This recursive expression varies over three holes (d, e, f), so it contains
| three initial values for these as well the body. The recurse expression then
| provides new values for those holes. You might notice that the third hole is
| always the lambda adding two numbers. That's a fixpoint!

import mod.mar

struct FixpointMask {
  | This is a mask of the compile-time known structure of the recursive args.
  | The parts only known at runtime are black holes.
  args: Slice[TacoExpr],
}

fun find_fixpoint_mask(
  body: TacoBody, args: Slice[TacoExpr], context: OptimizeTacoContext
): FixpointMask {
  eprintln("Finding fixpoints")
  | var namespace = holes_namespace()
  | eprintln("Initial args:")
  | for arg in args do {
  |   stderr.write(arg, namespace.&, indentation(1))
  |   eprintln()
  | }
  | eprintln("Body:")
  | stderr.write(body, namespace.&, indentation(1))
  | eprintln()

  var candidate = args
  loop {
    | eprintln("Analyzing recursions")
    var recurse_args =
      body.fill(candidate.unblacken()).optimize(context).find_recurse_args()
    var new = candidate
    for args in recurse_args do {
      | eprintln("  Recursion:")
      | for arg in recurse.children do {
      |   stderr.write(arg, namespace.&, indentation(2))
      |   eprintln()
      | }

      for both in zip(new.iter(), args.iter()) do {
        eprintln("Unioning")
        var namespace = holes_namespace()
        stderr.write(both.a, namespace.&, indentation(1))
        eprintln()
        stderr.write(both.b, namespace.&, indentation(1))
        eprintln()
        stderr.write(union(both.a, both.b), namespace.&, indentation(1))
        eprintln()
      }
      new = union(new, args) | TODO: Make children self-contained?
    }
    if new == candidate then break
    candidate = new
    | eprintln("New candidate:")
    | for arg in new do {
    |   stderr.write(arg, namespace.&, indentation(1))
    |   eprintln()
    | }
    | eprintln()
  }
  | eprintln("Fixpoints:")
  | for arg in candidate do {
  |   stderr.write(arg, namespace.&, indentation(1))
  |   eprintln()
  | }
  | eprintln()
  FixpointMask { args = candidate }
}

fun unblacken(exprs: Slice[TacoExpr]): Slice[TacoExpr] {
  var new = list[TacoExpr]()
  for old in exprs do new.&.push(old.map(Unblacken {}))
  new.to_slice()
}
struct Unblacken {}
fun map(expr: TacoExpr, unblacken: Unblacken): TacoExpr {
  if expr.op is hole(hole) then if hole.is_black() then
    return taco_hole(hole(expr.type))
  expr.map_children(unblacken)
}
fun map(body: TacoBody, unblacken: Unblacken): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(unblacken) }
}

fun find_recurse_args(expr: TacoExpr): Slice[Slice[TacoExpr]] {
  var recurses = list[Slice[TacoExpr]]()
  expr.visit(CollectRecurses { out = recurses.& })
  recurses.to_slice()
}
struct CollectRecurses { out: &List[Slice[TacoExpr]] }
fun visit(expr: TacoExpr, collect_recurses: CollectRecurses) {
  if expr.op is recurse(args) then collect_recurses.out.push(args)
  if expr.op is recursive(rec) then
    for arg in rec.a do arg.visit(collect_recurses)
  else
    expr.visit_children(collect_recurses)
}
fun visit(body: TacoBody, collect_recurses: CollectRecurses) {
  body.expr.visit(collect_recurses)
}

fun union(a: Slice[TacoExpr], b: Slice[TacoExpr]): Slice[TacoExpr] {
  var all = list[TacoExpr]()
  for both in zip(a.iter(), b.iter()) do all.&.push(union(both.a, both.b))
  all.to_slice()
}
fun union(a: TacoExpr, b: TacoExpr): TacoExpr {
  if a == b then return a

  if a.op is hole(hole) then if hole.is_black() then return a
  if b.op is hole(hole) then if hole.is_black() then return b

  | if a.op is recursive then return union(a.wrap_around(), b)
  | if b.op is recursive then return union(a, b.wrap_around())

  switch a.op
  case hole(a) if b.op is hole(b) then if a == b then return taco_hole(a)
  case type(a) if b.op is type(b) then if a == b then return taco_type(a)
  case byte(a) if b.op is byte(b) then if a == b then return taco_byte(a)
  case int(a) if b.op is int(b) then if a == b then return taco_int(a)
  case array(a_items) {
    switch b.op
    case array(b_items)
      if a_items.len == b_items.len then
        return array(a.type, union(a_items, b_items))
    case array_slice(b_args)
      if a == b_args.a.* then
        return array_slice(
          a,
          union(taco_int(0), b_args.b.*),
          union(taco_int(a_items.len), b_args.c.*),
        )
    default {}
  }
  case array_slice(a_args) {
    switch b.op
    case array(b_items)
      if a_args.a.* == b then
        return array_slice(
          b,
          union(a_args.b.*, taco_int(0)),
          union(a_args.c.*, taco_int(b_items.len)),
        )
    case array_slice(b_args)
      if a_args.a.* == b_args.a.* then
        return array_slice(
          a_args.a.*,
          union(a_args.b.*, b_args.b.*),
          union(a_args.c.*, b_args.c.*),
        )
    default {}
  }
  case struct_(a_fields)
    if b.op is struct_(b_fields) then {
      var fields = map[String, TacoExpr]()
      for field in a_fields do
        fields.&.put(field.key, union(field.value, b_fields.get(field.key)))
      return expr(TacoOp.struct_(fields), a.type)
    }
  case enum_(a_enum)
    if b.op is enum_(b_enum) then
      if a_enum.variant == b_enum.variant then
        return enum_(
          a.type, a_enum.variant, union(a_enum.payload.*, b_enum.payload.*)
        )
  case lambda(a_body)
    if b.op is lambda(b_body) then {
      var b_body = TacoBody {
        params = a_body.params,
        expr = b_body.fill({
          var fillings = list[TacoExpr]()
          for param in a_body.params do fillings.&.push(taco_hole(param))
          fillings.to_slice()
        })
      }
      if a_body.* == b_body then return a
    }
  case box(a_inner)
    if b.op is box(b_inner) then return box(union(a_inner.*, b_inner.*))
  default {}

  taco_hole(black_hole(a.type))
}

| | Simplifies the expression given that we know that it doesn't crash.
| fun not_crashing(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
|   var children = list[TacoExpr]()
|   for child in expr.children do children.&.push(child.not_crashing(context))
|   var children = children.to_slice()

|   switch expr.op
|   case switch_(holes) {
|     var condition = children.first()
|     var cases = children.without_first()
|     var new_holes = list[Hole]()
|     var new_cases = list[TacoExpr]()
|     for both in zip(holes.iter(), cases.iter()) do
|       if not(both.b.definitely_crashes()) then {
|         new_holes.&.push(both.a)
|         new_cases.&.push(both.b.not_crashing(context))
|       }
|     if new_cases.len == 0 then return taco_crash(expr.type)
|     if new_cases.len == 1 then
|       return new_cases.get(0)
|         .fill(map(new_holes.get(0) -> condition))
|         .optimize(context)
|         .not_crashing(context)
|     return expr(
|       TacoOp.switch_(new_holes.to_slice()),
|       (list(condition) + new_cases).to_slice(),
|       expr.type
|     )
|   }
|   case body return expr.children.last().not_crashing(context)
|   default {}

|   expr(expr.op, children, expr.type)
| }

fun mask(exprs: Slice[TacoExpr], mask: FixpointMask): Slice[TacoExpr] {
  | eprintln("mask")
  | for expr in exprs do {
  |   stderr.write(expr, holes_namespace().&, indentation(1))
  |   eprintln()
  | }
  exprs.mask(mask.args)
  | eprintln("mask")
  | for expr in out do {
  |   stderr.write(expr, holes_namespace().&, indentation(1))
  |   eprintln()
  | }
}
fun mask(exprs: Slice[TacoExpr], mask: Slice[TacoExpr]): Slice[TacoExpr] {
  var out = list[TacoExpr]()
  for both in zip(exprs.iter(), mask.iter()) do both.a.mask(both.b, out.&)
  out.to_slice()
}
fun mask(expr: TacoExpr, mask: TacoExpr, out: &List[TacoExpr]) {
  switch mask.op
  case hole(hole) if hole.is_black() then return out.push(expr)
  case type {}
  case byte {}
  case int {}
  case array(items) {
    for item in items.iter().enumerate() do
      mask(expr.array_get(taco_int(item.index)), item.item, out)
  }
  case array_slice(args) {
    | We know that the mask and actual expression refer to the same array.
    switch expr.op
    case array {
      out.push(taco_int(0))
      out.push(array_len(expr))
    }
    case array_slice(actual_args) {
      if actual_args.a.* != args.a.* then {
        var namespace = holes_namespace()
        stderr."Incompatible mask:\n"
        stderr.write(mask, namespace.&, indentation(1))
        stderr."\n"
        stderr.write(expr, namespace.&, indentation(1))
        panic("meh")
      }
      mask(actual_args.b.*, args.b.*, out)
      mask(actual_args.c.*, args.c.*, out)
    }
    default unreachable()
  }
  case struct_(fields) {
    for field in mask.type.kind().struct_.unwrap() do
      mask(expr.member(field.key), fields.get(field.key), out)
  }
  case enum_(enum_) {
    var variant_types = mask.type.kind().enum_.unwrap()
    var target_type = variant_types.get(enum_.variant)

    var cases = map[String, TacoBody]()
    for variant in variant_types do {
      var hole = hole(variant.value)
      cases.&.put(
        variant.key,
        body(
          hole,
          if variant.key == enum_.variant
          then taco_hole(hole)
          else taco_unreachable(target_type),
        ),
      )
    }

    mask(switch_(expr, target_type, cases), enum_.payload.*, out)
  }
  case lambda {}
  case box(inner) mask(unbox(expr), inner.*, out)
  default
    if mask.contains_black_hole() then
      panic("Unknown fixpoint mask {mask.debug()}")
}

fun contains_black_hole(expr: TacoExpr): Bool {
  var result = false
  expr.visit(ContainsBlackHole { out = result.& })
  result
}
struct ContainsBlackHole { out: &Bool }
fun visit(expr: TacoExpr, contains_black_hole: ContainsBlackHole) {
  if expr.op is hole(hole) then if hole.is_black() then
    contains_black_hole.out.* = true
  expr.visit_children(contains_black_hole)
}
fun visit(body: TacoBody, contains_black_hole: ContainsBlackHole) {
  body.expr.visit(contains_black_hole)
}


fun unmask(exprs: Slice[Hole], mask: FixpointMask): Slice[TacoExpr] {
  mask.args.map(FillBlackHoles { fillings = exprs.iter().& })
}
struct FillBlackHoles[I] { fillings: &Iter[Hole, I] }
fun map[I](expr: TacoExpr, fill_black_holes: FillBlackHoles[I]): TacoExpr {
  if expr.op is hole(hole) then if hole.is_black() then
    return taco_hole(fill_black_holes.fillings.next().unwrap())
  expr.map_children(fill_black_holes)
}
fun map[I](body: TacoBody, fill_black_holes: FillBlackHoles[I]): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(fill_black_holes) }
}

fun replace_recurses(expr: TacoExpr, mask: FixpointMask): TacoExpr {
  expr.map(ReplaceRecurses { mask })
}
struct ReplaceRecurses { mask: FixpointMask }
fun map(expr: TacoExpr, replace_recurses: ReplaceRecurses): TacoExpr {
  switch expr.op
  case recursive(rec) recursive(rec.a.map(replace_recurses), rec.b.*)
  case recurse(args) recurse(args.mask(replace_recurses.mask), expr.type)
  default expr.map_children(replace_recurses)
}
fun map(body: TacoBody, replace_recurses: ReplaceRecurses): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(replace_recurses) }
}

| fun wrap_around(expr: TacoExpr): TacoExpr {
|   if not(expr.op is recursive) then panic("can only wrap recursives")
|   var holes = expr.op.recursive.unwrap()
|   var args = expr.children.without_last()
|   var body = expr.children.last()
|   body.fill(holes, args).wrap_rec(holes, body)
| }
| fun wrap_rec(expr: TacoExpr, holes: Slice[Hole], body: TacoExpr): TacoExpr {
|   if expr.op is recurse then
|     return recursive(holes, expr.children, body) | TODO: what if an arg recurses?
|   var children = list[TacoExpr]()
|   for child in expr.children do children.&.push(child.wrap_rec(holes, body))
|   expr(expr.op, children.to_slice(), expr.type)
| }
