import mod.mar

fun new_holes(expr: TacoExpr): TacoExpr {
  expr.new_holes(map[Hole, Hole]().&)
}
fun new_holes(expr: TacoExpr, mapping: &Map[Hole, Hole]): TacoExpr {
  | Create new hole identities for the holes that expressions introduce.
  var new_op =
    switch expr.op
    case hole(old)
      if mapping.get_maybe(old) is some(new) then
        some(TacoOp.hole(new))
      else
        none[TacoOp]()
    case type none[TacoOp]()
    case byte none[TacoOp]()
    case int none[TacoOp]()
    case array none[TacoOp]()
    case struct_ none[TacoOp]()
    case enum_ none[TacoOp]()
    case lambda(params) {
      var new_params = list[Hole]()
      for old in params do {
        var new = hole(old.type)
        mapping.&.put(old, new)
        new_params.&.push(new)
      }
      some(TacoOp.lambda(new_params.to_slice()))
    }
    case box none[TacoOp]()
    case member none[TacoOp]()
    case switch_(holes) {
      var new_holes = list[Hole]()
      for old in holes do {
        var new = hole(old.type)
        mapping.&.put(old, new)
        new_holes.&.push(new)
      }
      some(TacoOp.switch_(new_holes.to_slice()))
    }
    case call_fun none[TacoOp]()
    case call_lambda none[TacoOp]()
    case body none[TacoOp]()
    case cast none[TacoOp]()
    case lower_byte none[TacoOp]()
    case byte_to_int none[TacoOp]()
    case add_ints none[TacoOp]()
    case sub_ints none[TacoOp]()
    case mul_ints none[TacoOp]()
    case div_ints none[TacoOp]()
    case mod_ints none[TacoOp]()
    case and_ints none[TacoOp]()
    case or_ints none[TacoOp]()
    case xor_ints none[TacoOp]()
    case compare_ints none[TacoOp]()
    case unbox none[TacoOp]()
    case generate_array none[TacoOp]()
    case array_get none[TacoOp]()
    case array_set none[TacoOp]()
    case array_slice none[TacoOp]()
    case array_len none[TacoOp]()
    case crash none[TacoOp]()
    case type_info none[TacoOp]()
    case static_to_dynamic none[TacoOp]()
    case dynamic_to_static none[TacoOp]()
    case recursive(holes) {
      var new_holes = list[Hole]()
      for old in holes do {
        var new = hole(old.type)
        mapping.&.put(old, new)
        new_holes.&.push(new)
      }
      some(TacoOp.recursive(new_holes.to_slice()))
    }
    case recurse none[TacoOp]()

  var children = list[TacoExpr]()
  for child in expr.children do
    children.&.push(child.new_holes(mapping))
  expr(new_op or expr.op, children.to_slice(), expr.type)
}
