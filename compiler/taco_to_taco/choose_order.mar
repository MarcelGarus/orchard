import mod.mar

fun choose_optimization_order(taco: Taco): Slice[String] {
  var rev_order = list[String]()
  taco.entry_point.signature.choose_order(taco, rev_order.&)
  var order = list[String]()
  for signature in rev_order.to_slice().rev_iter() do order.&.push(signature)
  order.to_slice()
}
fun choose_order(signature: String, taco: Taco, out: &List[String]) {
  if out.iter().&.contains(signature) then return {}
  out.push(signature)
  taco.funs.get(signature).expr.visit(ChooseOrder { taco, out }).ignore()
}
struct ChooseOrder { taco: Taco, out: &List[String] }
fun visit(expr: TacoExpr, choose: ChooseOrder) {
  if expr.op is call_fun(call) then
    call.fun_.signature.choose_order(choose.taco, choose.out)
  expr.visit_children(choose)
}
fun visit(body: TacoBody, choose: ChooseOrder) {
  body.expr.visit(choose)
}
