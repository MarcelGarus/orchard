import mod.mar

fun desugar_dynamics(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  for fun_ in taco.funs do
    funs.&.put(fun_.key, fun_.value.map(DesugarDynamics { funs = funs.& }))
  Taco { funs, entry_point = taco.entry_point }
}

struct DesugarDynamics { funs: &Map[String, TacoBody] }
fun map(expr: TacoExpr, mapper: DesugarDynamics): TacoExpr {
  var expr = expr.map_children(mapper)
  if expr.op is static_to_dynamic(static) then
    return compile_static_to_dynamic_fun(static.type, mapper.funs)
      .call(list(static).to_slice())
  else if expr.op is dynamic_to_static(dynamic) then
    return compile_dynamic_to_static_fun(expr.type, mapper.funs)
      .call(list(dynamic).to_slice())
  expr
}
fun map(body: TacoBody, mapper: DesugarDynamics): TacoBody {
  TacoBody { params = body.params, body = body.expr.map(mapper) }
}

fun compile_static_to_dynamic_fun(
  type: EggType, funs: &Map[String, TacoBody]
): String {
  var signature = "{type} to dynamic"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[TacoBody]().*) | placeholder

  var value = hole(type)
  funs.put(signature, TacoBody {
    params = list(value).to_slice(),
    body = {
      var value = taco_hole(value)
      switch type.kind()
      case variable panic("type var in compile to dynamic")
      case never taco_unreachable(type_dynamic)
      case type enum_(type_dynamic, "type", taco_nothing)
      case byte enum_(type_dynamic, "byte", value)
      case int enum_(type_dynamic, "int", value)
      case array(item_type)
        enum_(type_dynamic, "array", {
          generate_array(value.array_len(), {
            var index = hole(type_int)
            lambda(list(index).to_slice(), {
              value
                .array_get(taco_hole(index))
                .static_to_dynamic(item_type)
                .desugar_dynamics(funs)
            })
          })
        })
      case struct_(field_types)
        enum_(type_dynamic, "struct", {
          var dynamic_fields = list[YogurtExpr]()
          for field in field_types do {
            var name = field.key
            var field_type = field.value
            dynamic_fields.&.push(struct_(map(
              "name" -> taco_string(name),
              "value" ->
                value.member(name).static_to_dynamic().desugar_dynamics(funs),
            )))
          }
          array(type_dynamic_fields, dynamic_fields.to_slice())
        })
      case enum_(variant_types)
        enum_(type_dynamic, "enum", {
          value.switch_(type_dynamic_variant, {
            var cases = map[String, YogurtBody]()
            for variant in variant_types do {
              var name = variant.key
              var variant_type = variant.value

              var body = body_builder(body.dag).&
              var payload_value = body.param(variant_type)
              var name_and_value = taco_struct_(map(
                "name" -> taco_string(name),
                "value" -> payload_value.static_to_dynamic(context),
              ))
              cases.&.put(name, body.finish(name_and_value))
            }
            cases
          })
        })
      case lambda(lambda_type)
        enum_(type_dynamic, "lambda", {
          var args = hole(type_array(type_dynamic))
          lambda(list(args).to_slice(), {
            body(list(
              | Make sure the number of arguments is correct.
              switch_on_ordering(
                compare_ints(
                  taco_hole(args).array_len(), taco_int(lambda_type.args.len)
                ),
                taco_crash(type_nothing),
                taco_nothing,
                taco_crash(type_nothing),
              ),
              {
                | Convert the arguments into static ones.
                var static_args = list[TacoExpr]()
                for arg in lambda_type.args.iter().enumerate() do
                  static_args.&.push(
                    taco_hole(args)
                      .array_get(taco_int(arg.index))
                      .dynamic_to_static(arg.item)
                      .desugar_dynamics(funs),
                  )
                var args = static_args.to_slice()
                value.call(args).static_to_dynamic().desugar_dynamics(funs)
              },
            ).to_slice())
          })
        })
      case box
        enum_(type_dynamic, "box", {
          unbox(value).static_to_dynamic().desugar_dynamics(funs)
        })
    }
  })
  signature
}

fun compile_dynamic_to_static_fun(
  type: EggType, funs: &Map[String, TacoBody]
): String {
  var signature = "dynamic to {type}"
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[TacoBody]().*) | placeholder

  var value = hole(type_dynamic)
  funs.put(signature, TacoBody {
    params = list(value).to_slice(),
    body = {
      var value = taco_hole(value)
      switch type.kind()
      case variable panic("type var in compile to dynamic")
      case never taco_crash(type)
      case type
        | Note: We don't need to re-create the exact type, as you can't inspect
        | non-statically-known types â€“ during runtime, Types don't store
        | anything. So, we just return _any_ type.
        value.expect_variant_or_crash(
          "type", hole(type_nothing), taco_type(type_int)
        )
      case byte {
        var param = hole(type_byte)
        value.expect_variant_or_crash("byte", param, taco_hole(param))
      }
      case int {
        var param = hole(type_int)
        value.expect_variant_or_crash("int", param, taco_hole(param))
      }
      case array(item_type) {
        var param = hole(type_array(type_dynamic))
        value.expect_variant_or_crash("array", param, {
          generate_array(taco_hole(param).array_len(), {
            var index = hole(type_int)
            lambda(list(index).to_slice(), {
              taco_hole(param)
                .array_get(taco_hole(index))
                .dynamic_to_static(item_type)
                .desugar_dynamics(funs)
            })
          })
        })
      }
      case struct_(field_types) {
        var param = hole(type_dynamic_fields)
        value.expect_variant_or_crash("struct", param, {
          struct_({
            var fields = map[String, TacoExpr]()
            for field in field_types do {
              var name = field.key
              var field_type = field.value
              fields.&.put(name, {
                var index = hole(type_int)
                recursive(list(hole).to_slice(), taco_int(0), {
                  switch_on_ordering(
                    compare_ints(index, taco_hole(param).array_len()),
                    {
                      var field = taco_hole(param).array_get(index)
                      if_(
                        compare_strings(taco_string(name), field.member("name"), context),
                        field.member("value"),
                        recurse(add_ints(index, yogurt_int(1)))
                      )
                    },
                    taco_crash(type_dynamic),
                    taco_unreachable(type_dynamic),
                  )
                })
                  .dynamic_to_static(field_type, context)
              })
            }
            fields
          })
        })
      }
      case enum_(variants)
        value.expect_variant_or_crash(dag, "enum", {
          var body = dag.body_builder().&
          var dynamic = body.param(type_dynamic_variant)

          var inner_body = {
            var body = dag.body_builder().&
            var payload = body.param(type_nothing)
            body.finish(yogurt_crash("No enum case matches.", type))
          }
          for variant in variants do {
            var body = dag.body_builder().&
            var payload = body.param(type_nothing)
            inner_body = body.finish(
              compare_strings(
                dynamic.member("name"), yogurt_string(variant.key), context
              ).switch_(type, map(
                "true" -> dag.body_accepting_nothing(
                  enum_(
                    type,
                    variant.key,
                    dynamic.member("value").dynamic_to_static(
                      variant.value, context
                    ),
                  )
                ),
                "false" -> inner_body,
              ))
            )
          }
          for id in inner_body.children do body.children.&.push(id)
          inner_body.returns
        })
      case lambda
        value.expect_variant_or_crash(dag, "lambda", {
          var body = body_builder(body.dag).&
          var payload = body.param(type_dynamic_lambda)
          body.finish(body.lambda(
            type, compile_static_lambda_wrapper_fun(type, context), box(payload)
          ))
        })
      case box(inner_type)
        value.expect_variant_or_crash(dag, "box", {
          var body = dag.body_builder().&
          var inner = body.param(type_dynamic)
          body.finish(box(inner.dynamic_to_static(inner_type, context)))
        })
    }
  })
  signature
}
fun expect_variant_or_crash(
  enum_: TacoExpr, expected_variant: String, param: Hole, body: TacoExpr
): TacoExpr {
  switch_(enum_, body.type, {
    var cases = map[String, Tuple2[Hole, TacoExpr]]()
    for variant in enum_.type.kind().enum_.unwrap() do
      cases.&.put(
        variant.key,
        if variant.key == expected_variant then
          tuple(param, body)
        else
          tuple(hole(variant.value), taco_crash(body.type)),
      )
    cases
  })
}
fun compare_strings(a: TacoExpr, b: TacoExpr): String {
  var index = hole(type_int)
  if_(
    compare_ints(
      a.member("utf8_bytes").array_len(),
      b.member("utf8_bytes").array_len(),
    ).is_equal(),
    recursive(
      list(index).to_slice(),
      taco_int(0),
      switch_on_ordering(
        compare_ints(taco_hole(index), a.array_len()),
        if_(
          compare_ints(
            a.array_get(taco_hole(index)).byte_to_int(),
            b.array_get(taco_hole(index)).byte_to_int(),
          ).is_equal(),
          recurse(list(add_ints(index, taco_int(1))).to_slice()),
          taco_false,
        ),
        taco_true,
        taco_unreachable(type_bool),
      )
    ),
    taco_false,
  )
}
