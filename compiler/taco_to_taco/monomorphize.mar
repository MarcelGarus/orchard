import mod.mar

fun monomorphize(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  var signature = taco.entry_point.monomorphize(taco, funs.&)
  Taco {
    funs,
    entry_point = TacoCalledFun { signature, substitutions = no_substitutions },
  }
}

fun monomorphize(
  called: TacoCalledFun, taco: Taco, out: &Map[String, TacoBody]
): String {
  | eprintln("Monomorphizing {called.signature} with {called.substitutions}")

  var signature = "{called.signature}"
  if called.substitutions.substitutions.is_not_empty() then
    signature = "{signature} with {called.substitutions}"
  if out.contains(signature) then return signature

  out.put(signature, uninitialized[TacoBody]().*) | placeholder

  var fun_ = taco.funs.get(called.signature)
  var fun_ = TacoBody {
    params = fun_.params.specialize(called.substitutions),
    expr = fun_.expr.map(Monomorphize {
      substitutions = called.substitutions,
      taco,
      out,
    }),
  }

  out.put(signature, fun_)
  signature
}

fun specialize(hole: Hole, substitutions: Substitutions): Hole {
  Hole { id = hole.id, type = hole.type.specialize(substitutions) }
}
fun specialize(holes: Slice[Hole], substitutions: Substitutions): Slice[Hole] {
  var new = list[Hole]()
  for old in holes do new.&.push(old.specialize(substitutions))
  new.to_slice()
}

struct Monomorphize {
  substitutions: Substitutions, taco: Taco, out: &Map[String, TacoBody]
}
fun map(expr: TacoExpr, mono: Monomorphize): TacoExpr {
  var expr = expr(
    expr.map_children(mono).op,
    expr.type.specialize(mono.substitutions),
  )
  if expr.op is hole(hole) then
    return taco_hole(hole.specialize(mono.substitutions))
  if expr.op is type(type) then
    return taco_type(type.specialize(mono.substitutions))
  if expr.op is call_fun(call) then {
    var called = TacoCalledFun {
      signature = call.fun_.signature,
      substitutions =
        call.fun_.substitutions.specialize(mono.substitutions),
    }
    return TacoCalledFun {
      signature = called.monomorphize(mono.taco, mono.out),
      substitutions = no_substitutions,
    }.call(call.args, expr.type)
  }
  expr
}
fun map(body: TacoBody, mono: Monomorphize): TacoBody {
  TacoBody {
    params = body.params.specialize(mono.substitutions),
    expr = body.expr.map(mono),
  }
}

| Specializes the body with type substitutions.
fun specialize(body: TacoBody, substitutions: Substitutions): TacoBody {
  body.map(Specialize { substitutions })
}
struct Specialize { substitutions: Substitutions }
fun map(expr: TacoExpr, specialize: Specialize): TacoExpr {
  if expr.op is hole(hole) then
    return taco_hole(hole.specialize(specialize.substitutions))
  if expr.op is type(type) then
    return taco_type(type.specialize(specialize.substitutions))
  expr(
    expr.map_children(specialize).op,
    expr.type.specialize(specialize.substitutions),
  )
}
fun map(body: TacoBody, specialize: Specialize): TacoBody {
  TacoBody {
    params = body.params.specialize(specialize.substitutions),
    expr = body.expr.map(specialize),
  }
}
