import mod.mar

fun monomorphize(taco: Taco): Taco {
  var funs = map[String, TacoFun]()
  var signature = taco.entry_point.monomorphize(taco, funs.&)
  Taco {
    funs,
    entry_point = TacoCalledFun { signature, substitutions = no_substitutions },
  }
}

fun monomorphize(
  called: TacoCalledFun, taco: Taco, out: &Map[String, TacoFun]
): String {
  eprintln("Monomorphizing {called.signature} with {called.substitutions}")

  var signature = "{called.signature}"
  if called.substitutions.substitutions.is_not_empty() then
    signature = "{signature} with {called.substitutions}"
  if out.contains(signature) then return signature

  out.put(signature, uninitialized[TacoFun]().*) | placeholder

  var fun_ = taco.funs.get(called.signature)
  var fun_ = TacoFun {
    params = fun_.params.specialize(called.substitutions),
    body = fun_.body.monomorphize(called.substitutions, taco, out),
  }

  out.put(signature, fun_)
  signature
}

fun specialize(holes: Slice[Hole], substitutions: Substitutions): Slice[Hole] {
  var new = list[Hole]()
  for old in holes do
    new.&.push(Hole { id = old.id, type = old.type.specialize(substitutions) })
  new.to_slice()
}

fun monomorphize(
  expr: TacoExpr, substitutions: Substitutions,
  taco: Taco, out: &Map[String, TacoFun],
): TacoExpr {
  var op =
    switch expr.op
    case type(type) TacoOp.type(type.specialize(substitutions))
    case lambda(holes) TacoOp.lambda(holes.specialize(substitutions))
    case switch_(holes) TacoOp.switch_(holes.specialize(substitutions))
    case call_fun(fun_)
      TacoOp.call_fun(TacoCalledFun {
        signature = fun_.monomorphize(taco, out),
        substitutions = no_substitutions,
      })
    default expr.op

  var children = list[TacoExpr]()
  for child in expr.children do
    children.&.push(child.monomorphize(substitutions, taco, out))
  var children = children.to_slice()

  var type = expr.type.specialize(substitutions)

  expr(op, children, type)
}
