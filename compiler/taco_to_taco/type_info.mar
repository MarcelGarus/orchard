import mod.mar

fun desugar_type_info(taco: Taco): Taco {
  var funs = map[String, TacoFun]()
  for fun_ in taco.funs do
    funs.&.put(fun_.key, fun_.value.desugar_type_info())
  Taco { funs, entry_point = taco.entry_point }
}

fun desugar_type_info(fun_: TacoFun): TacoFun {
  TacoFun { params = fun_.params, body = fun_.body.desugar_type_info() }
}

fun desugar_type_info(expr: TacoExpr): TacoExpr {
  if expr.op is type_info then
    return type_info_expr(expr.children.get(0).op.type.unwrap())
  
  var children = list[TacoExpr]()
  for child in expr.children do children.&.push(child.desugar_type_info())
  expr(expr.op, children.to_slice(), expr.type)
}

fun type_info_expr(type: EggType): TacoExpr {
  var variant_and_payload =
    switch type.internal_kind()
    case variable unreachable()
    case byte tuple("byte", taco_nothing)
    case int tuple("int", taco_nothing)
    case type tuple("type", taco_nothing)
    case box(inner_type) tuple("box", type_info_expr(inner_type))
    case array(item_type) tuple("array", type_info_expr(item_type))
    case never tuple("never", taco_nothing)
    case struct_(struct_)
      tuple(
        "struct",
        array(type_type_info_fields, {
          var fields = list[TacoExpr]()
          for field in struct_ do
            fields.&.push(struct_(map(
              "name" -> taco_string(field.key),
              "type" -> type_info_expr(field.value),
            )))
          fields.to_slice()
        }),
      )
    case enum_(enum_)
      tuple(
        "enum",
        array(type_type_info_variants, {
          var variants = list[TacoExpr]()
          for variant in enum_ do
            variants.&.push(struct_(map(
              "name" -> taco_string(variant.key),
              "type" -> type_info_expr(variant.value),
            )))
            variants.to_slice()
        }),
      )
    case lambda(lambda)
      tuple(
        "lambda",
        struct_(map(
          "arguments" -> array(type_type_info_lambda_args, {
            var args = list[TacoExpr]()
            for arg in lambda.args do args.&.push(type_info_expr(arg))
            args.to_slice()
          }),
          "return_type" -> type_info_expr(lambda.return_type),
        )),
      )
    case recursive(level) tuple("recursive", taco_int(level))

  enum_(type_type_info, variant_and_payload.a, variant_and_payload.b)
}
