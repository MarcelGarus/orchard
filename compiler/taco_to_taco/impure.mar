import mod.mar

enum Diverges { yes, no, maybe }

fun merge(a: Diverges, b: Diverges): Diverges {
  switch a
  case yes Diverges.yes
  case maybe {
    switch b
    case yes Diverges.yes
    default Diverges.maybe
  }
  case no b
}
fun merge(a: Diverges, b: Diverges, c: Diverges): Diverges {
  a.merge(b).merge(c)
}
fun merge(a: Diverges, b: Diverges, c: Diverges, d: Diverges): Diverges {
  a.merge(b).merge(c).merge(d)
}

fun diverges(expr: TacoExpr): Diverges {
  switch expr.op
  case hole Diverges.no
  case type Diverges.no
  case byte Diverges.no
  case int Diverges.no
  case array(items) {
    var result = Diverges.no
    for item in items do result = merge(result, item.diverges())
    result
  }
  case struct_(fields) {
    var result = Diverges.no
    for field in fields do result = merge(result, field.value.diverges())
    result
  }
  case enum_(enum_) enum_.payload.diverges()
  case lambda Diverges.no
  case box(arg) arg.diverges()
  case member(member) member.of.diverges()
  case switch_(switch_) {
    var result = switch_.condition.diverges()
    for case_ in switch_.cases do
      result = merge(result, case_.value.expr.diverges())
    result
  }
  case call_fun Diverges.maybe
  case call_lambda Diverges.maybe
  case both(args) merge(args.a.diverges(), args.b.diverges())
  case let(let) merge(let.a.diverges(), let.b.expr.diverges())
  case cast(arg) arg.diverges()
  case lower_byte(arg) arg.diverges()
  case byte_to_int(arg) arg.diverges()
  case add(args) merge(args.a.diverges(), args.b.diverges())
  case subtract(args) merge(args.a.diverges(), args.b.diverges())
  case multiply(args) merge(args.a.diverges(), args.b.diverges())
  case divide(args) merge(args.a.diverges(), args.b.diverges(), Diverges.maybe)
  case modulo(args) merge(args.a.diverges(), args.b.diverges(), Diverges.maybe)
  case unchecked_divide(args) merge(args.a.diverges(), args.b.diverges())
  case unchecked_modulo(args) merge(args.a.diverges(), args.b.diverges())
  case and_(args) merge(args.a.diverges(), args.b.diverges())
  case or_(args) merge(args.a.diverges(), args.b.diverges())
  case xor(args) merge(args.a.diverges(), args.b.diverges())
  case compare(args) merge(args.a.diverges(), args.b.diverges())
  case unbox(arg) arg.diverges()
  case generate_array(args)
    merge(
      args.a.diverges(),
      switch args.b.expr.diverges()
      case yes Diverges.maybe
      case maybe Diverges.maybe
      case no Diverges.no
    )
  case array_get(args)
    merge(args.a.diverges(), args.b.diverges(), Diverges.maybe)
  case array_set(args)
    merge(
      args.a.diverges(), args.b.diverges(), args.c.diverges(), Diverges.maybe
    )
  case array_slice(args)
    merge(
      args.a.diverges(), args.b.diverges(), args.c.diverges(), Diverges.maybe
    )
  case array_len(arg) arg.diverges()
  case unchecked_generate_non_empty_array(gen)
    merge(gen.a.diverges(), gen.b.expr.diverges())
  case unchecked_array_get(args) merge(args.a.diverges(), args.b.diverges())
  case unchecked_array_set(args)
    merge(args.a.diverges(), args.b.diverges(), args.c.diverges())
  case unchecked_array_slice(args)
    merge(args.a.diverges(), args.b.diverges(), args.c.diverges())
  case crash Diverges.yes
  case type_info(arg) arg.diverges()
  case static_to_dynamic(arg) arg.diverges()
  case dynamic_to_static(arg) merge(arg.diverges(), Diverges.maybe)
  case recursive(rec) {
    var result = Diverges.maybe
    for arg in rec.a do result = merge(result, arg.diverges())
    merge(result, rec.b.expr.diverges())
  }
  case recurse Diverges.maybe
  case unreachable Diverges.yes
  default Diverges.maybe
}

| Turns the expr into one that evaluates to (Nothing), but has the same impure
| effects (crashing and hanging).
fun keep_only_impure(expr: TacoExpr): TacoExpr {
  if expr.diverges() is no then return taco_nothing

  switch expr.op
  case hole unreachable()
  case type unreachable()
  case byte unreachable()
  case int unreachable()
  case array(items)
    all({
      var exprs = list[TacoExpr]()
      for item in items do exprs.&.push(item.keep_only_impure())
      exprs.to_slice()
    }, taco_nothing)
  case struct_(fields)
    all({
      var exprs = list[TacoExpr]()
      for field in fields do exprs.&.push(field.value.keep_only_impure())
      exprs.to_slice()
    }, taco_nothing)
  case enum_(enum_) enum_.payload.keep_only_impure()
  case lambda unreachable()
  case box(arg) arg.keep_only_impure()
  case member(member) member.of.keep_only_impure()
  case switch_(switch_)
    switch_(switch_.condition.*, type_nothing, {
      var cases = map[String, TacoBody]()
      for case_ in switch_.cases do
        cases.&.put(
          case_.key,
          body(case_.value.params, case_.value.expr.keep_only_impure()),
        )
      cases
    })
  case call_fun expr
  case call_lambda expr
  case both(both) both(both.a.keep_only_impure(), both.b.keep_only_impure())
  case let(let) panic("let")
  case cast(arg) arg.keep_only_impure()
  case lower_byte(arg) arg.keep_only_impure()
  case byte_to_int(arg) arg.keep_only_impure()
  case add(args) both(args.a.keep_only_impure(), args.b.keep_only_impure())
  case subtract(args) both(args.a.keep_only_impure(), args.b.keep_only_impure())
  case multiply(args) both(args.a.keep_only_impure(), args.b.keep_only_impure())
  case divide expr
  case modulo expr
  case and_(args) both(args.a.keep_only_impure(), args.b.keep_only_impure())
  case or_(args) both(args.a.keep_only_impure(), args.b.keep_only_impure())
  case xor(args) both(args.a.keep_only_impure(), args.b.keep_only_impure())
  case compare(args) both(args.a.keep_only_impure(), args.b.keep_only_impure())
  case unbox(args) args.keep_only_impure()
  case generate_array expr
  case array_get expr
  case array_set expr
  case array_slice expr
  case array_len(arg) arg.keep_only_impure()
  case crash expr
  case type_info(arg) arg.keep_only_impure()
  case static_to_dynamic(arg) arg.keep_only_impure()
  case dynamic_to_static expr
  case recursive expr
  case recurse expr
  case unreachable expr
  default expr
}

fun assert_not_crashing(expr: TacoExpr, not_crashing: TacoExpr): TacoExpr {
  expr.map(AssertNotCrashing { not_crashing })
}
fun assert_not_crashing(body: TacoBody, not_crashing: TacoExpr): TacoBody {
  body.map(AssertNotCrashing { not_crashing })
}
struct AssertNotCrashing { not_crashing: TacoExpr }
fun map(expr: TacoExpr, assert_not_crashing: AssertNotCrashing): TacoExpr {
  if expr.op is both(both) then
    if both.a.* =~= assert_not_crashing.not_crashing then
      return both.b.map(assert_not_crashing)
  expr.map_children(assert_not_crashing)
}
