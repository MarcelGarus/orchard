import mod.mar

fun desugar_type_info(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  for fun_ in taco.funs do
    funs.&.put(fun_.key, fun_.value.map(DesugarTypeInfo { funs = funs.& }))
  Taco { funs, entry_point = taco.entry_point }
}

struct DesugarTypeInfo { funs: &Map[String, TacoBody] }
fun map(expr: TacoExpr, desugar: DesugarTypeInfo): TacoExpr {
  var expr = expr.map_children(desugar)
  if expr.op is type_info(type) then
    return type_info_expr(type.op.type.unwrap())
  expr
}

fun type_info_expr(type: EggType): TacoExpr {
  var variant_and_payload =
    switch type.internal_kind()
    case variable panic("not monomorphized yet")
    case byte tuple("byte", taco_nothing)
    case int tuple("int", taco_nothing)
    case type tuple("type", taco_nothing)
    case box(inner_type) tuple("box", type_info_expr(inner_type))
    case array(item_type) tuple("array", type_info_expr(item_type))
    case never tuple("never", taco_nothing)
    case struct_(struct_)
      tuple(
        "struct",
        array(type_type_info_fields, {
          var fields = list[TacoExpr]()
          for field in struct_ do
            fields.&.push(struct_(map(
              "name" -> taco_string(field.key),
              "type" -> type_info_expr(field.value),
            )))
          fields.to_slice()
        }),
      )
    case enum_(enum_)
      tuple(
        "enum",
        array(type_type_info_variants, {
          var variants = list[TacoExpr]()
          for variant in enum_ do
            variants.&.push(struct_(map(
              "name" -> taco_string(variant.key),
              "type" -> type_info_expr(variant.value),
            )))
            variants.to_slice()
        }),
      )
    case lambda(lambda)
      tuple(
        "lambda",
        struct_(map(
          "arguments" -> array(type_type_info_lambda_args, {
            var args = list[TacoExpr]()
            for arg in lambda.args do args.&.push(type_info_expr(arg))
            args.to_slice()
          }),
          "return_type" -> type_info_expr(lambda.return_type),
        )),
      )
    case recursive(level) tuple("recursive", taco_int(level))

  enum_(type_type_info, variant_and_payload.a, variant_and_payload.b)
}
