import mod.mar

struct TacoComptimeValue { kind: TacoComptimeValueKind, type: EggType }
enum TacoComptimeValueKind {
  type: EggType,
  byte: Byte,
  int: Int,
  array: Slice[TacoComptimeValue],
  struct_: Map[String, TacoComptimeValue],
  enum_: TacoEnumComptimeValue,
  lambda: TacoLambdaComptimeValue,
  box: &TacoComptimeValue,
}
struct TacoEnumComptimeValue { name: String, value: &TacoComptimeValue }
struct TacoLambdaComptimeValue { function: String, closure: &TacoComptimeValue }

fun typed(kind: TacoComptimeValueKind, type: EggType): TacoComptimeValue {
  TacoComptimeValue { kind, type }
}

fun write[W](writer: W, value: TacoComptimeValue) {
  switch value.kind
  case byte(byte) writer."{byte}"
  case int(int) writer."{int}"
  case box(inner) writer."(box {inner})"
  case array(items) {
    writer."["
    var first = true
    for item in items do {
      if first then first = false else writer." "
      writer."{item}"
    }
    writer."]"
  }
  case struct_(fields) {
    writer."(&"
    for field in fields do writer." {field.key}: {field.value}"
    writer.")"
  }
  case enum_(enum_) {
    if enum_.value.kind is struct_(fields) then if fields.is_empty() then {
      writer."(| {enum_.name})"
      return {}
    }
    writer."(| {enum_.name}: {enum_.value})"
  }
  case lambda(lambda) writer."(\\ ...)"
  case type(type) writer."{type}"
}

fun to_comptime(expr: TacoExpr): Result[TacoComptimeValue, Nothing] {
  var kind =
    switch expr.op
    case byte(byte) TacoComptimeValueKind.byte(byte)
    case int(int) TacoComptimeValueKind.int(int)
    case array(array) {
      var items = list[TacoComptimeValue]()
      for item in array do items.&.push(item.to_comptime()?)
      TacoComptimeValueKind.array(items.to_slice())
    }
    case struct_(struct_) {
      var fields = map[String, TacoComptimeValue]()
      for field in struct_ do
        fields.&.put(field.key, field.value.to_comptime()?)
      TacoComptimeValueKind.struct_(fields)
    }
    case enum_(enum_)
      TacoComptimeValueKind.enum_(TacoEnumComptimeValue {
        name = enum_.name,
        value = enum_.value.to_comptime()?.put_on_heap(),
      })
    | case lambda(lambda)
    |   TacoComptimeValueKind.lambda(TacoLambdaComptimeValue {
    |     body = lambda.function,
    |     closure = lambda.closure.to_comptime(lambda.closure)?.put_on_heap(),
    |   })
    case type(type) TacoComptimeValueKind.type(type)
    default return error[TacoComptimeValue, Nothing]({})
  ok[TacoComptimeValue, Nothing](TacoComptimeValue { kind, type = expr.type })
}

fun to_expr(value: TacoComptimeValue): TacoExpr {
  switch value.kind
  case int(int) egg_int(int)
  case byte(byte) egg_byte(byte)
  case box(inner) box(inner.to_expr())
  case array(array) {
    var items = list[TacoExpr]()
    for item in array do items.&.push(item.to_expr())
    array(value.type, items.to_slice())
  }
  case struct_(struct_) {
    var fields = map[String, TacoExpr]()
    for field in struct_ do fields.&.put(field.key, field.value.to_expr())
    struct_(fields)
  }
  case enum_(enum_)
    enum_(value.type, enum_.name, enum_.value.to_expr())
  case lambda(lambda)
    todo("handle lambda result")
    | egg_lambda(value.type, lambda.function, lambda.closure.to_expr()))
  case type(type) egg_type(type)
}

struct TacoRunResources { exprs: Int }
fun use_expr(res: &TacoRunResources): Result[Nothing, Nothing] {
  if res.exprs > 0 then {
    res.exprs = res.exprs - 1
    ok[Nothing, Nothing]({})
  } else
    error[Nothing, Nothing]({})
}

struct RunTacoContext { resources: &TacoRunResources, egg: Taco }

fun run(
  fun_: TacoCalledFun, args: Slice[TacoComptimeValue], context: RunTacoContext
): Result[TacoComptimeValue, Nothing] {
  | eprint("\"{function}\"")
  | for arg in args do eprint(" {arg}")
  | eprintln()

  var fun_ = context.egg.funs.get(fun_.signature)
  var value = fun_.body.run(args, RunTacoFunContext {
    global = context, visible = map[TacoId, TacoComptimeValue]().&
  })?

  ok[TacoComptimeValue, Nothing](value)
}

struct RunTacoFunContext {
  global: RunTacoContext, visible: &Map[TacoId, TacoComptimeValue]
}

fun run(
  body: TacoBody, args: Slice[TacoComptimeValue], context: RunTacoFunContext
): Result[TacoComptimeValue, Nothing] {
  for both in zip(body.params.iter(), args.iter()) do
    context.visible.put(both.a, both.b)
  for id in body.children do
    context.visible.put(id, id.get().run(context)?)
  body.returns.run(context)
}

fun run(
  expr: TacoExpr, context: RunTacoFunContext
): Result[TacoComptimeValue, Nothing] {
  context.global.resources.use_expr()?
  | eprintln("Running: {expr.debug()}")

  ok[TacoComptimeValue, Nothing](
    switch expr.op
    case param unreachable()
    case id(id) context.visible.get(id)
    case byte(byte) TacoComptimeValueKind.byte(byte).typed(type_byte)
    case int(int) TacoComptimeValueKind.int(int).typed(type_int)
    case array(array) {
      var items = list[TacoComptimeValue]()
      for item in array do items.&.push(item.run(context)?)
      TacoComptimeValueKind.array(items.to_slice()).typed(expr.type)
    }
    case struct_(struct_) {
      var fields = map[String, TacoComptimeValue]()
      for field in struct_ do
        fields.&.put(field.key, field.value.run(context)?)
      TacoComptimeValueKind.struct_(fields).typed(expr.type)
    }
    case member(member)
      member.of.run(context)?.kind.struct_.unwrap().get(member.name)
    case enum_(enum_)
      TacoComptimeValueKind.enum_(TacoEnumComptimeValue {
        name = enum_.name, value = enum_.value.run(context)?.put_on_heap()
      }).typed(expr.type)
    case switch_(switch_) {
      var condition = switch_.condition.run(context)?.kind.enum_.unwrap()
      var case_ = switch_.cases.get(condition.name)
      case_.run(list(condition.value.*).to_slice(), context)?
    }
    case lambda(lambda)
      return error[TacoComptimeValue, Nothing]({}) | TODO
      | todo("comptime lambda construction")
      | TacoComptimeValueKind.lambda(TacoLambdaComptimeValue {
      |   function = lambda.function,
      |   closure = visible.get(lambda.closure).put_on_heap(),
      | }).typed(expr.type)
    case call(call) {
      var args = list[TacoComptimeValue]()
      for arg in call.args do args.&.push(arg.run(context)?)
      var args = args.to_slice()

      switch call.callee
      case lambda(lambda) {
        todo("comptime lambda call")
        | var lambda = lambda.run(context)?.kind.lambda.unwrap()
        | var all_args = list[TacoComptimeValue]()
        | for arg in args do all_args.&.push(arg)
        | all_args.&.push(lambda.closure.*)
        | lambda.function.run(all_args.to_slice(), egg, res)?
      }
      case fun_(fun_) fun_.run(args, context.global)?
      case builtin(builtin) {
        switch builtin.builtin
        case lower_byte
          TacoComptimeValueKind.byte(
            args.get(0).kind.int.unwrap().lower_byte()
          ).typed(expr.type)
        case byte_to_int
          TacoComptimeValueKind.int(args.get(0).kind.byte.unwrap().to_int())
            .typed(expr.type)
        case add_ints
          TacoComptimeValueKind.int(
            args.get(0).kind.int.unwrap() + args.get(1).kind.int.unwrap()
          ).typed(expr.type)
        case sub_ints
          TacoComptimeValueKind.int(
            args.get(0).kind.int.unwrap() - args.get(1).kind.int.unwrap()
          ).typed(expr.type)
        case mul_ints
          TacoComptimeValueKind.int(
            args.get(0).kind.int.unwrap() * args.get(1).kind.int.unwrap()
          ).typed(expr.type)
        case div_ints
          TacoComptimeValueKind.int(
            args.get(0).kind.int.unwrap() / args.get(1).kind.int.unwrap()
          ).typed(expr.type)
        case mod_ints
          TacoComptimeValueKind.int(
            args.get(0).kind.int.unwrap() % args.get(1).kind.int.unwrap()
          ).typed(expr.type)
        case and_ints
          TacoComptimeValueKind.int(
            args.get(0).kind.int.unwrap() & args.get(1).kind.int.unwrap()
          ).typed(expr.type)
        case or_ints
          TacoComptimeValueKind.int(
            or(args.get(0).kind.int.unwrap(), args.get(1).kind.int.unwrap())
          ).typed(expr.type)
        case xor_ints
          TacoComptimeValueKind.int(
            args.get(0).kind.int.unwrap() ^ args.get(1).kind.int.unwrap()
          ).typed(expr.type)
        case compare_ints
          TacoComptimeValueKind.enum_(TacoEnumComptimeValue {
            name =
              switch
                args.get(0).kind.int.unwrap() <=> args.get(1).kind.int.unwrap()
              case less "less"
              case equal "equal"
              case greater "greater",
            value = TacoComptimeValue {
              kind = TacoComptimeValueKind.struct_(
                map[String, TacoComptimeValue]()
              ),
              type = type_nothing,
            }.put_on_heap(),
          }).typed(expr.type)
        case box
          TacoComptimeValueKind.box(args.get(0).put_on_heap()).typed(expr.type)
        case unbox args.get(0).kind.box.unwrap().*
        case generate_array {
          todo("comptime generate array")
          | var len = args.get(0).kind.int.unwrap()
          | var lambda = args.get(1).kind.lambda.unwrap()
          | var items = list[TacoComptimeValue]()
          | for index in 0..len do
          |   items.&.push(
          |     lambda.function.run(
          |       list(
          |         TacoComptimeValueKind.int(index).typed(type_int),
          |         lambda.closure.*,
          |       ).to_slice(),
          |       egg,
          |       res,
          |     )?
          |   )
          | TacoComptimeValueKind.array(items.to_slice()).typed(expr.type)
        }
        case array_get {
          var array = args.get(0).kind.array.unwrap()
          var index = args.get(1).kind.int.unwrap()
          array.get(index)
        }
        case array_set {
          var array = args.get(0).kind.array.unwrap()
          var index = args.get(1).kind.int.unwrap()
          var item  = args.get(2)
          var copy = list[TacoComptimeValue]()
          for item in array do copy.&.push(item)
          copy.&.set(index, item)
          TacoComptimeValueKind.array(copy.to_slice()).typed(expr.type)
        }
        case array_slice {
          var array = args.get(0).kind.array.unwrap()
          var range = args.get(1).kind.struct_.unwrap()
          var start = range.get("start").kind.int.unwrap()
          var end   = range.get("end").kind.int.unwrap()
          TacoComptimeValueKind.array(array.subslice(start..end))
            .typed(expr.type)
        }
        case array_len
          TacoComptimeValueKind.int(args.get(0).kind.array.unwrap().len)
            .typed(expr.type)
        case call todo("comptime call builtin")
        case type_of todo("comptime type_of builtin")
        case type_info todo("comptime type_info builtin")
        case static_to_dynamic todo("comptime static_to_dynamic builtin")
        case dynamic_to_static todo("comptime static_to_dynamic builtin")
        case crash return error[TacoComptimeValue, Nothing]({})
      }
    }
    case recursive(loop_) todo("comptime loop")
    case recurse(args) todo("comptime continue")
    case cast(inner) {
      inner.run(context)?.cast(expr.type)
      | return error[TacoComptimeValue, Nothing]({})
    }
    case type(type) TacoComptimeValueKind.type(type).typed(type_type)
  )
}

fun cast(value: TacoComptimeValue, type: EggType): TacoComptimeValue {
  if value.type == type then return value

  switch type.kind()
  case box(inner_type)
    TacoComptimeValueKind.box(
      value.kind.box.unwrap().cast(inner_type).put_on_heap()
    ).typed(type)
  case array(item_type) {
    var items = list[TacoComptimeValue]()
    for item in value.kind.array.unwrap() do
      items.&.push(item.cast(item_type))
    TacoComptimeValueKind.array(items.to_slice()).typed(type)
  }
  case struct_(field_types) {
    var fields = map[String, TacoComptimeValue]()
    for field in value.kind.struct_.unwrap() do
      fields.&.put(field.key, field.value.cast(field_types.get(field.key)))
    TacoComptimeValueKind.struct_(fields).typed(type)
  }
  case enum_(variant_types) {
    var enum_ = value.kind.enum_.unwrap()
    TacoComptimeValueKind.enum_(TacoEnumComptimeValue {
      name = enum_.name,
      value = enum_.value.cast(variant_types.get(enum_.name)).put_on_heap(),
    }).typed(type)
  }
  case lambda(lambda) todo("comptime lambda cast")
  case never unreachable()
  default panic("cast from {value.type} to {type}")
}
