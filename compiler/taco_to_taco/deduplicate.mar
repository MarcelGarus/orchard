fun deduplicate(lime: Taco): Taco {
  var funs = map[String, TacoFun]()
  for fun_ in lime.funs do funs.&.put(fun_.key, fun_.value.deduplicate())
  Taco { entry_point = lime.entry_point, funs = funs }
}

fun deduplicate(fun_: TacoFun): TacoFun {
  TacoFun {
    params = fun_.params,
    body = {
      var body = ongoing_body(fun_.params)
      var bodies = list(body)
      var inner = fun_.body.deduplicate(bodies.&)
      var body = bodies.&.pop()
      body(body.lets.to_slice(), inner)
        .inline_lets_only_used_once_in_same_body()
    }
  }
}

struct OngoingBody {
  defined_holes: Slice[Hole], lets: List[Tuple2[Hole, TacoExpr]]
}
fun ongoing_body(defined_holes: Slice[Hole]): OngoingBody {
  OngoingBody { defined_holes, lets = list[Tuple2[Hole, TacoExpr]]() }
}

fun deduplicate(expr: TacoExpr, bodies: &List[OngoingBody]): TacoExpr {
  var expr =
    switch expr.op
    case lambda(params) {
      var body = ongoing_body(params)
      bodies.push(body)
      var inner = expr.children.get(0).deduplicate(bodies)
      var body = bodies.pop()
      lambda(params, body(body.lets.to_slice(), inner))
    }
    case switch_(holes) {
      var children = list[TacoExpr]()
      children.&.push(expr.children.first().deduplicate(bodies))
      for both in zip(holes.iter(), expr.children.without_first().iter()) do {
        var body = ongoing_body(list(both.a).to_slice())
        bodies.push(body)
        var inner = both.b.deduplicate(bodies)
        var body = bodies.pop()
        children.&.push(body(body.lets.to_slice(), inner))
      }
      expr(expr.op, children.to_slice(), expr.type)
    }
    case generate_array(index) {
      var length = expr.children.get(0).deduplicate(bodies)
      var body = ongoing_body(list(index).to_slice())
      bodies.push(body)
      var generator = expr.children.get(1).deduplicate(bodies)
      var body = bodies.pop()
      generate_array(length, index, body(body.lets.to_slice(), generator))
    }
    case recursive(args) {
      var children = list[TacoExpr]()
      for child in expr.children.without_last() do
        children.&.push(child.deduplicate(bodies))
      var body = ongoing_body(args)
      bodies.push(body)
      var inner = expr.children.last().deduplicate(bodies)
      var body = bodies.pop()
      children.&.push(body(body.lets.to_slice(), inner))
      expr(expr.op, children.to_slice(), expr.type)
    }
    default {
      var children = list[TacoExpr]()
      for child in expr.children do
        children.&.push(child.deduplicate(bodies))
      expr(expr.op, children.to_slice(), expr.type)
    }

  for body in bodies do
    for visible in body.lets do
      if visible.b == expr then return taco_hole(visible.a)

  if expr.is_expensive() then {
    var hole = hole(expr.type)
    bodies.get_ref(bodies.len - 1).lets.&.push(tuple(hole, expr))
    taco_hole(hole)
  } else
    expr
}

fun is_expensive(expr: TacoExpr): Bool {
  switch expr.op
  case hole false
  case type false
  case byte false
  case int false
  case array true
  case struct_ false
  case enum_ false
  case lambda true
  case box true
  case member false
  case switch_ true
  case call_fun true
  case call_lambda true
  case both false
  case let_body false
  default true
}

fun count_hole_references(expr: TacoExpr): Map[Hole, Int] {
  var counts = map[Hole, Int]()
  expr.count_hole_references(counts.&)
  counts
}
fun count_hole_references(expr: TacoExpr, out: &Map[Hole, Int]) {
  if expr.op is hole(hole) then {
    var count = out.get_ref_or_put_default(hole, 0)
    count.* = count.* + 1
  }
  for child in expr.children do child.count_hole_references(out)
}

fun inline_lets_only_used_once_in_same_body(expr: TacoExpr): TacoExpr {
  var hole_counts = expr.count_hole_references()
  expr.inline_lets_only_used_once_in_same_body(hole_counts)
}
fun inline_lets_only_used_once_in_same_body(
  expr: TacoExpr, hole_counts: Map[Hole, Int]
): TacoExpr {
  var children = list[TacoExpr]()
  for child in expr.children do
    children.&.push(child.inline_lets_only_used_once_in_same_body(hole_counts))
  var children = children.to_slice()

  if expr.op is let_body(holes) then {
    var rev_holes = list[Hole]()
    var rev_children = list(children.last())
    for both in zip(holes.rev_iter(), children.without_last().rev_iter()) do {
      var hole = both.a
      var expr = both.b
      if hole_counts.get(hole) == 1 then {
        | Inline the hole definition if it's used in the same body.
        var used = false
        var new_rev_children = list[TacoExpr]()
        for child in rev_children do
          new_rev_children.&.push(
            child.inline_hole_if_in_same_body(hole, expr, used.&)
          )
        if used then rev_children = new_rev_children
      } else {
        rev_holes.&.push(hole)
        rev_children.&.push(expr)
      }
    }
    var holes = list[Hole]()
    var children = list[TacoExpr]()
    for hole in rev_holes.to_slice().rev_iter() do holes.&.push(hole)
    for child in rev_children.to_slice().rev_iter() do children.&.push(child)
    expr(TacoOp.let_body(holes.to_slice()), children.to_slice(), expr.type)
  } else
    expr(expr.op, children, expr.type)
}
| fun inline_hole_if_in_same_body(expr: TacoExpr, hole: Hole, def: TacoExpr): Maybe[TacoExpr] {
|   var used = false
|   var expr = expr.inline_hole_if_in_same_body(hole, def, used.&)
|   if used then some(expr) else none[TacoExpr]()
| }
fun inline_hole_if_in_same_body(
  expr: TacoExpr, hole: Hole, def: TacoExpr, used: &Bool
): TacoExpr {
  switch expr.op
  case hole(h)
    if h == hole then {
      used.* = true
      def
    } else
      expr
  case lambda expr
  case switch_ expr
  case generate_array expr
  case recursive expr
  default {
    var children = list[TacoExpr]()
    for child in expr.children do
      children.&.push(child.inline_hole_if_in_same_body(hole, def, used))
    expr(expr.op, children.to_slice(), expr.type)
  }
}
