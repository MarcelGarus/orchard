import mod.mar

fun deduplicate(lime: Taco): Taco {
  var funs = map[String, TacoBody]()
  for fun_ in lime.funs do funs.&.put(fun_.key, fun_.value.deduplicate())
  Taco { entry_point = lime.entry_point, funs = funs }
}

fun deduplicate(fun_: TacoBody): TacoBody {
  TacoBody {
    params = fun_.params,
    expr = {
      var body = ongoing_body(fun_.params)
      var bodies = list(body)
      var inner = fun_.expr.map(Deduplicate { bodies = bodies.& })
      var body = bodies.&.pop()
      lets(body.lets.to_slice(), inner)
        .inline_lets_only_used_once_in_same_body()
    }
  }
}

struct Deduplicate { bodies: &List[OngoingBody] }
struct OngoingBody {
  defined_holes: Slice[Hole], lets: List[Tuple2[Hole, TacoExpr]]
}
fun ongoing_body(defined_holes: Slice[Hole]): OngoingBody {
  OngoingBody { defined_holes, lets = list[Tuple2[Hole, TacoExpr]]() }
}

fun map(expr: TacoExpr, deduplicate: Deduplicate): TacoExpr {
  var expr = expr.map_children(deduplicate)

  for body in deduplicate.bodies do
    for visible in body.lets do
      if visible.b == expr then return taco_hole(visible.a)

  if expr.is_expensive() then {
    var hole = hole(expr.type)
    if expr.can_diverge() then
      deduplicate.bodies.get_ref(deduplicate.bodies.len - 1).lets.&.push(tuple(hole, expr))
    else {
      | Add it to the outermost possible body so that we don't recompute the
      | expression in loops / lambdas every time.
      var referenced_holes = expr.collect_captured()
      var i = deduplicate.bodies.len - 1
      loop {
        if i == 0 then break
        var body = deduplicate.bodies.get(i)
        var can_move_further = true
        for hole in referenced_holes do {
          if body.defined_holes.iter().&.contains(hole) then
            can_move_further = false
          for let in body.lets do if let.a == hole then can_move_further = false
        }
        if not(can_move_further) then break
        i = i - 1
      }
      deduplicate.bodies.get_ref(i).lets.&.push(tuple(hole, expr))
    }
    taco_hole(hole)
  } else
    expr
}
fun map(body: TacoBody, deduplicate: Deduplicate): TacoBody {
  deduplicate.bodies.push(ongoing_body(body.params))
  var expr = body.expr.map(deduplicate)
  var ongoing = deduplicate.bodies.pop()
  TacoBody { params = body.params, expr = lets(ongoing.lets.to_slice(), expr) }
}

fun is_expensive(expr: TacoExpr): Bool {
  switch expr.op
  case hole false
  case type false
  case byte false
  case int false
  case array true
  case struct_ false
  case enum_ false
  case lambda true
  case box true
  case member false
  case switch_ true
  case call_fun true
  case call_lambda true
  case both false
  case let false
  default true
}

fun count_hole_references(expr: TacoExpr): Map[Hole, Int] {
  var counts = map[Hole, Int]()
  expr.visit(CountHoles { counts = counts.& })
  counts
}
struct CountHoles { counts: &Map[Hole, Int] }
fun visit(expr: TacoExpr, count_holes: CountHoles) {
  if expr.op is hole(hole) then {
    var count = count_holes.counts.get_ref_or_put_default(hole, 0)
    count.* = count.* + 1
  }
  expr.visit_children(count_holes)
}
fun visit(body: TacoBody, count_holes: CountHoles) {
  body.expr.visit(count_holes)
}

fun inline_lets_only_used_once_in_same_body(expr: TacoExpr): TacoExpr {
  var hole_counts = expr.count_hole_references()
  expr.map(InlineLetsOnlyUsedOnceInSameBody { hole_counts })
}
struct InlineLetsOnlyUsedOnceInSameBody { hole_counts: Map[Hole, Int] }
fun map(expr: TacoExpr, inline: InlineLetsOnlyUsedOnceInSameBody): TacoExpr {
  var expr = expr.map_children(inline)

  if expr.op is let(let) then {
    var hole = let.b.params.get(0)
    if inline.hole_counts.get(hole) == 1 then
      if let.b.expr.inline_hole_if_in_same_body(hole, let.a.*) is some(result)
      then
        return result
  }

  expr
}
fun map(body: TacoBody, inline: InlineLetsOnlyUsedOnceInSameBody): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(inline) }
}

fun inline_hole_if_in_same_body(
  expr: TacoExpr, hole: Hole, def: TacoExpr
): Maybe[TacoExpr] {
  var used = false
  var expr = expr.map(InlineHoleIfInSameBody { hole, def, used = used.& })
  if used then some(expr) else none[TacoExpr]()
}
struct InlineHoleIfInSameBody { hole: Hole, def: TacoExpr, used: &Bool }
fun map(expr: TacoExpr, inline: InlineHoleIfInSameBody): TacoExpr {
  if expr.op is hole(hole) then
    if hole == inline.hole then {
      inline.used.* = true
      return inline.def
    }
  expr.map_children(inline)
}
fun map(body: TacoBody, inline: InlineHoleIfInSameBody): TacoBody { body }
