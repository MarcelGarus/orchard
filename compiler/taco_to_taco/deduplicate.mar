fun deduplicate(lime: Taco): Taco {
  var funs = map[String, TacoFun]()
  for fun_ in lime.funs do funs.&.put(fun_.key, fun_.value.deduplicate())
  Taco { entry_point = lime.entry_point, funs = funs }
}

fun deduplicate(fun_: TacoFun): TacoFun {
  TacoFun {
    params = fun_.params,
    body = {
      var lets = list[Tuple2[Hole, TacoExpr]]()
      var inner =
        fun_.body.deduplicate(lets.&, list[Tuple2[Hole, TacoExpr]]().&)
      body(lets.to_slice(), inner)
    }
  }
}

fun deduplicate(
  expr: TacoExpr,
  body: &List[Tuple2[Hole, TacoExpr]],
  visible: &List[Tuple2[Hole, TacoExpr]],
): TacoExpr {
  var expr =
    switch expr.op
    case lambda(params) {
      var body = list[Tuple2[Hole, TacoExpr]]()
      var snapshot = visible.len
      var inner = expr.children.get(0).deduplicate(body.&, visible)
      visible.len = snapshot
      lambda(params, body(body.to_slice(), inner))
    }
    case switch_ {
      var children = list[TacoExpr]()
      children.&.push(expr.children.first().deduplicate(body, visible))
      for child in expr.children.without_first() do {
        var body = list[Tuple2[Hole, TacoExpr]]()
        var snapshot = visible.len
        var inner = child.deduplicate(body.&, visible)
        visible.len = snapshot
        children.&.push(body(body.to_slice(), inner))
      }
      expr(expr.op, children.to_slice(), expr.type)
    }
    case generate_array(index) {
      var length = expr.children.get(0).deduplicate(body, visible)
      var body = list[Tuple2[Hole, TacoExpr]]()
      var snapshot = visible.len
      var generator = expr.children.get(1).deduplicate(body.&, visible)
      visible.len = snapshot
      generate_array(length, index, body(body.to_slice(), generator))
    }
    case recursive {
      var children = list[TacoExpr]()
      for child in expr.children.without_last() do
        children.&.push(child.deduplicate(body, visible))
      var body = list[Tuple2[Hole, TacoExpr]]()
      var snapshot = visible.len
      var inner = expr.children.last().deduplicate(body.&, visible)
      children.&.push(body(body.to_slice(), inner))
      visible.len = snapshot
      expr(expr.op, children.to_slice(), expr.type)
    }
    default {
      var children = list[TacoExpr]()
      for child in expr.children do
        children.&.push(child.deduplicate(body, visible))
      expr(expr.op, children.to_slice(), expr.type)
    }

  for visible in visible do
    if visible.b == expr then return taco_hole(visible.a)

  if expr.is_expensive() then {
    var hole = hole(expr.type)
    body.push(tuple(hole, expr))
    visible.push(tuple(hole, expr))
    taco_hole(hole)
  } else
    expr
}

fun is_expensive(expr: TacoExpr): Bool {
  switch expr.op
  case hole false
  case type false
  case byte false
  case int false
  case array true
  case struct_ false
  case enum_ false
  case lambda true
  case box true
  case member false
  case switch_ true
  case call_fun true
  case call_lambda true
  case body false
  case let_body false
  default true
}
