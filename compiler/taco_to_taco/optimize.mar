import mod.mar

fun optimize(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  for signature in taco.choose_optimization_order() do {
    | eprintln("Optimizing {signature}")
    | stderr.write(signature, taco.funs.get(signature))
    | eprintln()

    funs.&.put(
      signature,
      taco.funs.get(signature).optimize(OptimizeTacoContext {
        optimized = funs, taco
      })
    )

    | eprintln("Optimized")
    | stderr.write(signature, funs.get(signature))
    | eprintln()
  }
  Taco { funs, entry_point = taco.entry_point }.tree_shake()
}

fun choose_optimization_order(taco: Taco): Slice[String] {
  var rev_order = list[String]()
  taco.entry_point.signature.choose_order(taco, rev_order.&)
  var order = list[String]()
  for signature in rev_order.to_slice().rev_iter() do order.&.push(signature)
  order.to_slice()
}
fun choose_order(signature: String, taco: Taco, out: &List[String]) {
  if out.iter().&.contains(signature) then return {}
  out.push(signature)
  taco.funs.get(signature).expr.visit(ChooseOrder { taco, out }).ignore()
}
struct ChooseOrder { taco: Taco, out: &List[String] }
fun visit(expr: TacoExpr, choose: ChooseOrder) {
  if expr.op is call_fun(call) then
    call.fun_.signature.choose_order(choose.taco, choose.out)
  expr.visit_children(choose)
}
fun visit(body: TacoBody, choose: ChooseOrder) {
  body.expr.visit(choose)
}

fun tree_shake(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  for signature in taco.choose_optimization_order() do
    funs.&.put(signature, taco.funs.get(signature))
  Taco { funs, entry_point = taco.entry_point }
}

struct OptimizeTacoContext { optimized: Map[String, TacoBody], taco: Taco }
struct Optimize { context: OptimizeTacoContext }
fun map(expr: TacoExpr, optimize: Optimize): TacoExpr {
  expr.map_children(optimize).optimize_shallow(optimize.context)
}
fun map(body: TacoBody, optimize: Optimize): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(optimize) }
}
fun optimize(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
  expr.map(Optimize { context })
}
fun optimize(body: TacoBody, context: OptimizeTacoContext): TacoBody {
  body.map(Optimize { context })
}

| Assumes that the children are already optimized.
fun optimize_shallow(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
  var type = expr.type
  switch expr.op
  case member(member)
    if member.of.op is struct_(fields) then return fields.get(member.name)
  case switch_(switch_) {
    if switch_.condition.op is enum_(enum_) then {
      return switch_.cases.get(enum_.variant)
        .fill(enum_.payload.*)
        .optimize(context)
    }
  }
  case call_fun(call) {
    | TODO: Try to run the function at compile time.

    | We inline the function, if:
    | - The function has already been visited during the optimization pass.
    |   Otherwise, mutually recursive functions might hang the compiler.
    | - The function size fits in some upper bound.
    |   Otherwise, we may get exponential code explosion.
    | - The function is not generic.
    |   Otherwise, the function might call itself with different type arguments
    |   and we can't model that, not even using a recursive expression. After
    |   monomorphization, no generic functions exist, so every function has a
    |   chance of being inlined eventually.
    if call.fun_.substitutions.substitutions.size == 0 then
      if context.optimized.get_maybe(call.fun_.signature) is some(body) then {
        var should_inline = body.expr.num_exprs() <= 30
        if should_inline then {
          return recursive(
            call.args,
            body
              .specialize(call.fun_.substitutions)
              .new_holes()
              .call_to_recurse(call.fun_, type.specialize(call.fun_.substitutions)),
          ).optimize_shallow(context)
        }
      }
  }
  case call_lambda(call)
    if call.lambda.op is lambda(body) then return body.fill(call.args)
  case both(both) {
    var new_children = list[TacoExpr]()
    both.ignored.collect_impure(new_children.&)
    new_children.&.push(both.result.*)
    return body(new_children.to_slice())
  }
  case let panic("optimize let")
  case cast(inner) {
    if inner.type == type then return inner.*
    if inner.op is enum_(enum_) then {
      var wanted_payload_type = type.kind().enum_.unwrap().get(enum_.variant)
      return enum_(
        type,
        enum_.variant,
        enum_.payload.cast(wanted_payload_type).optimize_shallow(context),
      )
    }
  }
  case lower_byte(int) {
    if int.op is int(int) then return taco_byte(int.lower_byte())
  }
  case byte_to_int(byte) {
    if byte.op is byte(byte) then return taco_int(byte.to_int())
  }
  case add_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then return taco_int(a + b)
    if a.op is int(a) then if a == 0 then return b  | 0 + x
    if b.op is int(b) then if b == 0 then return a  | x + 0
    if a.op is sub_ints(args) then if b == args.b.* then return both(b, args.a.*)  | (x - y) + y
    if b.op is sub_ints(args) then if a == args.b.* then return both(a, args.a.*)  | x + (y - x)
  }
  case sub_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then return taco_int(a - b)
    if b.op is int(b) then if b == 0 then return a  | x - 0
  }
  case mul_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then return taco_int(a * b)
    if a.op is int(a) then if a == 1 then return b  | 1 * x
    if b.op is int(b) then if b == 1 then return a  | x * 1
  }
  case div_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return taco_int(a / b)
    if b.op is int(b) then if b == 1 then return a  | x / 1
  }
  case mod_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return taco_int(a % b)
    if b.op is int(b) then if b == 1 then return taco_int(0)  | x % 1
  }
  case and_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then return taco_int(a & b)
    if a.op is int(a) then if a == 0 then return taco_int(0)  | 0 & x
    if b.op is int(b) then if b == 0 then return taco_int(0)  | x & 0
    if a.op is int(a) then if a == -1 then return b  | -1 & x
    if b.op is int(b) then if b == -1 then return a  | x & -1
  }
  case or_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then return taco_int(or(a, b))
    if a.op is int(a) then if a == 0 then return b  | 0 | x
    if b.op is int(b) then if b == 0 then return a  | x | 0
    if a.op is int(a) then if a == -1 then return taco_int(-1)  | -1 | x
    if b.op is int(b) then if b == -1 then return taco_int(-1)  | x | -1
  }
  case xor_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then return taco_int(a ^ b)
  }
  case compare_ints(args) {
    var a = args.a.*
    var b = args.b.*
    if a.op is int(a) then if b.op is int(b) then {
      var symbol =
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater"
      return enum_(type, symbol, taco_nothing)
    }
  }
  case unbox(box) if box.op is box(inner) then return inner.*
  case generate_array(gen) {
    if gen.length.op is int(len) then if len <= 10 then {
      var items = list[TacoExpr]()
      for index in 0..len do
        items.&.push(
          gen.generator
            .fill(list(taco_int(index)).to_slice())
            .optimize_shallow(context)
        )
      return array(gen.generator.expr.type, items.to_slice())
    }
  }
  case array_get(args) {
    var array = args.a.*
    var index = args.b.*
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then return items.get(index)
  }
  case array_set(args) {
    var array = args.a.*
    var index = args.b.*
    var item  = args.c.*
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then {
        var new_items = list[TacoExpr]()
        for item in items do new_items.&.push(item)
        new_items.&.set(index, item)
        return array(type, new_items.to_slice())
      }
  }
  case array_slice(args) {
    var array = args.a.*
    var start = args.b.*
    var end = args.c.*
    if array.op is array(items) then {
      if start.op is int(start) then if end.op is int(end) then {
        if (0..items.len).contains(start) and (0..items.len).contains(end)
        then return array(type, items.subslice(start..end))
      }
    }
  }
  case array_len(array) {
    if array.op is array(items) then return taco_int(items.len)
    | TODO: generator may panic for an input
    | if array.op is generate_array(gen) then return array.children.get(0)
  }
  case recursive(recursive) {
    if not(recursive.body.expr.recurses()) then
      return recursive.body.fill(recursive.initial).optimize(context)

    | Find fixpoints
    var mask = recursive.body.find_fixpoint_mask(recursive.initial, context)
    var new_args = {
      var res = list[TacoExpr]()
      for arg in recursive.initial.mask(mask) do
        res.&.push(arg.optimize(context))
      res.to_slice()
    }
    var new_holes = {
      var res = list[Hole]()
      for arg in new_args do res.&.push(hole(arg.type))
      res.to_slice()
    }
    return recursive(
      new_args,
      body(
        new_holes,
        recursive.body
          .fill(new_holes.unmask(mask))
          .replace_recurses(mask)
          .optimize(context),
      )
    )
  }
  case recurse(args) {
    for arg in args do if arg.definitely_crashes() then return taco_crash(type)
    if args.len == 1 then if args.get(0).op is switch_(switch_) then {
      | Push recurse into the switch cases.
      return switch_(switch_.condition.*, type, {
        var cases = map[String, TacoBody]()
        for case_ in switch_.cases do
          cases.&.put(
            case_.key,
            TacoBody {
              params = case_.value.params,
              expr = recurse(list(case_.value.expr).to_slice(), type)
                .optimize_shallow(context)
            }
          )
        cases
      })
    }
  }
  default {}

  expr
}

| The number of expressions inside this expression.
fun num_exprs(expr: TacoExpr): Int {
  var num = 1
  for child in expr.children() do num = num + child.num_exprs()
  num
}

| Whether the expression contains a recurse expression that is not nested within
| a recursive expression.
fun recurses(expr: TacoExpr): Bool {
  if expr.op is recursive then return false  | An inner recurse is local.
  if expr.op is recurse then return true
  for child in expr.children() do if child.recurses() then return true
  false
}

| Converts calls to the given called signature into recurse expressions.
fun call_to_recurse(
  expr: TacoExpr, called: TacoCalledFun, return_type: EggType
): TacoExpr {
  expr.map(CallToRecurse { called, return_type })
}
fun call_to_recurse(
  body: TacoBody, called: TacoCalledFun, return_type: EggType
): TacoBody {
  body.map(CallToRecurse { called, return_type })
}
struct CallToRecurse { called: TacoCalledFun, return_type: EggType }
fun map(expr: TacoExpr, call_to_recurse: CallToRecurse): TacoExpr {
  var expr = expr.map_children(call_to_recurse)
  if expr.op is call_fun(call) then
    if call.fun_ == call_to_recurse.called then
      return recurse(call.args, call_to_recurse.return_type)
  expr
}
fun map(body: TacoBody, call_to_recurse: CallToRecurse): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(call_to_recurse) }
}

| Fills the body with concrete arguments for its parameters.
fun fill(body: TacoBody, args: Slice[TacoExpr]): TacoExpr {
  var fillings = map[Hole, TacoExpr]()
  for both in zip(body.params.iter(), args.iter()) do
    fillings.&.put(both.a, both.b)
  body.expr.map(Fill { fillings })
}
fun fill(body: TacoBody, arg: TacoExpr): TacoExpr {
  body.fill(list(arg).to_slice())
}
struct Fill { fillings: Map[Hole, TacoExpr] }
fun map(expr: TacoExpr, fill: Fill): TacoExpr {
  if expr.op is hole(hole) then
    if fill.fillings.get_maybe(hole) is some(value) then return value
  expr.map_children(fill)
}
fun map(body: TacoBody, fill: Fill): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(fill) }
}

fun specialize(body: TacoBody, substitutions: Substitutions): TacoBody {
  stderr."Specializing using {substitutions}:\n"
  stderr.write(body.expr, holes_namespace().&, no_indentation)
  stderr."\nDone specializing:\n"
  stderr.write(body.expr.map(Specialize { substitutions }), holes_namespace().&, no_indentation)
  stderr."\n"
  body.map(Specialize { substitutions })
}
struct Specialize { substitutions: Substitutions }
fun map(expr: TacoExpr, specialize: Specialize): TacoExpr {
  if expr.op is hole(hole) then
    return taco_hole(hole.specialize(specialize.substitutions))
  if expr.op is type(type) then
    return taco_type(type.specialize(specialize.substitutions))
  expr(
    expr.map_children(specialize).op,
    expr.type.specialize(specialize.substitutions),
  )
}
fun map(body: TacoBody, specialize: Specialize): TacoBody {
  TacoBody {
    params = body.params.specialize(specialize.substitutions),
    expr = body.expr.map(specialize),
  }
}


| Whether the operation itself (not the children) can diverge.
fun can_root_diverge(expr: TacoExpr): Bool {
  switch expr.op
  case hole false
  case type false
  case byte false
  case int false
  case array false
  case struct_ false
  case enum_ false
  case lambda false
  case box false
  case member false
  case switch_ true
  case call_fun true
  case call_lambda true
  case both true
  case let false
  case cast false
  case lower_byte false
  case byte_to_int false
  case add_ints false
  case sub_ints false
  case mul_ints false
  case div_ints true
  case mod_ints true
  case and_ints false
  case or_ints false
  case xor_ints false
  case compare_ints false
  case unbox false
  case generate_array true
  case array_get true
  case array_set true
  case array_slice true
  case array_len false
  case crash true
  case type_info false
  case static_to_dynamic false
  case dynamic_to_static true
  case recursive true
  case recurse true
  case unreachable true
}

fun can_diverge(expr: TacoExpr): Bool {
  expr.can_root_diverge() or {
    for child in expr.children() do if child.can_diverge() then return true
    false
  }
}

fun collect_impure(expr: TacoExpr, out: &List[TacoExpr]) {
  if expr.can_root_diverge() then 
    out.push(expr)
  else
    for child in expr.children() do child.collect_impure(out)
}

fun definitely_crashes(expr: TacoExpr): Bool {
  switch expr.op
  case lambda false
  case switch_(switch_) {
    if switch_.condition.definitely_crashes() then return true
    for case_ in switch_.cases do
      if not(case_.value.expr.definitely_crashes()) then return false
    true
  }
  case crash true
  case unreachable true
  default {
    for child in expr.children() do
      if child.definitely_crashes() then return true
    false
  }
}
