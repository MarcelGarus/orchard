import mod.mar

fun optimize(taco: Taco): Taco {
  var funs = map[String, TacoFun]()
  for signature in taco.choose_optimization_order() do {
    eprintln("Optimizing {signature}")
    | stderr.write(signature, taco.funs.get(signature))
    | eprintln()

    funs.&.put(
      signature,
      taco.funs.get(signature).optimize(OptimizeTacoContext {
        optimized = funs, taco
      })
    )

    | eprintln("Optimized")
    | stderr.write(signature, funs.get(signature))
    | eprintln()
  }
  Taco { funs, entry_point = taco.entry_point }.tree_shake()
}

fun choose_optimization_order(taco: Taco): Slice[String] {
  var rev_order = list[String]()
  taco.entry_point.signature.choose_order(taco, rev_order.&)
  var order = list[String]()
  for signature in rev_order.to_slice().rev_iter() do order.&.push(signature)
  order.to_slice()
}
fun choose_order(signature: String, taco: Taco, out: &List[String]) {
  if out.iter().&.contains(signature) then return {}
  out.push(signature)
  taco.funs.get(signature).body.choose_order(taco, out)
}
fun choose_order(expr: TacoExpr, taco: Taco, out: &List[String]) {
  if expr.op is call_fun(fun_) then fun_.signature.choose_order(taco, out)
  for child in expr.children do child.choose_order(taco, out)
}

fun tree_shake(taco: Taco): Taco {
  var funs = map[String, TacoFun]()
  for signature in taco.choose_optimization_order() do
    funs.&.put(signature, taco.funs.get(signature))
  Taco { funs, entry_point = taco.entry_point }
}

fun optimize(fun_: TacoFun, context: OptimizeTacoContext): TacoFun {
  TacoFun { params = fun_.params, body = fun_.body.optimize(context) }
}

struct OptimizeTacoContext { optimized: Map[String, TacoFun], taco: Taco }

fun optimize(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
  | stderr."Optimizing:"
  | stderr.write(expr.op, 0)
  | stderr."\n"
 
  var children = list[TacoExpr]()
  for child in expr.children do children.&.push(child.optimize(context))
  expr(expr.op, children.to_slice(), expr.type).optimize_shallow(context)
}
| Assumes that the children are already optimized.
fun optimize_shallow(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
  var type = expr.type
  var children = expr.children
  switch expr.op
  case member(name) {
    var struct_ = children.get(0)
    if struct_.op is struct_ then {
      var keys = list[String]()
      for field in struct_.type.kind().struct_.unwrap() do
        keys.&.push(field.key)
      keys.to_slice().&.sort()

      var index = 0
      loop if keys.get(index) == name then break else index = index + 1

      return struct_.children.get(index)
    }
  }
  case switch_(case_holes) {
    var condition = children.first()
    var cases = children.without_first()
    if condition.op is enum_(name) then {
      var keys = list[String]()
      for variant in condition.type.kind().enum_.unwrap() do
        keys.&.push(variant.key)
      keys.to_slice().&.sort()

      var index = 0
      loop if keys.get(index) == name then break else index = index + 1

      return cases.get(index)
        .fill(map(case_holes.get(index) -> condition.children.get(0)))
        .optimize(context)
    }
  }
  case call_fun(fun_) {
    var signature = fun_.signature
    var substitutions = fun_.substitutions
    var args = children

    | Try to run the function at compile time.
    | if
    |   fun_.call_at_comptime(args, type, EggRunResources { exprs = 1000 }, context)
    | is ok(result)
    | then return result.to_expr()

    | Possibly inline the function.
    if context.optimized.get_maybe(signature) is some(fun_) then {
      var should_inline = fun_.body.num_exprs() < 10
      if should_inline then {
        return recursive(
          fun_.params,
          args,
          fun_.body
            .specialize(substitutions)
            .new_holes()
            .call_to_recurse(signature, type),
        ).optimize_shallow(context)
      }
    }
  }
  case call_lambda {
    var lambda = children.first()
    var args = children.without_first()
    if lambda.op is lambda(params) then
      return lambda.children.get(0).fill(params, args)
  }
  case body {
    var ignored = children.without_last()
    var result  = children.last()
    var children = list[TacoExpr]()
    for child in ignored do child.collect_impure(children.&)
    if children.is_empty() then return result
    children.&.push(result)
    return body(children.to_slice())
  }
  case cast {
    var inner = children.get(0)
    if inner.type == type then return inner
    if inner.op is enum_(name) then {
      var wanted_payload_type = type.kind().enum_.unwrap().get(name)
      var payload = inner.children.get(0)
      return enum_(
        type, name, cast(payload, wanted_payload_type).optimize_shallow(context)
      )
    }
  }
  case lower_byte {
    var int = children.get(0)
    if int.op is int(int) then return taco_byte(int.lower_byte())
  }
  case byte_to_int {
    var byte = children.get(0)
    if byte.op is byte(byte) then return taco_int(byte.to_int())
  }
  case add_ints {
    var a = children.get(0)
    var b = children.get(1)
    if a.op is int(a) then if a == 0 then return b
    if b.op is int(b) then if b == 0 then return a
    if a.op is int(a) then if b.op is int(b) then return taco_int(a + b)
  }
  case sub_ints {
    var a = children.get(0)
    var b = children.get(1)
    if b.op is int(b) then if b == 0 then return a
    if a.op is int(a) then if b.op is int(b) then return taco_int(a - b)
  }
  case mul_ints {
    var a = children.get(0)
    var b = children.get(1)
    if a.op is int(a) then if a == 1 then return b
    if b.op is int(b) then if b == 1 then return a
    if a.op is int(a) then if b.op is int(b) then return taco_int(a * b)
  }
  case div_ints {
    var a = children.get(0)
    var b = children.get(1)
    if b.op is int(b) then if b == 1 then return a
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return taco_int(a / b)
  }
  case mod_ints {
    var a = children.get(0)
    var b = children.get(1)
    if b.op is int(b) then if b == 1 then return taco_int(0)
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return taco_int(a % b)
  }
  case and_ints {
    var a = children.get(0)
    var b = children.get(1)
    if a.op is int(a) then if a == 0 then return taco_int(0)
    if b.op is int(b) then if b == 0 then return taco_int(0)
    if a.op is int(a) then if a == -1 then return b
    if b.op is int(b) then if b == -1 then return a
    if a.op is int(a) then if b.op is int(b) then return taco_int(a & b)
  }
  case or_ints {
    var a = children.get(0)
    var b = children.get(1)
    if a.op is int(a) then if a == 0 then return b
    if b.op is int(b) then if b == 0 then return a
    if a.op is int(a) then if a == -1 then return taco_int(-1)
    if b.op is int(b) then if b == -1 then return taco_int(-1)
    if a.op is int(a) then if b.op is int(b) then return taco_int(or(a, b))
  }
  case xor_ints {
    var a = children.get(0)
    var b = children.get(1)
    if a.op is int(a) then if b.op is int(b) then return taco_int(a ^ b)
  }
  case compare_ints {
    var a = children.get(0)
    var b = children.get(1)
    if a.op is int(a) then if b.op is int(b) then {
      var symbol =
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater"
      return enum_(type, symbol, taco_nothing)
    }
  }
  case unbox {
    var box = children.get(0)
    if box.op is box then return box.children.get(0)
  }
  case generate_array {
    var len = children.get(0)
    var generator = children.get(1)
    var item_type = generator.type.kind().lambda.unwrap().return_type
    if len.op is int(len) then if len <= 10 then {
      var items = list[TacoExpr]()
      for index in 0..len do
        items.&.push(
          generator.call(list(taco_int(index)).to_slice())
            .optimize_shallow(context)
        )
      return array(item_type, items.to_slice())
    }
  }
  case array_get {
    var array = children.get(0)
    var index = children.get(1)
    if array.op is array then if index.op is int(index) then
      if (0..array.children.len).contains(index) then
        return array.children.get(index)
  }
  case array_set {
    var array = children.get(0)
    var index = children.get(1)
    var item  = children.get(2)
    if array.op is array then if index.op is int(index) then
      if (0..array.children.len).contains(index) then {
        var new_items = list[TacoExpr]()
        for item in array.children do new_items.&.push(item)
        new_items.&.set(index, item)
        return array(type, new_items.to_slice())
      }
  }
  case array_slice {
    var array = children.get(0)
    var range = children.get(1)
    if array.op is array then if range.op is struct_ then {
      var items = array.children
      var end = range.children.get(0)
      var start = range.children.get(1)
      if start.op is int(start) then if end.op is int(end) then {
        if (0..items.len).contains(start) and (0..items.len).contains(end)
        then return array(type, items.subslice(start..end))
      }
    }
  }
  case array_len {
    var array = children.get(0)
    if array.op is array then return taco_int(array.children.len)
    if array.op is generate_array then return array.children.get(0)
  }
  case recursive(holes) {
    var args = children.without_last()
    var body = children.last()
    if not(body.recurses()) then return body.fill(holes, args).optimize(context)
    
    | Find fixpoints
    var fixpoints = body.find_fixpoints(holes, args, context)
    var new_args = args.values_for_black_holes(fixpoints)
    var new_holes = list[Hole]()
    for arg in new_args do new_holes.&.push(hole(arg.type))
    var new_holes = new_holes.to_slice()
    var expr = recursive(
      new_holes,
      new_args,
      body
        .fill(holes, fixpoints.fill_black_holes(new_holes))
        .replace_recurses(fixpoints)
        .optimize(context),
    )
    | eprintln("Optimized recursive:")
    | stderr.write(expr, holes_namespace().&, indentation(0))
    | eprintln()
    return expr
  }
  case buffer_of_array {
    var array = children.get(0)
    if array.op is array_from_buffer then return array.children.get(0)
  }
  case start_of_array {
    var array = children.get(0)
    if array.op is array_from_buffer then return array.children.get(1)
  }
  case end_of_array {
    var array = children.get(0)
    if array.op is array_from_buffer then return array.children.get(2)
  }
  default {}

  expr
}

fun num_exprs(expr: TacoExpr): Int {
  var num = 0
  for child in expr.children do num = num + child.num_exprs()
  num
}

fun recurses(expr: TacoExpr): Bool {
  if expr.op is recursive then return false  | An inner recurse is local.
  if expr.op is recurse then return true
  for child in expr.children do if child.recurses() then return true
  false
}

fun call_to_recurse(
  expr: TacoExpr, signature: String, return_type: EggType
): TacoExpr {
  var args = list[TacoExpr]()
  for arg in expr.children do
    args.&.push(arg.call_to_recurse(signature, return_type))
  var args = args.to_slice()

  if expr.op is call_fun(fun_) then
    if fun_.signature == signature then
      return recurse(args, return_type)
  expr(expr.op, args, expr.type)
}

fun fill(
  expr: TacoExpr, holes: Slice[Hole], fillings: Slice[TacoExpr]
): TacoExpr {
  var map = map[Hole, TacoExpr]()
  for both in zip(holes.iter(), fillings.iter()) do map.&.put(both.a, both.b)
  expr.fill(map)
}
fun fill(expr: TacoExpr, fillings: Map[Hole, TacoExpr]): TacoExpr {
  if expr.op is hole(hole) then
    if fillings.get_maybe(hole) is some(value) then return value
  
  var children = list[TacoExpr]()
  for child in expr.children do children.&.push(child.fill(fillings))
  expr(expr.op, children.to_slice(), expr.type)
}

fun specialize(expr: TacoExpr, substitutions: Substitutions): TacoExpr {
  var op =
    switch expr.op
    case type(type) TacoOp.type(type.specialize(substitutions))
    case lambda(holes) TacoOp.lambda(holes.specialize(substitutions))
    case switch_(holes) TacoOp.switch_(holes.specialize(substitutions))
    default expr.op

  var children = list[TacoExpr]()
  for child in expr.children do children.&.push(child.specialize(substitutions))
  var children = children.to_slice()

  var type = expr.type.specialize(substitutions)

  expr(op, children, type)
}

fun collect_impure(expr: TacoExpr, out: &List[TacoExpr]) {
  | Default behavior: Collect child expressions.
  var can_diverge =
    switch expr.op
    case hole false
    case type false
    case byte false
    case int false
    case array false
    case struct_ false
    case enum_ false
    case lambda false
    case box false
    case member false
    case switch_ true
    case call_fun true
    case call_lambda true
    case body false
    case cast false
    case lower_byte false
    case byte_to_int false
    case add_ints false
    case sub_ints false
    case mul_ints false
    case div_ints true
    case mod_ints true
    case and_ints false
    case or_ints false
    case xor_ints false
    case compare_ints false
    case unbox false
    case generate_array true
    case array_get true
    case array_set true
    case array_slice true
    case array_len false
    case crash true
    case type_info false
    case static_to_dynamic false
    case dynamic_to_static true
    case unreachable true
    case recursive true
    case recurse true
    case create_buffer false
    case buffer_set false
    case buffer_get false
    case buffer_len false
    case array_from_buffer false
    case buffer_of_array false
    case start_of_array false
    case end_of_array false

  if can_diverge then 
    out.push(expr)
  else
    for child in expr.children do child.collect_impure(out)
}

| fun optimized_member(builder: &EggBodyBuilder, of: EggExpr, name: String): EggExpr {
|   if of.op is struct_(fields)
|   then fields.get(name)
|   else EggOp.member(EggMember { of, name })
| }

| fun call_at_comptime(
|   fun_: EggCalledFun, args: Slice[EggExpr], type: EggType,
|   resources: EggRunResources, context: OptimizeTacoContext,
| ): Result[EggComptimeValue, Nothing] {
|   var arg_values = list[EggComptimeValue]()
|   for arg in args do
|     arg_values.&.push(
|       arg.to_comptime() or return error[EggComptimeValue, Nothing]({})
|     )
|   var arg_values = arg_values.to_slice()

|   fun_.run(
|     arg_values,
|     RunEggContext { egg = context.fun_.egg, resources = resources.& },
|   )
| }
