import mod.mar

fun optimize(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  for signature in taco.choose_optimization_order() do {
    | eprintln("Optimizing {signature}")
    | stderr.write(signature, taco.funs.get(signature))
    | eprintln()

    funs.&.put(
      signature,
      taco.funs.get(signature).optimize(OptimizeTacoContext {
        optimized = funs, taco
      })
    )

    | eprintln("Optimized")
    | stderr.write(signature, funs.get(signature))
    | eprintln()
  }
  Taco { funs, entry_point = taco.entry_point }.tree_shake()
}

fun choose_optimization_order(taco: Taco): Slice[String] {
  var rev_order = list[String]()
  taco.entry_point.signature.choose_order(taco, rev_order.&)
  var order = list[String]()
  for signature in rev_order.to_slice().rev_iter() do order.&.push(signature)
  order.to_slice()
}
fun choose_order(signature: String, taco: Taco, out: &List[String]) {
  if out.iter().&.contains(signature) then return {}
  out.push(signature)
  taco.funs.get(signature).expr.visit(ChooseOrder { taco, out }).ignore()
}
struct ChooseOrder { taco: Taco, out: &List[String] }
fun visit(expr: TacoExpr, choose: ChooseOrder) {
  if expr.op is call_fun(call) then
    call.fun_.signature.choose_order(choose.taco, choose.out)
  expr.visit_children(choose)
}
fun visit(body: TacoBody, choose: ChooseOrder) {
  body.expr.visit(choose)
}

fun tree_shake(taco: Taco): Taco {
  var funs = map[String, TacoBody]()
  for signature in taco.choose_optimization_order() do
    funs.&.put(signature, taco.funs.get(signature))
  Taco { funs, entry_point = taco.entry_point }
}

struct OptimizeTacoContext { optimized: Map[String, TacoBody], taco: Taco }
struct Optimize { context: OptimizeTacoContext }
fun map(expr: TacoExpr, optimize: Optimize): TacoExpr {
  expr.map_children(optimize).optimize_shallow(optimize.context)
}
fun map(body: TacoBody, optimize: Optimize): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(optimize) }
}
fun optimize(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
  expr.map(Optimize { context })
}
fun optimize(body: TacoBody, context: OptimizeTacoContext): TacoBody {
  body.map(Optimize { context })
}

| Assumes that the children are already optimized.
fun optimize_shallow(expr: TacoExpr, context: OptimizeTacoContext): TacoExpr {
  var type = expr.type
  switch expr.op
  case member(member) {
    | Bubble up crashes and both.
    if member.of.op is crash then return taco_crash(type)
    if member.of.op is both(both) then
      return both(
        both.a.*, member(both.b.*, member.name).optimize_shallow(context)
      ).optimize_shallow(context)

    | Constant fold members of known structs.
    | TODO: Keep the other fields for side effects.
    | 
    | member foo    | both
    |   &           |   hole b
    |     foo:      |   hole a
    |       hole a  |
    |     bar:      |
    |       hole b  |
    if member.of.op is struct_(fields) then return fields.get(member.name)
  }
  case switch_(switch_) {
    | Bubble up crashes and both.
    if switch_.condition.op is crash then return taco_crash(type)
    if switch_.condition.op is both(both) then
      return both(
        both.a.*,
        switch_(both.b.*, type, switch_.cases).optimize_shallow(context),
      ).optimize_shallow(context)

    | Constant fold switches of known variants.
    if switch_.condition.op is enum_(enum_) then {
      return switch_.cases.get(enum_.variant)
        .fill(enum_.payload.*)
        .optimize(context)
    }

    | If all expressions that don't crash or are unreachable are the same and
    | don't depend on parameters, pull them out of the switch. This then allows
    | the surrounding expressions to bubble up the "both", leaving a simpler,
    | constant-foldable expression.
    |
    | add           | add             | both
    |   switch      |   both          |   switch
    |     hole a    |     switch      |     hole a
    |     true b:   |       hole a    |     true b:
    |       crash   |       true b:   |       crash
    |     false c:  |         crash   |     false c:
    |       int 3   |       false c:  |       &
    |   int 2       |         &       |   add
    |               |     int 3       |     int 3
    |               |   int 2         |     int 2
    var non_diverging_cases = list[MapEntry[String, TacoBody]]()
    for case_ in switch_.cases do {
      var diverges =
        {case_.value.expr.op is crash} or {case_.value.expr.op is unreachable}
      if not(diverges) then non_diverging_cases.&.push(case_)
    }
    if non_diverging_cases.is_not_empty() then {
      var all_the_same = true
      var common = non_diverging_cases.get(0).value.expr
      for case_ in non_diverging_cases do
        if case_.value.expr != common then all_the_same = false
      if all_the_same and common != taco_nothing then {
        return both(
          switch_(switch_.condition.*, expr.type, {
            var new_cases = map[String, TacoBody]()
            for case_ in switch_.cases do
              new_cases.&.put(
                case_.key,
                body(
                  case_.value.params,
                  if case_.value.expr == common
                  then taco_nothing
                  else case_.value.expr.op.expr(type_nothing),
                ),
              )
            new_cases
          }),
          common,
        ).optimize_shallow(context)
      }
    }

    if switch_.condition.op is switch_(inner_switch) then {
      | Consider inlining the outer switch into the cases of the inner switch.
      | var max_outer_case_complexity = 0
      | for case_ in switch_.cases do
      |   max_outer_case_complexity =
      |     max(max_outer_case_complexity, case_.value.expr.num_exprs())
      | if max_outer_case_complexity == 1 then {
      |   return switch_(inner_switch.condition.*, expr.type, {
      |     var new_cases = map[String, TacoBody]()
      |     for case_ in inner_switch.cases do
      |       new_cases.&.put(
      |         case_.key,
      |         body(
      |           case_.value.params,
      |           switch_(case_.value.expr, expr.type, switch_.cases)
      |             .optimize_shallow(context),
      |         ),
      |       )
      |     new_cases
      |   })
      | }
    }
  }
  case call_fun(call) {
    | TODO: Try to run the function at compile time.

    | Inline the function, if:
    | - The function has already been visited during the optimization pass.
    |   Otherwise, mutually recursive functions might hang the compiler.
    | - The function size fits in some upper bound.
    |   Otherwise, we may get exponential code explosion.
    | - The function is not generic.
    |   Otherwise, the function might call itself with different type arguments
    |   and we can't model that, not even using a recursive expression. After
    |   monomorphization, no generic functions exist, so every function has a
    |   chance of being inlined eventually.
    | TODO: example
    if call.fun_.substitutions.substitutions.size == 0 then
      if context.optimized.get_maybe(call.fun_.signature) is some(body) then {
        var should_inline = body.expr.num_exprs() <= 30
        if should_inline then {
          return recursive(
            call.args,
            body
              .specialize(call.fun_.substitutions)
              .new_holes()
              .call_to_recurse(
                call.fun_, type.specialize(call.fun_.substitutions)
              ),
          ).optimize_shallow(context)
        }
      }
  }
  case call_lambda(call) {
    | TODO: Bubble up crashes and both.

    | Constant fold calls of lambda literals.
    | 
    | call lambda   | add
    |   lambda a:   |   int 3
    |     add       |   hole b
    |       hole a  |
    |       hole b  |
    |   int 3       |
    if call.lambda.op is lambda(body) then return body.fill(call.args)
  }
  case both(both) {
    if both.a.*.op is unreachable then return taco_unreachable(expr.type)
    if both.a.*.op is crash then return taco_crash(expr.type)
    if both.b.*.op is crash then return taco_crash(expr.type)

    | Keep only the impure parts of the ignored expression.
    | 
    | both                 | both
    |   &                  |   call maycrash
    |     foo:             |   int 2
    |       call maycrash  |
    |   int 2
    var impure = list[TacoExpr]()
    both.a.collect_impure(impure.&)
    var result = both.b.*
    for child in impure.to_slice().rev_iter() do result = both(child, result)
    return result
  }
  case let {
    | TODO: is this needed? if yes, do so. if not, write something
    panic("optimize let")
  }
  case cast(inner) {
    | TODO: Bubble up crashes and both.
    
    | Remove unnecessary casts.
    |
    | cast Int  |  int 2
    |   int 2   |
    if inner.type == type then return inner.*

    | Instead of casting enums, construct them directly with the correct type.
    | 
    | cast (| none: (&) some: (Int))  | | none:  (| none: (&) some: (Int))
    |   | none:  (| none: (&))        |     &
    |       &                         |
    if inner.op is enum_(enum_) then {
      var wanted_payload_type = type.kind().enum_.unwrap().get(enum_.variant)
      return enum_(
        type,
        enum_.variant,
        enum_.payload.cast(wanted_payload_type).optimize_shallow(context),
      )
    }
  }
  case lower_byte(int) {
    | TODO: Bubble up crashes and both.

    | Constant fold lower bytes of ints.
    | TODO: Example
    if int.op is int(int) then return taco_byte(int.lower_byte())
  }
  case byte_to_int(byte) {
    | TODO: Bubble up crashes and both.

    if byte.op is byte(byte) then return taco_int(byte.to_int())
  }
  case add(args) {
    var a = args.a.*
    var b = args.b.*

    | Bubble up crashes and both.
    if a.op is crash then return taco_crash(type)
    if b.op is crash then return taco_crash(type)
    if a.op is both(both) then
      return both(
        both.a.*, add(both.b.*, b).optimize_shallow(context)
      ).optimize_shallow(context)
    if b.op is both(both) then
      return both(
        both.a.*, add(a, both.b.*).optimize_shallow(context)
      ).optimize_shallow(context)

    | Constant fold addition.
    if a.op is int(a) then if b.op is int(b) then return taco_int(a + b)
    if a.op is int(a) then if a == 0 then return b  | 0 + x
    if b.op is int(b) then if b == 0 then return a  | x + 0
    if a.op is subtract(args) then
      if b == args.b.* then
        return both(b, args.a.*).optimize_shallow(context)  | (x - y) + y
    if b.op is subtract(args) then
      if a == args.b.* then
        return both(a, args.a.*).optimize_shallow(context)  | x + (y - x)
  }
  case subtract(args) {
    var a = args.a.*
    var b = args.b.*
    | TODO: Bubble up crashes and both.
    if a.op is int(a) then if b.op is int(b) then return taco_int(a - b)
    if b.op is int(b) then if b == 0 then return a  | x - 0
  }
  case multiply(args) {
    var a = args.a.*
    var b = args.b.*
    | TODO: Bubble up crashes and both.
    if a.op is int(a) then if b.op is int(b) then return taco_int(a * b)
    if a.op is int(a) then if a == 1 then return b  | 1 * x
    if b.op is int(b) then if b == 1 then return a  | x * 1
  }
  case divide(args) {
    var a = args.a.*
    var b = args.b.*
    | TODO: Bubble up crashes and both.
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return taco_int(a / b)
    if b.op is int(b) then if b == 1 then return a  | x / 1
  }
  case modulo(args) {
    var a = args.a.*
    var b = args.b.*
    | TODO: Bubble up crashes and both.
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return taco_int(a % b)
    if b.op is int(b) then if b == 1 then return taco_int(0)  | x % 1
  }
  case and_(args) {
    var a = args.a.*
    var b = args.b.*
    | TODO: Bubble up crashes and both.
    if a.op is int(a) then if b.op is int(b) then return taco_int(a & b)
    if a.op is int(a) then if a == 0 then return taco_int(0)  | 0 & x
    if b.op is int(b) then if b == 0 then return taco_int(0)  | x & 0
    if a.op is int(a) then if a == -1 then return b  | -1 & x
    if b.op is int(b) then if b == -1 then return a  | x & -1
  }
  case or_(args) {
    var a = args.a.*
    var b = args.b.*
    | TODO: Bubble up crashes and both.
    if a.op is int(a) then if b.op is int(b) then return taco_int(or(a, b))
    if a.op is int(a) then if a == 0 then return b  | 0 | x
    if b.op is int(b) then if b == 0 then return a  | x | 0
    if a.op is int(a) then if a == -1 then return taco_int(-1)  | -1 | x
    if b.op is int(b) then if b == -1 then return taco_int(-1)  | x | -1
  }
  case xor(args) {
    var a = args.a.*
    var b = args.b.*
    | TODO: Bubble up crashes and both.
    if a.op is int(a) then if b.op is int(b) then return taco_int(a ^ b)
  }
  case compare(args) {
    var a = args.a.*
    var b = args.b.*

    | Bubble up crashes and both.
    if a.op is crash then return taco_crash(type)
    if b.op is crash then return taco_crash(type)
    if a.op is both(both) then
      return both(both.a.*, compare(both.b.*, b).optimize_shallow(context)).optimize_shallow(context)
    if b.op is both(both) then
      return both(both.a.*, compare(a, both.b.*).optimize_shallow(context)).optimize_shallow(context)

    | TODO: Docs.
    if a.op is int(a) then if b.op is int(b) then {
      var symbol =
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater"
      return enum_(type, symbol, taco_nothing)
    }
  }
  case unbox(box) {
    | TODO: Bubble up crashes and both.
    | TODO: Document
    if box.op is box(inner) then return inner.*
  }
  case generate_array(gen) {
    | TODO: Bubble up crashes and both.
    | TODO: Docs.
    if gen.a.op is int(len) then if len <= 10 then {
      var items = list[TacoExpr]()
      for index in 0..len do
        items.&.push(
          gen.b
            .fill(list(taco_int(index)).to_slice())
            .optimize_shallow(context)
        )
      return array(gen.b.expr.type, items.to_slice())
    }
  }
  case array_get(args) {
    var array = args.a.*
    var index = args.b.*
    | TODO: Bubble up crashes and both.
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then return items.get(index)
  }
  case array_set(args) {
    var array = args.a.*
    var index = args.b.*
    var item  = args.c.*
    | TODO: Bubble up crashes and both.
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then {
        var new_items = list[TacoExpr]()
        for item in items do new_items.&.push(item)
        new_items.&.set(index, item)
        return array(type, new_items.to_slice())
      }
  }
  case array_slice(args) {
    var array = args.a.*
    var start = args.b.*
    var end = args.c.*
    | TODO: Bubble up crashes and both.
    switch array.op
    case array(items) {
      if start.op is int(start) then if end.op is int(end) then {
        if (0..items.len).contains(start) and (0..items.len).contains(end)
        then return array(type, items.subslice(start..end))
      }
    }
    case array_slice(inner_args) {
      var inner_array = inner_args.a.*
      var inner_start = inner_args.b.*
      var inner_end = inner_args.c.*

      | TODO: Bubble up crashes and both.

      | Merge the two nested slice operations into one. This requires explicitly
      | performing the checks that the inner slice would have done.
      return array_slice(
        inner_array,
        if_(
          compare(inner_start, taco_int(0)).optimize_shallow(context)
            .is_less().optimize_shallow(context),
          taco_crash(type_int),
          add(inner_start, start).optimize_shallow(context),
        ).optimize_shallow(context),
        if_(
          compare(
            inner_end, array_len(inner_array).optimize_shallow(context)
          ).optimize_shallow(context).is_less_equal().optimize_shallow(context),
          add(inner_start, end).optimize_shallow(context),
          taco_crash(type_int),
        ).optimize_shallow(context),
      )
    }
    default {}
  }
  case array_len(array) {
    | TODO: Bubble up crashes and both.
    switch array.op
    case array(items) return taco_int(items.len)
    case generate_array(gen) {
      | The generator may panic for an index, so we need to call it with the
      | original indices.
      return both(
        recursive(list(taco_int(0)).to_slice(), {
          var index = gen.b.params.get(0)
          body(index, both(
            gen.b.expr,
            if_(
              compare(taco_hole(index), gen.a.*).is_equal(),
              taco_nothing,
              recurse(
                list(add(taco_hole(index), taco_int(1))).to_slice(),
                type_nothing,
              ),
            )
          ).optimize_shallow(context))
        }),
        gen.a.*,
      ).optimize_shallow(context)
    }
    case array_slice(args) {
      var array = args.a.*
      var start = args.b.*
      var end = args.c.*

      | TODO: Bubble up crashes and both.

      | We can calculate the length from the slice bounds. We must also perform
      | bounds checking, just like the array slice function would have done.
      return both(
        if_(
          compare(start, taco_int(0)).is_less(),
          taco_crash(type_nothing),
          if_(
            compare(end, array_len(array)).is_greater(),
            taco_crash(type_nothing),
            taco_nothing,
          ),
        ),
        subtract(end, start),
      ).optimize_shallow(context)
    }
    default {}
  }
  case recursive(rec) {
    | TODO: Bubble up crashes and both.

    if not(rec.b.expr.recurses()) then
      return rec.b.fill(rec.a).optimize(context)

    | Find fixpoints
    var mask = rec.b.find_fixpoint_mask(rec.a, context)
    var new_args = {
      var res = list[TacoExpr]()
      for arg in rec.a.mask(mask) do res.&.push(arg.optimize(context))
      res.to_slice()
    }
    var new_holes = {
      var res = list[Hole]()
      for arg in new_args do res.&.push(hole(arg.type))
      res.to_slice()
    }
    return recursive(
      new_args,
      body(
        new_holes,
        rec.b
          .fill(new_holes.unmask(mask))
          .optimize(context)
          .replace_recurses(mask),
      )
    )
  }
  case recurse(args) {
    | Bubble up crashes and both.
    for arg in args do if arg.op is crash then return taco_crash(type)
    for arg in args.iter().enumerate() do if arg.item.op is both(both) then {
      var new_args = list[TacoExpr]()
      for i in 0..args.len do
        new_args.&.push(if i == arg.index then both.b.* else args.get(i))
      return both(
        both.a.*,
        recurse(new_args.to_slice(), expr.type).optimize_shallow(context),
      ).optimize_shallow(context)
    }

    | Push recurse into switch cases.
    if args.len == 1 then if args.get(0).op is switch_(switch_) then {
      return switch_(switch_.condition.*, type, {
        var cases = map[String, TacoBody]()
        for case_ in switch_.cases do
          cases.&.put(
            case_.key,
            TacoBody {
              params = case_.value.params,
              expr = recurse(list(case_.value.expr).to_slice(), type)
                .optimize_shallow(context)
            }
          )
        cases
      })
    }
  }
  default {}

  expr
}

| The number of expressions inside this expression.
fun num_exprs(expr: TacoExpr): Int {
  var num = 1
  for child in expr.children() do num = num + child.num_exprs()
  num
}

| Whether the expression contains a recurse expression that is not nested within
| a recursive expression.
fun recurses(expr: TacoExpr): Bool {
  if expr.op is recursive then return false  | An inner recurse is local.
  if expr.op is recurse then return true
  for child in expr.children() do if child.recurses() then return true
  false
}

| Converts calls to the given called signature into recurse expressions.
fun call_to_recurse(
  expr: TacoExpr, called: TacoCalledFun, return_type: EggType
): TacoExpr {
  expr.map(CallToRecurse { called, return_type })
}
fun call_to_recurse(
  body: TacoBody, called: TacoCalledFun, return_type: EggType
): TacoBody {
  body.map(CallToRecurse { called, return_type })
}
struct CallToRecurse { called: TacoCalledFun, return_type: EggType }
fun map(expr: TacoExpr, call_to_recurse: CallToRecurse): TacoExpr {
  var expr = expr.map_children(call_to_recurse)
  if expr.op is call_fun(call) then
    if call.fun_ == call_to_recurse.called then
      return recurse(call.args, call_to_recurse.return_type)
  expr
}
fun map(body: TacoBody, call_to_recurse: CallToRecurse): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(call_to_recurse) }
}

| Fills the body with concrete arguments for its parameters.
fun fill(body: TacoBody, args: Slice[TacoExpr]): TacoExpr {
  var fillings = map[Hole, TacoExpr]()
  for both in zip(body.params.iter(), args.iter()) do
    fillings.&.put(both.a, both.b)
  body.expr.fill(fillings)
}
fun fill(body: TacoBody, arg: TacoExpr): TacoExpr {
  body.fill(list(arg).to_slice())
}
fun fill(expr: TacoExpr, fillings: Map[Hole, TacoExpr]): TacoExpr {
  expr.map(Fill { fillings })
}
struct Fill { fillings: Map[Hole, TacoExpr] }
fun map(expr: TacoExpr, fill: Fill): TacoExpr {
  if expr.op is hole(hole) then
    if fill.fillings.get_maybe(hole) is some(value) then return value
  expr.map_children(fill)
}
fun map(body: TacoBody, fill: Fill): TacoBody {
  TacoBody { params = body.params, expr = body.expr.map(fill) }
}

fun specialize(body: TacoBody, substitutions: Substitutions): TacoBody {
  stderr."Specializing using {substitutions}:\n"
  stderr.write(body.expr, holes_namespace().&, no_indentation)
  stderr."\nDone specializing:\n"
  stderr.write(body.expr.map(Specialize { substitutions }), holes_namespace().&, no_indentation)
  stderr."\n"
  body.map(Specialize { substitutions })
}
struct Specialize { substitutions: Substitutions }
fun map(expr: TacoExpr, specialize: Specialize): TacoExpr {
  if expr.op is hole(hole) then
    return taco_hole(hole.specialize(specialize.substitutions))
  if expr.op is type(type) then
    return taco_type(type.specialize(specialize.substitutions))
  expr(
    expr.map_children(specialize).op,
    expr.type.specialize(specialize.substitutions),
  )
}
fun map(body: TacoBody, specialize: Specialize): TacoBody {
  TacoBody {
    params = body.params.specialize(specialize.substitutions),
    expr = body.expr.map(specialize),
  }
}


fun collect_captured(expr: TacoExpr): Slice[Hole] {
  var out = set[Hole]()
  expr.visit(CollectCaptured { ignore = set[Hole]().&, out = out.& })
  var res = list[Hole]()
  for hole in out do res.&.push(hole)
  res.to_slice()
}
fun collect_captured(body: TacoBody): Slice[Hole] {
  var out = set[Hole]()
  body.visit(CollectCaptured { ignore = set[Hole]().&, out = out.& })
  var res = list[Hole]()
  for hole in out do res.&.push(hole)
  res.to_slice()
}
struct CollectCaptured { ignore: &Set[Hole], out: &Set[Hole] }
fun visit(expr: TacoExpr, collect_captured: CollectCaptured) {
  if expr.op is hole(hole) then
    if not(collect_captured.ignore.contains(hole)) then
      collect_captured.out.put(hole)
  expr.visit_children(collect_captured)
}
fun visit(body: TacoBody, collect_captured: CollectCaptured) {
  for param in body.params do collect_captured.ignore.put(param)
  body.expr.visit(collect_captured)
}


| Whether the operation itself (not the children) can diverge.
fun can_root_diverge(expr: TacoExpr): Bool {
  switch expr.op
  case hole false
  case type false
  case byte false
  case int false
  case array false
  case struct_ false
  case enum_ false
  case lambda false
  case box false
  case member false
  case switch_ true
  case call_fun true
  case call_lambda true
  case both true
  case let false
  case cast false
  case lower_byte false
  case byte_to_int false
  case add false
  case subtract false
  case multiply false
  case divide true
  case modulo true
  case and_ false
  case or_ false
  case xor false
  case compare false
  case unbox false
  case generate_array true
  case array_get true
  case array_set true
  case array_slice true
  case array_len false
  case crash true
  case type_info false
  case static_to_dynamic false
  case dynamic_to_static true
  case recursive true
  case recurse true
  case unreachable true
}

fun can_diverge(expr: TacoExpr): Bool {
  expr.can_root_diverge() or {
    for child in expr.children() do if child.can_diverge() then return true
    false
  }
}

fun collect_impure(expr: TacoExpr, out: &List[TacoExpr]) {
  if expr.can_root_diverge() then 
    out.push(expr)
  else
    for child in expr.children() do child.collect_impure(out)
}
