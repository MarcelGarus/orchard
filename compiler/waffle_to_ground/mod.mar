import ../plum.mar
import builder.mar

fun to_ground(waffle: Waffle): Ground {
  var instructions = list[GroundInstruction]()
  var signature_to_offset = map[String, Int]()
  var patches = list[Patch]()
  var builder = GroundBuilder {
    instructions = instructions.&, patches = patches.&, waffle
  }

  var entry_point = "workspace/test/playground.main Int"
  signature_to_offset.&.put(entry_point, 0)
  waffle.funs.get(entry_point).compile(builder.&)

  for fun_ in waffle.funs do {
    if fun_.key == entry_point then continue
    signature_to_offset.&.put(fun_.key, instructions.len)
    fun_.value.compile(builder.&)
  }

  for patch in patches do {
    var patched =
      switch patch.what
      case call(target) GroundInstruction.call(signature_to_offset.get(target))
      case push_indirect(target)
        GroundInstruction.push_indirect(signature_to_offset.get(target))
    instructions.&.set(patch.where, patched)
  }

  Ground { instructions = instructions.to_slice() }
}
fun compile(fun_: WaffleFun, builder: &GroundBuilder) {
  var params = id(0)
  var builder = FunGroundBuilder {
    instructions = builder.instructions, patches = builder.patches,
    stack_mapping = map[Id, Int](), stack_size = 0,
    fun_, waffle = builder.waffle,
  }.&

  | Now, the stack contains the params.
  fun_.body.compile(builder)
  | Now, the stack contains the return value.
  builder.return_()
}
fun compile(body: WaffleBody, builder: &FunGroundBuilder) {
  var stack_size_at_body_start = builder.stack_size

  for local in body.locals do {
    var expr = builder.fun_.dag.get(local)
    builder.align_to(expr.alignment)
    builder.add_mapping(local, builder.stack_size)
    expr.compile(builder)
    builder.stack_size >= builder.stack_mapping.get(local) or
      panic("removed too much from the stack")
  }

  builder.align_to(body.returns.alignment)
  var locals_size = builder.stack_size - stack_size_at_body_start
  body.returns.compile(builder)

  var return_value_size = body.returns.size

  builder.pop_below_top(return_value_size, locals_size)
}

| Compiles an expression. Assumes that the stack is already aligned for the
| expression.
fun compile(expr: WaffleExpr, builder: &FunGroundBuilder) {
  switch expr.kind
  case param builder.stack_size = builder.stack_size + expr.size
  case padding(amount) builder.push_padding(amount)
  case byte(byte) builder.push_1(byte)
  case int(int) builder.push_8(int)
  case local(local) builder.copy_from_stack(local, expr.size)
  case aggregate(aggregate) for field in aggregate do field.compile(builder)
  case member(member) {
    | Quite often, you see things like @0.0:8 in the Waffle â€“ for example, if
    | we have an aggregate representing the arguments of a function and we want
    | to get a single argument, we extract that argument.
    | Lowering this in a naive way (first lowering @0, then lowering the member
    | access) leads to crazy amounts of copying: We copy the entire local
    | aggregate to the top of the stack, just to then discard the majority to
    | extract the field we want.
    | So, here, we special-case that pattern.
    if member.of.kind is local(local) then {
      builder.copy_from_stack(
        builder.stack_mapping.get(local) + member.offset,
        expr.size,
      )
    } else {
      var padding = builder.align_to(member.of.alignment)
      member.of.compile(builder)
      var amount_before_member = padding + member.offset
      var amount_after_member  = member.of.size - expr.size - member.offset
      builder.pop(amount_after_member)
      builder.pop_below_top(expr.size, amount_before_member)
    }
  }
  case switch_(switch_) {
    switch_.byte.compile(builder)

    var jump_table_index = builder.jump_table_placeholder()
    var stack_size_at_start_of_case = builder.stack_size

    var table = list[Int]()
    var end_jumps = list[Int]()
    for case_ in switch_.cases do {
      table.&.push(builder.instructions.len)
      builder.stack_size = stack_size_at_start_of_case
      case_.compile(builder)
      end_jumps.&.push(builder.jump_placeholder())
    }
    var end = builder.instructions.len
    for jump in end_jumps do builder.patch_jump(jump, end)
    builder.patch_jump_table(jump_table_index, table.to_slice())
  }
  case call(call) {
    var padding = builder.align_to(call.args.alignment)
    call.args.compile(builder)
    builder.call(call.function, 0 - call.args.size + expr.size)
    builder.pop_below_top(expr.size, padding)
  }
  case call_indirect(call) {
    var padding = builder.align_to(call.args.alignment)
    call.args.compile(builder)
    var more_padding = builder.align_to(8)
    call.function_ptr.compile(builder)
    var stack_diff = 0
      - more_padding   | the function consumes the padding. TODO: Does it?
      - call.args.size | as well as the arguments
      + expr.size      | and pushes its result
    builder.call_indirect(stack_diff)
    builder.pop_below_top(expr.size, padding)
  }
  case function_ptr(signature) builder.push_indirect(signature)
  case add(args)         { args.compile(builder)  builder.add_8() }
  case sub(args)         { args.compile(builder)  builder.sub_8() }
  case mul(args)         { args.compile(builder)  builder.mul_8() }
  case div(args)         { args.compile(builder)  builder.div_8() }
  case mod(args)         { args.compile(builder)  builder.mod_8() }
  case compare_zero(arg) { arg.compile(builder)   builder.compare_zero_8() }
  case and_(args)        { args.compile(builder)  builder.and_8() }
  case or_(args)         { args.compile(builder)  builder.or_8() }
  case xor(args)         { args.compile(builder)  builder.xor_8() }
  case malloc(size) {
    size.compile(builder)
    builder.push_1(8.lower_byte())
    builder.malloc()
  }
  case free(free) {
    var padding = builder.align_to(8)
    free.compile(builder) | aggregate of pointer and size
    builder.push_1(8.lower_byte())
    builder.free()
    builder.pop_below_top(8, padding)
  }
  case load(ptr) {
    var padding = builder.align_to(8)
    | Compute the pointer to be unboxed.
    var ptr_start = builder.stack_size
    ptr.compile(builder)

    | Copy the data from the heap.
    var data_start = builder.stack_size
    var cursor = 0
    loop if cursor + 8 > expr.size then break else {
      builder.push_8_from_stack(ptr_start)
      builder.push_8(cursor)
      builder.add_8()
      builder.load_8() | TODO: alignment
      cursor = cursor + 8
    }
    loop if cursor == expr.size then break else {
      var padding = builder.align_to(8)
      builder.push_8_from_stack(ptr_start)
      builder.push_8(cursor)
      builder.add_8()
      builder.load_1()
      builder.pop_below_top(1, padding)
      cursor = cursor + 1
    }
    builder.pop_below_top(expr.size, 8 + padding)
  }
  case store(store) {
    | Compute the pointer.
    var padding_before_ptr = builder.align_to(8)
    var ptr_start = builder.stack_size
    store.ptr.compile(builder)

    | Compute the data to be boxed.
    var data_start = builder.stack_size
    store.value.compile(builder)

    if store.value.size == 1 then {
      builder.store_1()
    } else if store.value.size == 8 then {
      builder.store_8()
    } else {
      | Store data piece by piece.
      var padding_before_work = builder.align_to(8)
      var cursor = 0
      loop if cursor + 8 > store.value.size then break else {
        builder.push_8_from_stack(ptr_start)
        builder.add_8(cursor)
        builder.push_8_from_stack(data_start + cursor)
        builder.store_8()
        cursor = cursor + 8
      }
      loop if cursor == store.value.size then break else {
        builder.push_8_from_stack(ptr_start)
        builder.add_8(cursor)
        builder.push_1_from_stack(data_start + cursor)
        builder.store_1()
        cursor = cursor + 1
      }
      builder.pop(padding_before_ptr + 8 + store.value.size + padding_before_work)
    }
  }
  case store_multiple(store) {
    | Compute the pointer.
    var padding_before_ptr = builder.align_to(8)
    var ptr_start = builder.stack_size
    store.ptr.compile(builder)
    | Stack: [pad][ptr]

    | Compute the number of times that the data should be stored.
    var times_start = builder.stack_size
    store.times.compile(builder)
    | Stack: [pad][ptr][times]

    | Compute the data to be boxed.
    var data_start = builder.stack_size
    store.value.compile(builder)
    | Stack: [pad][ptr][times][data]

    | Copy the data to the heap.
    | The counter goes from 0 to times.
    var padding_before_work = builder.align_to(8)
    var counter_start = builder.stack_size
    builder.push_8(0)
    eprintln("counter ptr is at {counter_start}")
    | Stack: [pad][ptr][times][data][pad][counter]

    var loop_start = builder.instructions.len
    var stack_size_at_start_of_loop = builder.stack_size
    builder.push_8_from_stack(counter_start)
    builder.push_8_from_stack(times_start)
    builder.sub_8()
    builder.compare_zero_8()
    var jump_table_index = builder.jump_table_placeholder()
    | Later on, we'll patch the jump table so it only jumps here if
    | counter < times.
    | Stack: [pad][ptr][times][data][pad][counter]
    var less_case = builder.instructions.len
    var cursor = 0 | A cursor through the bytes of a single item.
    var value_ptr = builder.stack_size
    eprintln("value ptr is at {value_ptr}")
    builder.push_8_from_stack(ptr_start)
    builder.push_8_from_stack(counter_start)
    builder.push_8(store.value.size)
    builder.mul_8()
    builder.add_8()
    eprintln("stack size is now {builder.stack_size}")
    | Stack: [pad][ptr][times][data][pad][counter][value_ptr]
    | We've now computed where the item should be stored.
    if store.value.size == 1 then {
      builder.push_1_from_stack(data_start)
      builder.store_1()
    } else if store.value.size == 8 then {
      builder.push_8_from_stack(data_start)
      builder.store_8()
    } else {
      | TODO: take care of alignment
      | Copy the item piece by piece.
      loop if cursor + 8 > store.value.size then break else {
        builder.push_8_from_stack(value_ptr)
        builder.add_8(cursor)
        builder.push_8_from_stack(data_start + cursor)
        builder.store_8()
        cursor = cursor + 8
      }
      loop if cursor == store.value.size then break else {
        builder.push_8_from_stack(value_ptr)
        builder.add_8(cursor)
        builder.push_1_from_stack(data_start + cursor)
        builder.store_1()
        cursor = cursor + 1
      }
      builder.pop(8)
    }
    builder.add_8(1)
    builder.jump(loop_start)

    builder.stack_size == stack_size_at_start_of_loop or panic("stuff is wrong")
    var end = builder.instructions.len
    builder.patch_jump_table(jump_table_index, list(
      end,       | counter == times -> done
      end,       | counter > times  -> should never happen
      less_case, | counter < times -> copy more stuff
    ).to_slice())

    builder.pop(
      padding_before_ptr + 8 + store.value.size + padding_before_work + 8
    )
  }
  case crash(args) {
    todo("crash args")
    builder.crash()
  }
}
