| Converting Pudding to Waffle  

import plum.mar

fun to_waffle(signature: PuddingSignature): WaffleSignature {
  waffle_signature(signature.string)
}

fun compile_dup_fun(
  type: PlumType, funs: &Map[WaffleSignature, WaffleFun]
): WaffleSignature {
  var signature = waffle_signature("dup {type}")
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[WaffleFun]().*)

  var layout = type.memory_layout()

  var fun_builder = waffle_fun_builder(layout.size, layout.alignment)
  var body_builder = fun_builder.&.body()
  var param = waffle_local(WaffleId { index = 0 }, layout.size, layout.alignment)

  switch type.extend_one_level()
  case primitive(name) {}
  case never {}
  case struct_(fields) {
    var layout = type.memory_layout_struct()
    for field in fields do {
      var field_layout = field.value.memory_layout()
      body_builder.&.local(waffle_call(
        field.value.compile_dup_fun(funs),
        param.waffle_member(
          layout.field_to_offset.get(field.key),
          field_layout.size, field_layout.alignment
        ),
        0, 1
      ))
    }
  }
  case enum_(variants) {
    var layout = type.memory_layout_enum()
    var cases = list[WaffleBody]()

    for variant in variants do {
      var payloads = variant.value
      var variant = variant.key
      var payload_positions = layout.variants.get(variant).payload_positions
      var case_builder = fun_builder.&.body()

      for payload in payloads.iter().enumerate() do {
        var index = payload.index
        var payload_type = payload.item
        var payload_layout = payload_type.memory_layout()
        var payload_position = payload_positions.get(index)

        switch payload_position.boxing
        case boxed {
          var pointer = param.waffle_member(payload_position.offset, 8, 8)
          case_builder.&.local(waffle_store(
            pointer, waffle_add(waffle_load(pointer, 8, 8), waffle_word(1))
          ))
        }
        case unboxed
          case_builder.&.local(waffle_call(
            payload_type.compile_dup_fun(funs),
            param.waffle_member(
              payload_position.offset, payload_layout.size, payload_layout.alignment
            ),
            0, 1
          ))
      }
      cases.&.push(case_builder.returns(waffle_padding(0)))
    }
    body_builder.&.local(waffle_switch(
      param.waffle_member(layout.tag_offset, 1, 1), cases.to_slice()
    )).ignore()
  }
  case lambda(lambda) {
    todo("dup lambda")
  }
  case recursive unreachable()

  var body = body_builder.returns(waffle_padding(0))
  var fun_ = fun_builder.finish(body)

  funs.put(signature, fun_)
  signature
}

fun compile_drop_fun(
  type: PlumType, funs: &Map[WaffleSignature, WaffleFun]
): WaffleSignature {
  var signature = waffle_signature("drop {type}")
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[WaffleFun]().*)

  var layout = type.memory_layout()

  var fun_builder = waffle_fun_builder(layout.size, layout.alignment)
  var body_builder = fun_builder.&.body()
  var param = waffle_local(WaffleId { index = 0 }, layout.size, layout.alignment)

  switch type.extend_one_level()
  case primitive(name) {}
  case never {}
  case struct_(fields) {
    var layout = type.memory_layout_struct()
    for field in fields do {
      var field_layout = field.value.memory_layout()
      body_builder.&.local(waffle_call(
        field.value.compile_drop_fun(funs),
        param.waffle_member(
          layout.field_to_offset.get(field.key),
          field_layout.size, field_layout.alignment
        ),
        0, 1
      ))
    }
  }
  case enum_(variants) {
    var layout = type.memory_layout_enum()
    var cases = list[WaffleBody]()

    for variant in variants do {
      var payloads = variant.value
      var variant = variant.key
      var payload_positions = layout.variants.get(variant).payload_positions
      var case_builder = fun_builder.&.body()

      for payload in payloads.iter().enumerate() do {
        var index = payload.index
        var payload_type = payload.item
        var payload_layout = payload_type.memory_layout()
        var payload_position = payload_positions.get(index)

        switch payload_position.boxing
        case boxed {
          var pointer = param.waffle_member(payload_position.offset, 8, 8)
          var new_refcount = case_builder.&.local(waffle_sub(
            waffle_load(pointer, 8, 8), waffle_word(1)
          ))
          case_builder.&.local(waffle_store(pointer, new_refcount))
          case_builder.&.local(waffle_switch(
            waffle_compare_zero(new_refcount),
            list(
              WaffleBody {
                locals = empty_slice[WaffleId](),
                returns = waffle_call(
                  payload_type.compile_free_fun(funs), pointer, 0, 1
                )
              },
              WaffleBody { locals = empty_slice[WaffleId](), returns = waffle_padding(0) },
              WaffleBody { locals = empty_slice[WaffleId](), returns = waffle_padding(0) },
            ).to_slice()
          ))
        }
        case unboxed
          case_builder.&.local(waffle_call(
            payload_type.compile_drop_fun(funs),
            param.waffle_member(
              payload_position.offset, payload_layout.size, payload_layout.alignment
            ),
            0, 1
          ))
      }
      cases.&.push(case_builder.returns(waffle_padding(0)))
    }
    body_builder.&.local(waffle_switch(
      param.waffle_member(layout.tag_offset, 1, 1), cases.to_slice()
    )).ignore()
  }
  case lambda(lambda) {
    todo("drop lambda")
  }
  case recursive unreachable()

  var body = body_builder.returns(waffle_padding(0))
  var fun_ = fun_builder.finish(body)

  funs.put(signature, fun_)
  signature
}

fun compile_free_fun(
  type: PlumType, funs: &Map[WaffleSignature, WaffleFun]
): WaffleSignature {
  var signature = waffle_signature("free {type}")
  if funs.contains(signature) then return signature
  funs.put(signature, uninitialized[WaffleFun]().*)

  var layout = type.memory_layout()

  var fun_builder = waffle_fun_builder(8, 8)
  var body_builder = fun_builder.&.body()
  var param = waffle_local(WaffleId { index = 0 }, 8, 8)

  body_builder.&.local(waffle_call(
    type.compile_drop_fun(funs),
    waffle_load(
      waffle_add(param, waffle_word(8)), layout.size, layout.alignment
    ),
    0, 1
  ))
  var body = body_builder.returns(waffle_free(param))
  var fun_ = fun_builder.finish(body)

  funs.put(signature, fun_)
  signature
}

fun to_waffle(
  expr: PuddingExpr,
  fun_: PuddingFun,
  fun_builder: &WaffleFunBuilder, body_builder: &WaffleBodyBuilder,
  pudding_id_to_waffle_expr: &Map[PuddingId, WaffleExpr],
  pudding: Pudding, funs: &Map[WaffleSignature, WaffleFun],
): WaffleExpr {
  eprint("Compiling ")
  stderr.write(expr.op, fun_, 0)
  eprintln()

  switch expr.op
  case param unreachable()
  case uninitialized unreachable()
  case int(int) waffle_word(int)
  case string(string)
    waffle_aggregate(list(
      waffle_word(string.data.to_int()),
      waffle_word(string.len),
    ).to_slice())
  case type(type) todo("compile type")
  case struct_(struct_) {
    var layout = expr.type.memory_layout_struct()
    var parts = list[WaffleExpr]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case field(name) {
          var waffle_expr = pudding_id_to_waffle_expr.get(struct_.get(name))
          body_builder.local(waffle_call(
            WaffleSignature { string = "dup" }, waffle_expr, 0, 1
          ))
          waffle_expr
        }
        case padding(amount) waffle_padding(amount)
      )
    waffle_aggregate(parts.to_slice())
  }
  case member(member) {
    var struct_layout = fun_.get(member.of).type.memory_layout_struct()
    var field_layout = expr.type.memory_layout()
    pudding_id_to_waffle_expr.get(member.of).waffle_member(
      struct_layout.field_to_offset.get(member.name),
      field_layout.size,
      field_layout.alignment,
    )
  }
  case variant(variant) {
    var layout = expr.type.memory_layout_enum().variants.get(variant.symbol)
    var parts = list[WaffleExpr]()
    for part in layout.parts do
      parts.&.push(
        switch part
        case padding(amount) waffle_padding(amount)
        case payload(index) pudding_id_to_waffle_expr.get(variant.payloads.get(index))
        case payload_ptr(index) {
          var payload = pudding_id_to_waffle_expr.get(variant.payloads.get(index))
          var pointer = body_builder.&.local(waffle_malloc(waffle_word(8 + payload.size)))
          body_builder.local(waffle_store(pointer,
            waffle_aggregate(list(waffle_word(1), payload).to_slice())
          ))
          pointer
        }
        case tag(byte) waffle_byte(byte)
      )
    waffle_aggregate(parts.to_slice())
  }
  case switch_(switch_) {
    var condition = pudding_id_to_waffle_expr.get(switch_.condition)

    var layout = fun_.get(switch_.condition).type.memory_layout_enum()

    for variant_layout in layout.variants do {
      var payloads = switch_.cases.get(variant_layout.key).params
      for payload in payloads.iter().enumerate() do {
        var id = payload.item
        var payload_layout = fun_.get(id).type.memory_layout()
        var payload_position =
          variant_layout.value.payload_positions.get(payload.index)
        pudding_id_to_waffle_expr.put(
          id,
          switch payload_position.boxing
          case boxed waffle_load(
            waffle_add(
              condition.waffle_member(payload_position.offset, 8, 8),
              waffle_word(8),
            ),
            payload_layout.size, payload_layout.alignment,
          )
          case unboxed condition.waffle_member(
            payload_position.offset,
            payload_layout.size, payload_layout.alignment,
          )
        )
      }
    }

    var cases = uninitialized_slice[WaffleBody](layout.tag_to_variant.size)
    for entry in layout.tag_to_variant do
      cases.&.set(
        entry.key.to_int(),
        switch_.cases.get(entry.value)
          .to_waffle(fun_, fun_builder, pudding_id_to_waffle_expr, pudding, funs)
      )

    waffle_switch(
      condition.waffle_member(layout.tag_offset, 1, 1),
      cases,
    )
  }
  case lambda(lambda) {
    | Build the closure (a heap-allocated struct containing all captured
    | variables). This allows lambdas to have a uniform representation
    | consisting of a pointer to the closure as well as a function pointer.
    var captured_types = list[PlumType]()
    for id in lambda.captures do captured_types.&.push(fun_.get(id).type)
    var closure_layout = captured_types.to_slice().memory_layout_closure()

    var parts = list[WaffleExpr]()
    for part in closure_layout.parts do
      parts.&.push(
        switch part
        case capture(index) pudding_id_to_waffle_expr.get(lambda.captures.get(index))
        case padding(amount) waffle_padding(amount)
      )
    var closure = waffle_aggregate(parts.to_slice())
    var closure_pointer =
      body_builder.&.local(waffle_malloc(waffle_word(closure.size)))
    body_builder.local(waffle_store(closure_pointer,
      waffle_aggregate(list(waffle_word(1), closure).to_slice())
    ))

    waffle_aggregate(list(
      closure_pointer,
      waffle_function_ptr(waffle_signature(lambda.function.string)),
    ).to_slice())
  }
  case lambda_call(call) {
    var lambda = pudding_id_to_waffle_expr.get(call.lambda)
    var closure_ptr = lambda.waffle_member(0, 8, 8)
    var function_ptr = lambda.waffle_member(8, 8, 8)

    var arg_types = list[PlumType]()
    for arg in call.args do arg_types.&.push(fun_.get(arg).type)
    arg_types.&.push(PlumType.primitive("Int")) | closure pointer TODO: better type
    var arg_layout = arg_types.to_slice().memory_layout_params()

    var parts = list[WaffleExpr]()
    for part in arg_layout.parts do
      parts.&.push(
        switch part
        case padding(amount) waffle_padding(amount)
        case param(index) {
          if index == call.args.len then
            closure_ptr
          else
            pudding_id_to_waffle_expr.get(call.args.get(index))
        }
      )
    var args = waffle_aggregate(parts.to_slice())

    var return_layout = expr.type.memory_layout()

    waffle_call_indirect(
      function_ptr, args,
      return_layout.size, return_layout.alignment,
    )
  }
  case call(call) {
    var arg_types = list[PlumType]()
    for arg in call.args do arg_types.&.push(fun_.get(arg).type)
    var arg_layout = arg_types.to_slice().memory_layout_params()

    var parts = list[WaffleExpr]()
    for part in arg_layout.parts do
      parts.&.push(
        switch part
        case padding(amount) waffle_padding(amount)
        case param(index) pudding_id_to_waffle_expr.get(call.args.get(index))
      )
    var args = waffle_aggregate(parts.to_slice())

    var return_layout = pudding.funs.get(call.function).return_type().memory_layout()

    waffle_call(
      WaffleSignature { string = call.function.string }, args,
      return_layout.size, return_layout.alignment,
    )
  }
  case instruction(instruction) {
    var args = instruction.args

    switch instruction.instruction
    case add_ints       waffle_add(    pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case sub_ints       waffle_sub(    pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case mul_ints       waffle_mul(    pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case div_ints       waffle_div(    pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case mod_ints       waffle_mod(    pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case and_ints       waffle_and(    pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case or_ints        waffle_or(     pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case xor_ints       waffle_xor(    pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
    case compare_ints   waffle_compare_zero(
                          waffle_sub(pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
                        ) | tag for enum: | Equal Greater Less
    case concat_strings todo("handle concat_strings")
    case crash          waffle_crash(  pudding_id_to_waffle_expr.get(args.get(0)), pudding_id_to_waffle_expr.get(args.get(1)))
  }
  case dup(value)
    waffle_call(
      fun_.get(value).type.compile_dup_fun(funs),
      pudding_id_to_waffle_expr.get(value),
      0, 1
    )
  case drop(value)
    waffle_call(
      fun_.get(value).type.compile_drop_fun(funs),
      pudding_id_to_waffle_expr.get(value),
      0, 1
    )
}

fun to_waffle(
  body: PuddingBody,
  fun_: PuddingFun, fun_builder: &WaffleFunBuilder,
  pudding_id_to_waffle_expr: &Map[PuddingId, WaffleExpr],
  pudding: Pudding, funs: &Map[WaffleSignature, WaffleFun],
): WaffleBody {
  var body_builder = fun_builder.&.body()
  for id in body.exprs do {
    var expr = body_builder.&.local(fun_.get(id).to_waffle(
      fun_, fun_builder, body_builder.&, pudding_id_to_waffle_expr, pudding, funs
    ))
    pudding_id_to_waffle_expr.&.put(id, expr)
  }
  body_builder.returns(pudding_id_to_waffle_expr.get(body.returns))
}

fun to_waffle(
  fun_: PuddingFun, pudding: Pudding, funs: &Map[WaffleSignature, WaffleFun]
): WaffleFun {
  | When you call a function, we expect the parameters to already be on the
  | stack, layouted efficiently as an aggregate:
  |
  | ... param1 param3 param2
  |
  | For lambdas, one of these parameters represents a pointer to the closure, a
  | heap-allocated object containing all captured values:
  |
  | ... param1 param3 closure_ptr param2
  |
  | Before lowering the
  | function's expressions, we copy those captured values from the closure on
  | the heap onto the stack:
  |
  | ... param1 param3 closure_ptr param2 captured1 captured2

  var params = list[PuddingId]()
  for param in fun_.body.params do params.&.push(param)
  var params = params.to_slice()

  var param_types = list[PlumType]()
  for param in params do param_types.&.push(fun_.get(param).type)
  if fun_.captures is some then
    param_types.&.push(PlumType.primitive("Int")) | closure pointer TODO: better type
  var param_layout = param_types.to_slice().memory_layout_params()

  var fun_builder = waffle_fun_builder(param_layout.size, param_layout.alignment)
  var param_aggregate = waffle_local(
    WaffleId { index = 0 }, param_layout.size, param_layout.alignment
  )

  var pudding_id_to_waffle_expr = map[PuddingId, WaffleExpr]()

  if fun_.captures is some(captures) then {
    var closure_ptr = param_aggregate.waffle_member(
      param_layout.param_to_offset.get(params.len), 8, 8
    )

    var captured_types = list[PlumType]()
    for id in captures do captured_types.&.push(fun_.get(id).type)
    var closure_layout = captured_types.to_slice().memory_layout_closure()

    var closure = waffle_load(
      waffle_add(closure_ptr, waffle_word(8)),
      closure_layout.size, closure_layout.alignment,
    )

    for capture in captures.iter().enumerate() do {
      var layout = fun_.get(capture.item).type.memory_layout()
      pudding_id_to_waffle_expr.&.put(
        capture.item,
        closure.waffle_member(
          closure_layout.capture_to_offset.get(capture.index),
          layout.size, layout.alignment,
        )
      )
    }
  }
  for param in params.iter().enumerate() do {
    var layout = fun_.get(param.item).type.memory_layout()
    pudding_id_to_waffle_expr.&.put(
      param.item,
      param_aggregate.waffle_member(
        param_layout.param_to_offset.get(param.index),
        layout.size, layout.alignment,
      )
    )
  }

  var body = fun_.body.to_waffle(
    fun_, fun_builder.&, pudding_id_to_waffle_expr.&, pudding, funs
  )
  fun_builder.finish(body)
}

fun to_waffle(pudding: Pudding): Waffle {
  var funs = map[WaffleSignature, WaffleFun]()
  for fun_ in pudding.funs do
    funs.&.put(
      fun_.key.to_waffle(), fun_.value.to_waffle(pudding, funs.&)
    )
  Waffle { funs }
}
