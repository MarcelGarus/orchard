import mod.mar

fun optimize(
  fun_: YogurtFun, optimized: &Map[String, YogurtFun], yogurt: Yogurt
): YogurtFun {
  var new_dag = dag[YogurtExpr]()
  var mapping = map[Id, Id]()
  var body = fun_.body.optimize(
    fun_.dag, 1, new_dag.&, mapping.&, optimized, yogurt
  )
  YogurtFun { dag = new_dag, body }
}

fun optimize(
  body: YogurtBody, dag: Dag[YogurtExpr], inline_depth: Int,
  new_dag: &Dag[YogurtExpr],
  mapping: &Map[Id, Id], optimized: &Map[String, YogurtFun], yogurt: Yogurt,
): YogurtBody {
  var builder = body_builder(new_dag).&
  for id in body.params do mapping.put(id, builder.param(dag.type_of(id)))
  for id in body.children do
    mapping.put(
      id, id.optimize(dag, inline_depth, builder, mapping, optimized, yogurt)
    )
  var body = builder.finish(mapping.get(body.returns))
  var body = body.tree_shake(new_dag.*)
  body
}

fun optimize(
  id: Id, dag: Dag[YogurtExpr], inline_depth: Int,
  builder: &YogurtBodyBuilder, mapping: &Map[Id, Id],
  optimized: &Map[String, YogurtFun], yogurt: Yogurt,
): Id {
  dag.get(id).optimize(dag, inline_depth, builder, mapping, optimized, yogurt)
}
fun optimize(
  expr: YogurtExpr, dag: Dag[YogurtExpr], inline_depth: Int,
  builder: &YogurtBodyBuilder, mapping: &Map[Id, Id],
  optimized: &Map[String, YogurtFun], yogurt: Yogurt,
): Id {
  | stderr."Optimizing:"
  | stderr.write(expr.op, dag, 0)
  | stderr."\n"

  switch expr.op
  case param unreachable()
  case byte(byte) builder.byte(byte)
  case int(int) builder.int(int)
  case string(string) builder.string(string)
  case array(items)
    builder.array(expr.type, {
      var new_items = list[Id]()
      for item in items do new_items.&.push(mapping.get(item))
      new_items.to_slice()
    })
  case struct_(struct_)
    builder.struct_({
      var fields = map[String, Id]()
      for field in struct_ do fields.&.put(field.key, mapping.get(field.value))
      fields
    })
  case member(member) {
    var of = mapping.get(member.of)
    if builder.get(of).op is struct_(fields)
    then fields.get(member.name)
    else builder.member(of, member.name)
  }
  case enum_(enum_)
    builder.enum_(expr.type, enum_.name, mapping.get(enum_.value))
  case switch_(switch_) {
    var condition = mapping.get(switch_.condition)
    if builder.get(condition).op is enum_(enum_) then {
      var case_ = switch_.cases.get(enum_.name)
      mapping.put(case_.params.get(0) -> enum_.value)
      for id in case_.children do
        mapping.&.put(
          id,
          id.optimize(dag, inline_depth, builder, mapping, optimized, yogurt),
        )
      return mapping.get(case_.returns)
    }
    builder.switch_(condition, expr.type, {
      var cases = map[String, YogurtBody]()
      for case_ in switch_.cases do
        cases.&.put(
          case_.key,
          case_.value.optimize(
            dag, inline_depth, builder.dag, mapping, optimized, yogurt
          ),
        )
      cases
    })
  }
  case lambda(lambda)
    builder.lambda(expr.type, lambda.function, mapping.get(lambda.closure))
  case call(call) {
    var args = list[Id]()
    for arg in call.args do args.&.push(mapping.get(arg))
    var args = args.to_slice()

    switch call.callee
    case lambda(lambda) {
      var lambda = mapping.get(lambda)
      if builder.get(lambda).op is lambda(lambda) then {
        var args = list[Id]()
        for arg in call.args do args.&.push(arg)
        args.&.push(lambda.closure)
        var args = args.to_slice()

        return optimize_function_call(
          lambda.function, args, expr.type,
          dag, inline_depth, builder, mapping, optimized, yogurt,
        )
      }
      builder.call(YogurtCallee.lambda(lambda), args, expr.type)
    }
    case fun_(signature)
      optimize_function_call(
        signature, args, expr.type,
        dag, inline_depth, builder, mapping, optimized, yogurt,
      )
    case builtin(builtin) optimize_builtin(builtin, args, expr.type, builder)
  }
  case type(type) builder.type(type)
}

fun optimize_function_call(
  signature: String, args: Slice[Id], type: EggType,
  dag: Dag[YogurtExpr], inline_depth: Int,
  builder: &YogurtBodyBuilder, mapping: &Map[Id, Id],
  optimized: &Map[String, YogurtFun], yogurt: Yogurt,
): Id {
  | If all the arguments are compile-time-known, try to run the function at
  | compile time.
  var arg_values = list[YogurtComptimeValue]()
  for arg in args do arg_values.&.push(builder.extract_comptime(arg) or break)
  var arg_values = arg_values.to_slice()
  var all_comptime_known = arg_values.len == args.len
  if all_comptime_known then {
    var resources = YogurtRunResources { exprs = 1000 }
    if run(signature, arg_values, yogurt, resources.&) is ok(value) then
      return builder.codify(value)
  }

  | Possibly inline the function.
  if inline_depth > 0 then
    if optimized.get_maybe(signature) is some(called) then {
      var should_inline = called.complexity() < 50
      if should_inline then {
        | Inline the called function!
        var inner_mapping = map[Id, Id]()
        for both in zip(called.body.params.iter(), args.iter()) do
          inner_mapping.&.put(both.a, both.b)
        for id in called.body.children do
          inner_mapping.&.put(
            id,
            id.optimize(
              called.dag, inline_depth - 1, builder,
              inner_mapping.&, optimized, yogurt,
            ),
          )
        return inner_mapping.get(called.body.returns)
      }
    }

  builder.call(YogurtCallee.fun_(signature), args, type)
}

fun optimize_builtin(
  builtin: YogurtBuiltin, args: Slice[Id], type: EggType,
  builder: &YogurtBodyBuilder,
): Id {
  switch builtin
  case lower_byte
    if builder.get(args.get(0)).op is int(int) then
      return builder.byte(int.lower_byte())
  case byte_to_int
    if builder.get(args.get(0)).op is byte(byte) then
      return builder.int(byte.to_int())
  case add_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if a.op is int(a) then if a == 0 then return args.get(1)
    if b.op is int(b) then if b == 0 then return args.get(0)
    if a.op is int(a) then if b.op is int(b) then return builder.int(a + b)
  }
  case sub_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if b.op is int(b) then if b == 0 then return args.get(0)
    if a.op is int(a) then if b.op is int(b) then return builder.int(a - b)
  }
  case mul_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if a.op is int(a) then if a == 1 then return args.get(1)
    if b.op is int(b) then if b == 1 then return args.get(0)
    if a.op is int(a) then if b.op is int(b) then return builder.int(a * b)
  }
  case div_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if b.op is int(b) then if b == 1 then return args.get(0)
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return builder.int(a / b)
  }
  case mod_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if b.op is int(b) then if b == 1 then return builder.int(0)
    if a.op is int(a) then if b.op is int(b) then if b != 0 then
      return builder.int(a % b)
  }
  case and_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if a.op is int(a) then if a == 0 then return args.get(0)
    if b.op is int(b) then if b == 0 then return args.get(1)
    if a.op is int(a) then if a == -1 then return args.get(1)
    if b.op is int(b) then if b == -1 then return args.get(0)
    if a.op is int(a) then if b.op is int(b) then return builder.int(a & b)
  }
  case or_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if a.op is int(a) then if a == 0 then return args.get(1)
    if b.op is int(b) then if b == 0 then return args.get(0)
    if a.op is int(a) then if a == -1 then return args.get(0)
    if b.op is int(b) then if b == -1 then return args.get(1)
    if a.op is int(a) then if b.op is int(b) then return builder.int(or(a, b))
  }
  case xor_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if a.op is int(a) then if b.op is int(b) then return builder.int(a ^ b)
  }
  case compare_ints {
    var a = builder.get(args.get(0))
    var b = builder.get(args.get(1))
    if a.op is int(a) then if b.op is int(b) then {
      var symbol =
        switch a <=> b
        case less "less"
        case equal "equal"
        case greater "greater"
      return builder.enum_(type, symbol, builder.nothing())
    }
  }
  case box {}
  case unbox {
    | TODO
    | if builder.get(args.get(0)).op is call(a) then
    |   return builder.int(a ^ b)
  }
  case generate_array {
    | TODO
  }
  case array_get {
    var array = builder.get(args.get(0))
    var index = builder.get(args.get(1))
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then return items.get(index)
  }
  case array_set {
    var array = builder.get(args.get(0))
    var index = builder.get(args.get(1))
    var item  = args.get(2)
    if array.op is array(items) then if index.op is int(index) then
      if (0..items.len).contains(index) then {
        var new_items = list[Id]()
        for item in items do new_items.&.push(item)
        new_items.&.set(index, item)
        return builder.array(type, new_items.to_slice())
      }
  }
  case array_slice {
    var array = builder.get(args.get(0))
    var range = builder.get(args.get(1))
    if array.op is array(items) then if range.op is struct_(range) then {
      var start = builder.get(range.get("start"))
      var end = builder.get(range.get("end"))
      if start.op is int(start) then if end.op is int(end) then {
        if (0..items.len).contains(start) and (0..items.len).contains(end)
        then return builder.array(type, items.subslice(start..end))
      }
    }
  }
  case array_len {
    var array = builder.get(args.get(0))
    if array.op is array(items) then return builder.int(items.len)
  }
  case crash {}

  builder.call(YogurtCallee.builtin(builtin), args, type)
}
