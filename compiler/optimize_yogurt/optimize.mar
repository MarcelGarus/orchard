import mod.mar

fun optimize(
  fun_: YogurtFun, optimized: &Map[String, YogurtFun], yogurt: Yogurt
): YogurtFun {
  var new_dag = dag[YogurtExpr]()
  var mapping = map[Id, Id]()
  var body = fun_.body.optimize(
    fun_.dag, 2, new_dag.&, mapping.&, optimized, yogurt
  )
  YogurtFun { dag = new_dag, body }
}

fun optimize(
  body: YogurtBody, dag: Dag[YogurtExpr], inline_depth: Int,
  new_dag: &Dag[YogurtExpr],
  mapping: &Map[Id, Id], optimized: &Map[String, YogurtFun], yogurt: Yogurt,
): YogurtBody {
  var builder = body_builder(new_dag).&
  for id in body.params do mapping.put(id, builder.param(dag.type_of(id)))
  for id in body.children do
    mapping.put(
      id, id.optimize(dag, inline_depth, builder, mapping, optimized, yogurt)
    )
  var body = builder.finish(mapping.get(body.returns))
  var body = body.tree_shake(new_dag.*)
  body
}

fun optimize(
  id: Id, dag: Dag[YogurtExpr], inline_depth: Int,
  builder: &YogurtBodyBuilder, mapping: &Map[Id, Id],
  optimized: &Map[String, YogurtFun], yogurt: Yogurt,
): Id {
  dag.get(id).optimize(dag, inline_depth, builder, mapping, optimized, yogurt)
}
fun optimize(
  expr: YogurtExpr, dag: Dag[YogurtExpr], inline_depth: Int,
  builder: &YogurtBodyBuilder, mapping: &Map[Id, Id],
  optimized: &Map[String, YogurtFun], yogurt: Yogurt,
): Id {
  | stderr."Optimizing:"
  | stderr.write(expr.op, dag, 0)
  | stderr."\n"

  switch expr.op
  case param unreachable()
  case byte(byte) builder.byte(byte)
  case int(int) builder.int(int)
  case string(string) builder.string(string)
  case array(items)
    builder.array(expr.type, {
      var new_items = list[Id]()
      for item in items do new_items.&.push(mapping.get(item))
      new_items.to_slice()
    })
  case struct_(struct_)
    builder.struct_({
      var fields = map[String, Id]()
      for field in struct_ do fields.&.put(field.key, mapping.get(field.value))
      fields
    })
  case member(member) {
    var of = mapping.get(member.of)
    if builder.get(of).op is struct_(fields)
    then fields.get(member.name)
    else builder.member(of, member.name)
  }
  case enum_(enum_)
    builder.enum_(expr.type, enum_.name, mapping.get(enum_.value))
  case switch_(switch_) {
    var condition = mapping.get(switch_.condition)
    if builder.get(condition).op is enum_(enum_) then {
      var case_ = switch_.cases.get(enum_.name)
      mapping.put(case_.params.get(0) -> enum_.value)
      for id in case_.children do
        mapping.&.put(
          id,
          id.optimize(dag, inline_depth, builder, mapping, optimized, yogurt),
        )
      return mapping.get(case_.returns)
    }
    builder.switch_(condition, expr.type, {
      var cases = map[String, YogurtBody]()
      for case_ in switch_.cases do
        cases.&.put(
          case_.key,
          case_.value.optimize(
            dag, inline_depth, builder.dag, mapping, optimized, yogurt
          ),
        )
      cases
    })
  }
  case lambda(lambda)
    builder.lambda(expr.type, lambda.function, mapping.get(lambda.closure))
  case call(call) {
    var callee =
      switch call.callee
      case lambda(lambda) {
        if builder.get(lambda).op is lambda(lambda) then {
          | return YogurtExpr {
          |   op = YogurtOp.call(YogurtCall {
          |     callee = YogurtCallee.fun_(lambda.function),
          |     args = {
          |       var args = list[Id]()
          |       for arg in call.args do args.&.push(arg)
          |       args.&.push(lambda.closure)
          |       args.to_slice()
          |     },
          |   }),
          |   type = expr.type,
          | }.optimize(dag, inline_depth, builder, mapping, optimized)
        }
        YogurtCallee.lambda(mapping.get(lambda))
      }
      case fun_(signature) {
        | If all the arguments are compile-time-known, just try to run the
        | function at compile time.
        {
          var args = list[YogurtComptimeValue]()
          for arg in call.args do
            args.&.push(builder.extract_comptime(mapping.get(arg)) or break)
          var args = args.to_slice()
          var all_comptime_known = args.len == call.args.len
          if all_comptime_known then {
            var result = run(
              signature, args, yogurt, YogurtRunResources { exprs = 100 }.&
            )
            if result is ok(value) then return builder.codify(value)
          }
        }
        if inline_depth > 0 then {
          if optimized.get_maybe(signature) is some(called) then {
            var should_inline = called.complexity() < 10 or {
              | TODO: Check if all the args are comptime-known.
              false
            }
            if should_inline then {
              | Inline the called function!
              var inner_mapping = map[Id, Id]()
              for both in zip(called.body.params.iter(), call.args.iter()) do
                inner_mapping.&.put(both.a, mapping.get(both.b))
              for id in called.body.children do
                inner_mapping.&.put(
                  id,
                  id.optimize(
                    called.dag,
                    inline_depth - 1,
                    builder,
                    inner_mapping.&,
                    optimized,
                    yogurt,
                  ),
                )
              return inner_mapping.get(called.body.returns)
            }
          }
        }
        YogurtCallee.fun_(signature)
      }
      case builtin(builtin) YogurtCallee.builtin(builtin)

    var args = list[Id]()
    for arg in call.args do args.&.push(mapping.get(arg))
    builder.call(callee, args.to_slice(), expr.type)
  }
  case type(type) builder.type(type)
}
