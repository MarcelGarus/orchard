import mod.mar

fun compile(
  fun_: ToastFun, module: Module,
  types: Map[String, EggTypeDef], toasts: Map[Module, Toast],
): Result[EggFun, Error] {
  var visible = visible()
  var body = egg_body_builder().&

  var param_types = list[EggType]()
  for param in fun_.params do {
    var type = param.type.compile(module, types)?
    visible.&.define(param.name.string, body.push_param(type))
    param_types.&.push(type)
  }
  var param_types = param_types.to_slice()

  | Push the type variables into the body.
  for var_ in param_types.collect_type_variables() do
    visible.&.define(var_, body.push(egg_type(type_variable(var_))))
  for param in fun_.params do
    if param.type.compile(module, types)? == type_type then {
      var id = body.push(egg_type(type_variable(param.name.string)))
      visible.&.define(param.name.string, id)
    }

  var returned = fun_.body.compile(body, module, visible.&, EggContext { toasts, types })?
  | var last = none[EggExpr]()
  | for expr in fun_.body.body.unwrap() do
  |   last = some(body.push(
  |     expr.compile(body, module, visible.&, EggContext { toasts, types })?
  |   ))
  | var returned = last.unwrap()

  var return_type = fun_.return_type.compile(module, types)?
  returned.type.is_assignable_to(return_type) or
    return error[EggFun, Error](error(
      "Function returns something different than its claimed return type:\n
      'Claimed: {return_type}\n
      'Actual:  {returned.type}",
      fun_.name.src,
    ))
  var returned = returned.cast(return_type)

  var body = body.finish(returned)

  ok[EggFun, Error](EggFun { module, name = fun_.name, body })
}

struct EggContext { toasts: Map[Module, Toast], types: Map[String, EggTypeDef] }

fun compile(
  toast: ToastExpr, body: &EggBodyBuilder, module: Module, visible: &Visible,
  context: EggContext,
): Result[EggExpr, Error] {
  ok[EggExpr, Error](
    switch toast
    case todo(src) egg_crash("Todo", type_never)
    case int(int) egg_int(int.int)
    case string(string) egg_string(string.string)
    case type(type) egg_type(type.compile(module, context.types)?)
    case struct_(struct_) struct_({
      var fields = map[String, EggExpr]()
      for field in struct_.fields do {
        var name = field.name.string
        var value = field.value.compile(body, module, visible, context)?
        var type = value.type
        if fields.contains(name) then
          return error[EggExpr, Error](error(
            "{name} is in the struct multiple times.",
            struct_.ampersand.src,
          ))
        fields.&.put(name, value)
      }
      fields
    })
    case enum_(enum_) {
      var name = enum_.name.string
      var value = enum_.value.compile(body, module, visible, context)?
      enum_(type_enum(map(name -> value.type)), name, value)
    }
    case switch_(switch_) {
      | Compile the condition.
      var condition = switch_.condition.compile(body, module, visible, context)?
      var variant_types = condition.type.kind().enum_
        or return error[EggExpr, Error](error(
          "Switched on non-enum: {condition.type}", switch_.percent.src
        ))

      | Make sure that no variant is handled twice, that all variants are
      | handled, and that no extra variants are handled.
      var handled_variants = set[String]()
      for case_ in switch_.cases do {
        if handled_variants.contains(case_.symbol.string) then
          return error[EggExpr, Error](error(
            "{case_.symbol.string} is handled multiple times.",
            switch_.percent.src,
          ))
        handled_variants.&.put(case_.symbol.string)
      }
      for variant in variant_types do
        if not(handled_variants.contains(variant.key)) then
          return error[EggExpr, Error](error(
            "{variant.key} is not handled.", switch_.percent.src
          ))
      for variant in handled_variants do
        if not(variant_types.contains(variant)) then
          return error[EggExpr, Error](error(
            "Handling non-existent variant {variant}.", switch_.percent.src
          ))

      | Compile the individual cases.
      var case_compilers = map[String, Tuple2[EggBodyBuilder, EggExpr]]()
      var case_types = list[EggType]()
      for case_ in switch_.cases do {
        var symbol = case_.symbol.string
        var snapshot = visible.snapshot()
        var case_body = egg_body_builder().&
        var payload_type = variant_types.get(symbol)
        if case_.payload is some(pattern) then {
          var payload = case_body.push_param(payload_type)
          pattern.compile_pattern(payload, case_body, module, visible, context)?
        } else
          case_body.push_param(payload_type).ignore()

        var returns = case_.body.compile(case_body, module, visible, context)?
        visible.restore(snapshot)
        case_compilers.&.put(symbol, tuple(case_body.*, returns))
        case_types.&.push(returns.type)
      }
      var common_type = union(case_types.to_slice()) or
        return error[EggExpr, Error](error(
          "Couldn't union types {case_types}", switch_.percent.src
        ))
      var common_type = common_type
      var cases = map[String, EggBody]()
      for compiler in case_compilers do {
        var symbol = compiler.key
        var returns = compiler.value.b
        var compiler = compiler.value.a
        var actual_return = returns.cast(common_type)
        cases.&.put(symbol, compiler.finish(actual_return))
      }

      switch_(condition, common_type, cases)
    }
    case name(name)
      visible.lookup(name.string) or
        return error[EggExpr, Error](error(
          "Unknown referenced name {name.string}.", name.src
        ))
    case lambda(lambda) {
      var snapshot = visible.snapshot()
      var lambda_body = egg_body_builder().&
      for param in lambda.params do {
        var name = param.name.string
        var type = param.type.compile(module, context.types)?
        visible.define(name, lambda_body.push_param(type))
      }
      var returns = lambda.body.compile(lambda_body, module, visible, context)?
      var lambda_body = lambda_body.finish(returns)
      visible.restore(snapshot)

      lambda(lambda_body)
    }
    case call(call) {
      var args = list[EggExpr]()
      for arg in call.args do
        args.&.push(arg.compile(body, module, visible, context)?)
      var args = args.to_slice()

      | Find the function name -- either some(String) if it's a function call
      | or none if it's a lambda call.
      var function_name =
        switch call.function.*
        case name(name) {
          | Check if the call is actually a struct access.
          if args.len == 1 then
            if args.get(0).type.internal_kind() is struct_(fields) then
              if fields.contains(name.string) then {
                | This is a struct access!
                var struct_ = args.get(0)
                var field_type = struct_.type.kind()
                  .struct_.unwrap().get(name.string)
                return ok[EggExpr, Error](
                  EggOp.member(EggMember {
                    of = struct_.put_on_heap(), name = name.string
                  }).expr(field_type, name.src)
                )
              }

          switch visible.lookup(name.string)
          case some none[StringAndSrc]()
          case none some(name)
        }
        default none[StringAndSrc]()

      switch function_name
      case some(name) { | top-level function
        | Resolve arguments of the type Type.
        var arg_values = list[FunArg]()
        for i in 0..args.len do {
          var arg = args.get(i)
          arg_values.&.push(
            if arg.type == type_type then {
              var type_value = loop {
                switch arg.op
                case type(type) break(type)
                case id(id) arg = id.get()
                default return error[EggExpr, Error](error(
                  "Arguments of the type Type have to be known at 
                  'compile-time. Arg is {args.get(i).debug()}",
                  name.src
                ))
              }
              FunArg { value = some(type_value), type = type_type }
            } else
              FunArg { value = none[EggType](), type = arg.type }
          )
        }
        var arg_values = arg_values.to_slice()

        | Look for a matching function.
        var match = lookup(
          name.string, arg_values, module, name.src,
          context.toasts, context.types,
        )?

        | Cast arguments
        var cast_args = list[EggExpr]()
        for both in zip(args.iter(), match.param_types.iter()) do
          cast_args.&.push(both.a.cast(both.b))
        var args = cast_args.to_slice()

        | Call the function.
        switch match.kind
        case fun_(signature)
          EggCalledFun { signature, substitutions = match.substitutions }
            .call(args, match.return_type)
        case builtin(builtin)
          EggCalledBuiltin { builtin, substitutions = match.substitutions }
            .call(args, match.return_type)
      }
      case none { | lambda
        var lambda = call.function.compile(body, module, visible, context)?
        var lambda_type = lambda.type
        var lambda_type = lambda_type.kind().lambda or
          return return error[EggExpr, Error](error(
            "Tried to call non-lambda: {lambda_type}", call.function.src()
          ))

        | Cast arguments
        var cast_args = list[EggExpr]()
        for both in zip(args.iter(), lambda_type.args.iter()) do {
          var arg = both.a
          var expected_type = both.b
          arg.type.is_assignable_to(expected_type) or
            return return error[EggExpr, Error](error(
              "Tried to call lambda with wrong types.", call.function.src()
            ))
          cast_args.&.push(arg.cast(expected_type))
        }
        var args = cast_args.to_slice()

        lambda.call(args)
      }
    }
    case var_(var_) {
      var value = body.push(var_.right.compile(body, module, visible, context)?)
      var_.left.compile_pattern(value, body, module, visible, context)?
      value
    }
    case body(exprs) {
      var last = none[EggExpr]()
      for expr in exprs do {
        if last is some(last) then body.push(last).ignore()
        last = some(expr.compile(body, module, visible, context)?)
      }
      last or unreachable()
    }
  )
}

fun compile_pattern(
  pattern: ToastExpr, matched: EggExpr,
  body: &EggBodyBuilder, module: Module, visible: &Visible,
  context: EggContext,
): Result[Nothing, Error] {
  switch pattern
  case todo
    error[Nothing, Error](error(
      "Todo in pattern.", pattern.src()
    ))
  case int
    error[Nothing, Error](error(
      "Int literals can't be in patterns.", pattern.src()
    ))
  case string
    error[Nothing, Error](error(
      "String literals can't be in patterns.", pattern.src()
    ))
  case type
    error[Nothing, Error](error(
      "Type literals can't be in patterns.", pattern.src()
    ))
  case struct_(pattern) {
    var struct_fields = matched.type.kind().struct_ or
      return error[Nothing, Error](error(
        "Tried to use a struct pattern to match on {matched.type}.",
        pattern.ampersand.src,
      ))

    for field in pattern.fields do
      struct_fields.contains(field.name.string) or
        return error[Nothing, Error](error(
          "Patterns refers to {field.name.string}, but that is not in the 
          'struct {matched.type}.",
          field.name.src,
        ))
    var matched_fields = set[String]()
    for field in pattern.fields do matched_fields.&.put(field.name.string)
    for field in struct_fields do
      matched_fields.contains(field.key) or
        return error[Nothing, Error](error(
          "Pattern does not bind field {field.key} of {matched.type}.",
          pattern.ampersand.src,
        ))

    var matched = body.push(matched)
    for field in pattern.fields do {
      var field_type = struct_fields.get(field.name.string)
      var matched_value = body.push(
        EggOp.member(EggMember {
          of = matched.put_on_heap(), name = field.name.string
        }).expr(field_type, field.name.src)
      )
      field.value.compile_pattern(
        matched_value, body, module, visible, context
      )?
    }

    ok[Nothing, Error]({})
  }
  case enum_
    error[Nothing, Error](error("Enums can't be in patterns.", pattern.src()))
  case switch_ unreachable()
  case name(name) {
    visible.define(name.string, matched)
    ok[Nothing, Error]({})
  }
  case lambda
    error[Nothing, Error](error("Lambdas can't be in patterns.", pattern.src()))
  case call
    error[Nothing, Error](error("Calls can't be in patterns.", pattern.src()))
  case var_
    error[Nothing, Error](error(
      "Variable declarations can't be in patterns.", pattern.src()
    ))
  case body
    error[Nothing, Error](error("Bodies can't be in patterns.", pattern.src()))
}
