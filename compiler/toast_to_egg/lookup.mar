| Looking up Functions  

import mod.mar

fun signature(module: Module, name: String, params: Slice[FunParam]): String {
  var b = string_builder().&
  b."{module}.{name}"
  for param in params do
    if param.type == type_type then
      b." {param.name}: {param.type}"
    else
      b." {param.type}"
  b.to_string()
}

struct UncompiledFun {
  name: StringAndSrc, params: Slice[FunParam], impl: UncompiledFunImpl
}
struct FunParam { name: String, type: PlumType }
enum UncompiledFunImpl {
  local: LocalUncompiledFun, imported: String, builtin: Builtin
}
struct LocalUncompiledFun { module: Module, fun_: ToastFun }

fun module(fun_: UncompiledFun): Module {
  switch fun_.impl
  case local(fun_) fun_.module
  case builtin builtin_module
  case imported unreachable()
}

fun collect_all_funs(
  toasts: Map[Module, Toast], types: Map[String, PlumTypeDef]
): Result[Tuple2[Map[String, UncompiledFun], Map[Module, Set[String]]], Error] {
  var funs = map[String, UncompiledFun]()
  var visible = map[Module, Set[String]]()

  for entry in toasts do {
    var module = entry.key
    var toast = entry.value
    var visible_in_this_module = set[String]()

    for def in toast.defs do
      | TODO: handle multiple functions with same signature
      switch def
      case fun_(fun_) {
        var params = list[FunParam]()
        for param in fun_.params do
          params.&.push(FunParam {
            name = param.name.string,
            type = param.type.compile(module, types)?,
          })
        var params = params.to_slice()

        var signature = signature(module, fun_.name.string, params)

        visible_in_this_module.&.put(signature)
        funs.&.put(signature, UncompiledFun {
          name = fun_.name,
          params,
          impl = UncompiledFunImpl.local(LocalUncompiledFun { module, fun_ })
        })
      }
      case import_(import_) {
        for part in import_.parts do {
          var imported_module = module.resolve_import(part.module) or(error)
            return error[
              Tuple2[Map[String, UncompiledFun], Map[Module, Set[String]]],
              Error,
            ](error(
              error, import_.keyword.src
            ))
          for item in part.items do
            if item is fun_(signature) then {
              var params = list[FunParam]()
              for param in signature.args do
                params.&.push(FunParam {
                  name = param.name.string,
                  type = param.type.compile(module, types)?,
                })
              var params = params.to_slice()

              var our_signature =
                signature(module, signature.name.string, params)
              var referred_signature =
                signature(imported_module, signature.name.string, params)

              visible_in_this_module.&.put(our_signature)
              funs.&.put(our_signature, UncompiledFun {
                name = signature.name,
                params,
                impl = UncompiledFunImpl.imported(referred_signature),
              })
            }
        }
      }
      default {}

    visible.&.put(module, visible_in_this_module)
  }
  ok[Tuple2[Map[String, UncompiledFun], Map[Module, Set[String]]], Error](tuple(
    funs, visible
  ))
}

| struct MatchingFun { fun_: ToastFun, substitutions: Substitutions }

| fun name(match: MatchingFun): String { match.fun_.name.string }
| fun param_types(match: MatchingFun): Slice[PlumType] {
|   var types = list[PlumType]()
|   for param in match.fun_.params do
|     types.&.push(param.type.specialize(match.substitutions))
|   types.to_slice()
| }
| fun return_type(match: MatchingFun): PlumType {
|   match.fun_.return_type.specialize(match.substitutions)
| }



| Arguments that have the type Type also have a compile-time-known value.
struct FunArg { value: Maybe[PlumType], type: PlumType }

fun match_against(
  args: Slice[FunArg], params: Slice[FunParam],
  constraints: &TypeVariableConstraints,
): Bool {
  args.len == params.len or return false
  for both in zip(args.iter(), params.iter()) do {
    var arg = both.a
    var param = both.b
    arg.type.match_against(param.type, constraints) or return false
    if arg.type == type_type then {
      eprintln("got a function with a type arg {param.name}: {arg.value.unwrap()}")
      var result = arg.value.unwrap().match_against(
        PlumType.primitive(param.name), constraints
      )
      if not(result) then unreachable()
    }
  }
  true
}
