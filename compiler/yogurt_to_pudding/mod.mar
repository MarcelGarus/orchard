| Converting Yogurt to Pudding  
|
| IDs in the Yogurt and Pudding are the same. Generally, the Pudding is also
| very similar to the Yogurt in terms of abstraction. The only difference is
| that it contains additional dup/drop instructions for incrementing and
| decrementing the reference counts of values.
| Every value in the Pudding is reference counted. Later on, some of the
| reference counting operations are simplified (for example, if a type doesn't
| require any heap allocations, no reference counting occurs because it is
| always copied).

import ../plum.mar

fun put(dag: &Dag[PuddingExpr], id: Id, expr: PuddingExpr): Id {
  dag.nodes.&.set(id.index, expr)
  id
}
fun put_dup(dag: &Dag[PuddingExpr], id: Id): Id {
  dag.put(PuddingOp.dup(id) $ YogurtType.never)
}
fun put_drop(dag: &Dag[PuddingExpr], id: Id): Id {
  dag.put(PuddingOp.drop(id) $ YogurtType.never)
}

fun require(
  rev_body: &List[Id], id: Id, dag: &Dag[PuddingExpr], needed_later_on: &Set[Id]
) {
  if needed_later_on.contains(id) then
    rev_body.push(dag.put_dup(id))
  else
    needed_later_on.put(id)
}

fun to_pudding(
  id: Id,
  fun_: YogurtFun, | TODO: is the DAG enough?
  dag: &Dag[PuddingExpr], rev_body: &List[Id], needed_later_on: &Set[Id],
  yogurt: Yogurt,
) {
  var expr = fun_.dag.get(id)
  var type = expr.type

  if not(needed_later_on.contains(id)) then
    rev_body.&.push(dag.put_drop(id))
  else
    needed_later_on.remove(id)

  switch expr.op
  case param unreachable()
  case uninitialized unreachable()
  case int(int) rev_body.push(dag.put(id, PuddingOp.int(int) $ type))
  case string(string)
    rev_body.push(dag.put(id, PuddingOp.string(string) $ type))
  case struct_(fields) {
    rev_body.push(dag.put(id, PuddingOp.struct_(fields) $ type))
    for field in fields do rev_body.require(field.value, dag, needed_later_on)
  }
  case member(member) {
    if needed_later_on.contains(member.of) then {
      rev_body.push(dag.put_dup(id))
      rev_body.push(dag.put(
        id, PuddingOp.member(PuddingMember {
          of = member.of, name = member.name
        }) $ type
      ))
    } else {
      rev_body.push(dag.put_drop(member.of))
      rev_body.push(dag.put_dup(id))
      rev_body.push(dag.put(
        id, PuddingOp.member(PuddingMember {
          of = member.of, name = member.name
        }) $ type
      ))
      rev_body.require(member.of, dag, needed_later_on)
    }
  }
  case enum_(enum_) {
    rev_body.push(dag.put(
      id, PuddingOp.enum_(PuddingEnum {
        name = enum_.name, value = enum_.value
      }) $ type
    ))
    rev_body.require(enum_.value, dag, needed_later_on)
  }
  case switch_(switch_) {
    | Lower the individual cases.
    var cases = map[String, PuddingBody]()
    var needed_by_branches = map[String, Set[Id]]()
    for case_ in switch_.cases do {
      var needed_by_this_branch = set[Id]()
      for id in needed_later_on do needed_by_this_branch.&.put(id)
      cases.&.put(case_.key, case_.value.to_pudding(
        fun_, dag, needed_by_this_branch.&, yogurt
      ))
      needed_by_branches.&.put(case_.key, needed_by_this_branch)
    }

    | Figure out the IDs that all branches need.
    for entry in needed_by_branches do
      for id in entry.value do needed_later_on.&.put(id)

    | If a branch doesn't use IDs that other branches use, drop those at the
    | start of the branch body.
    for case_ in cases do {
      var needed_by_this_branch = needed_by_branches.get(case_.key)
      var diff_to_other_branches = set[Id]()
      for id in needed_later_on do
        if not(needed_by_this_branch.contains(id)) then
          diff_to_other_branches.&.put(id)

      var drops = list(
        dag.put_dup(case_.value.params.get(0)),
        dag.put_drop(switch_.condition),
      )
      for id in diff_to_other_branches do drops.&.push(dag.put_drop(id))

      cases.&.put(case_.key, PuddingBody {
        params = case_.value.params,
        exprs = {drops + case_.value.exprs.to_list()}.to_slice(),
        returns = case_.value.returns,
      })
    }
    | todo("switch")
    rev_body.push(dag.put(
      id, PuddingOp.switch_(PuddingSwitch {
        condition = switch_.condition, cases
      }) $ type
    ))
    rev_body.require(switch_.condition, dag, needed_later_on)
  }
  case closure(value) {
    rev_body.push(dag.put(id, PuddingOp.closure(value) $ type))
    rev_body.require(value, dag, needed_later_on)
  }
  case get_closure(closure) {
    rev_body.push(dag.put_drop(closure))
    rev_body.push(dag.put_dup(id))
    rev_body.push(dag.put(id, PuddingOp.get_closure(closure) $ type))
    rev_body.require(closure, dag, needed_later_on)
  }
  case lambda(lambda) {
    rev_body.push(dag.put(
      id, PuddingOp.lambda(PuddingLambda {
        function = lambda.function, closure = lambda.closure
      }) $ type
    ))
    rev_body.require(lambda.closure, dag, needed_later_on)
  }
  case call(call) {
    switch call.callee
    case lambda(lambda) {
      rev_body.push(dag.put(
        id, PuddingOp.lambda_call(PuddingLambdaCall {
          lambda, args = call.args
        }) $ type
      ))
      rev_body.require(lambda, dag, needed_later_on)
    }
    case fun_(fun_)
      rev_body.push(dag.put(
        id, PuddingOp.call(PuddingCall {
          function = fun_, args = call.args
        }) $ type
      ))
    case builtin(builtin) {
      rev_body.push(dag.put(
        id, PuddingOp.instruction(PuddingInstruction {
          instruction =
            switch builtin
            case add_ints Instruction.add_ints
            case sub_ints Instruction.sub_ints
            case mul_ints Instruction.mul_ints
            case div_ints Instruction.div_ints
            case mod_ints Instruction.mod_ints
            case and_ints Instruction.and_ints
            case or_ints Instruction.or_ints
            case xor_ints Instruction.xor_ints
            case compare_ints Instruction.compare_ints
            case filled_array Instruction.filled_array
            case array_get Instruction.array_get
            case array_set Instruction.array_set
            case array_slice Instruction.array_slice
            case array_len Instruction.array_len
            case concat_strings Instruction.concat_strings
            case crash Instruction.crash,
          args = call.args,
        }) $ type
      ))
    }
    for arg in call.args do rev_body.require(arg, dag, needed_later_on)
  }
  case type(ty) rev_body.push(dag.put(id, PuddingOp.type(ty) $ type))
}

fun to_pudding(
  body: YogurtBody,
  fun_: YogurtFun, | TODO: is the DAG enough?
  dag: &Dag[PuddingExpr],
  needed_later_on: &Set[Id], | which yogurt ids are needed later on
  yogurt: Yogurt, | TODO: is this needed?
): PuddingBody {
  var rev_body = list[Id]()

  rev_body.&.require(body.returns, dag, needed_later_on)

  for id in body.children.rev_iter() do
    id.to_pudding(fun_, dag, rev_body.&, needed_later_on, yogurt)

  var params = list[Id]()
  for param in body.params do {
    if not(needed_later_on.contains(param)) then
      rev_body.&.push(dag.put_drop(param))
    else
      needed_later_on.remove(param)
    params.&.push(dag.put(param, PuddingOp.param $ fun_.dag.type_of(param)))
  }
  var params = params.to_slice()

  var exprs = list[Id]()
  for id in rev_body.to_slice().rev_iter() do exprs.&.push(id)
  var exprs = exprs.to_slice()

  PuddingBody { params, exprs, returns = body.returns }
}

fun to_pudding(fun_: YogurtFun, yogurt: Yogurt, pudding: &Pudding): PuddingFun {
  var dag = dag[PuddingExpr]()

  | The IDs in the Yogurt and Pudding are the same. So, we first reserve IDs for
  | all Yogurt expressions so that the additional dup/drop expressions get
  | bigger IDs.
  for i in 0..{fun_.dag.nodes.len} do
    dag.&.put(PuddingOp.uninitialized $ YogurtType.never)

  var body = fun_.body.to_pudding(fun_, dag.&, set[Id]().&, yogurt)

  PuddingFun { dag, body }
}

fun to_pudding(yogurt: Yogurt): Pudding {
  var pudding = pudding()
  for fun_ in yogurt.funs do {
    | eprintln("Compiling {fun_.key}")
    pudding.funs.&.put(fun_.key, fun_.value.to_pudding(yogurt, pudding.&))
  }
  pudding
}
