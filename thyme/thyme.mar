import ../../martinaise/stdlib.mar

| Code represents human-readable code.

enum Code {
  name: String,
  int: Int,
  struct_: Map[String, Code],
  enum_: EnumCode,
  lambda: LambdaCode,
  call: CallCode,
}
struct EnumCode { variant: String, payload: &Code }
struct LambdaCode { params: Slice[String], body: &Code }
struct CallCode { callee: &Code, args: Slice[Code] }

fun captured_names(lambda: LambdaCode): Set[String] {
  var captured = set[String]()
  lambda.collect_captured(captured.&, set[String]())
  captured
}
fun collect_captured(code: Code, out: &Set[String], ignore: Set[String]) {
  switch code
  case name(name) if not(ignore.contains(name)) then out.put(name)
  case int {}
  case struct_(fields)
    for field in fields do field.value.collect_captured(out, ignore)
  case enum_(enum_) enum_.payload.collect_captured(out, ignore)
  case lambda(lambda) lambda.collect_captured(out, ignore)
  case call(call) {
    call.callee.collect_captured(out, ignore)
    for arg in call.args do arg.collect_captured(out, ignore)
  }
}
fun collect_captured(
  lambda: LambdaCode, out: &Set[String], ignore: Set[String]
) {
  var inner_ignore = set[String]()
  for i in ignore do inner_ignore.&.put(i)
  for param in lambda.params do inner_ignore.&.put(param)
  lambda.body.collect_captured(out, inner_ignore)
}

fun write[W](writer: W, code: Code) {
  switch code
  case name(name) writer."{name}"
  case object(object) writer."{object.*}"
  case int(int) writer."{int}"
  case struct_(struct_) {
    writer."(&"
    for field in struct_ do writer." {field.key}: {field.value}"
    writer.")"
  }
  case enum_(enum_) {
    writer."(| {enum_.variant}: {enum_.payload})"
  }
  case lambda(lambda) {
    writer."(\\"
    for param in lambda.params do writer." {param}"
    writer." -> {lambda.body.*})"
  }
  case call(call) {
    writer."({call.callee}"
    for arg in call.args do writer." {arg}"
    writer.")"
  }
}

| All Thyme objects are stored in a heap. Semantically, each object is just a
| slice of bytes. The first byte tells us the type of the object and what the
| other bytes mean.

struct Heap { objects: List[Slice[Int]] }

| Types of object       memory layout
var tag_int      = 0  | 0 int
var tag_words    = 1  | 1 length byte byte ...
var tag_array    = 2  | 2 length item item ...
var tag_struct   = 3  | 3 fields(array[array[int]]) value value ...
var tag_enum     = 4  | 4 variant(array[int]) payload
var tag_function = 5  | 5 num_args ptr_to_ir
var tag_lambda   = 6  | 6 function closure(array)

fun heap(): Heap { Heap { objects = list[Slice[Int]]() } }
fun new(heap: &Heap, words: Slice[Int]): Int {
  var object_id = heap.objects.len
  heap.objects.&.push(words)
  object_id
}
fun get(heap: Heap, object_id: Int, offset: Int): Int {
  heap.objects.get(object_id).get(offset)
}

fun write[W](writer: W, heap: Heap) { writer.write(heap, 0) }
fun write[W](writer: W, heap: Heap, skip: Int) {
  var first = true
  for object in heap.objects.iter().enumerate().skip(skip) do {
    if first then first = false else writer."\n"
    writer."{"${object.index}".pad_left(4)}: "
    var object = object.item

    var tag = object.get(0)

    if tag == tag_int then writer."int {object.get(1)}"
    else if tag == tag_words then {
      writer."bytes"
      var len = object.get(1)
      for i in 0..len do writer." {object.get(2 + i)}"
    }
    else if tag == tag_array then {
      writer."array"
      var len = object.get(1)
      for i in 0..len do writer." ${object.get(2 + i)}"
    }
    else if tag == tag_struct then {
      writer."struct ${object.get(1)}"
      var num_fields = heap.get(object.get(1), 1)
      for i in 0..{num_fields} do writer." ${object.get(2 + i)}"
    }
    else if tag == tag_enum then
      writer."enum ${object.get(1)}: ${object.get(2)}"
    else if tag == tag_function then {
      writer."fun\n      "
      writer.write(object.get(2).to_address().to_reference[Ir]().*, 3)
    }
    else if tag == tag_lambda then
      writer."lambda ${object.get(1)} ${object.get(2)}"
    else writer."object with unknown tag {tag}"
  }
}

| Code is compiled into the Ir.

struct Ir { nodes: Slice[IrNode], params: Slice[IrId], body: IrBody }
struct IrId { index: Int }
struct IrBody { ids: Slice[IrId], returns: IrId }
enum IrNode {
  param,
  word: Int,
  obj: Int,
  new: Slice[IrId],                     | words
  load: Tuple2[IrId, IrId],             | base pointer, offset
  add: Tuple2[IrId, IrId],              | left, right
  subtract: Tuple2[IrId, IrId],         | left, right
  multiply: Tuple2[IrId, IrId],         | left, right
  divide: Tuple2[IrId, IrId],           | left, right
  modulo: Tuple2[IrId, IrId],           | left, right
  compare: Tuple2[IrId, IrId],          | left, right
  call: Tuple2[IrId, Slice[IrId]],      | callee, args
  switch_: Tuple2[IrId, Slice[IrBody]], | condition, cases
  crash: IrId,                          | message
}

fun get(ir: Ir, id: IrId): IrNode { ir.nodes.get(id.index) }

fun ==(a: IrId, b: IrId): Bool { a.index == b.index }
fun hash(hasher: &Hasher, id: IrId) { hasher.hash(id.index) }

fun ==(a: IrBody, b: IrBody): Bool {
  a.ids == b.ids and a.returns == b.returns
}
fun ==(a: IrNode, b: IrNode): Bool {
  switch a
  case param       b is param
  case word(a)     if b is word(b)     then a == b else false
  case obj(a)      if b is obj(b)      then a == b else false
  case new(a)      if b is new(b)      then a == b else false
  case load(a)     if b is load(b)     then a == b else false
  case add(a)      if b is add(b)      then a == b else false
  case subtract(a) if b is subtract(b) then a == b else false
  case multiply(a) if b is multiply(b) then a == b else false
  case divide(a)   if b is divide(b)   then a == b else false
  case modulo(a)   if b is modulo(b)   then a == b else false
  case compare(a)  if b is compare(b)  then a == b else false
  case call(a)     if b is call(b)     then a == b else false
  case switch_(a)  if b is switch_(b)  then a == b else false
  case crash(a)    if b is crash(b)    then a == b else false
}

fun write[W](writer: W, id: IrId) { writer."%{id.index}" }
fun write[W](writer: W, ir: Ir) { writer.write(ir, 0) }
fun write[W](writer: W, ir: Ir, indentation: Int) {
  writer."code"
  for param in ir.params do writer." {param}"
  writer.write(ir.body, ir, indentation + 1)
}
fun write[W](writer: W, body: IrBody, ir: Ir, indentation: Int) {
  for id in body.ids do {
    writer."\n"
    for i in 0..indentation do writer."  "
    writer."{id} = "
    writer.write(ir.get(id), ir, indentation)
  }
  writer."\n"
  for i in 0..indentation do writer."  "
  writer."{body.returns}"
}
fun write[W](writer: W, node: IrNode, ir: Ir, indentation: Int) {
  switch node
  case param writer."param"
  case word(word) writer."word {word}"
  case obj(obj) writer."obj ${obj}"
  case new(words) {
    writer."new"
    for word in words do writer." {word}"
  }
  case load(args) writer."load {args.a} {args.b}"
  case add(args) writer."add {args.a} {args.b}"
  case subtract(args) writer."subtract {args.a} {args.b}"
  case multiply(args) writer."multiply {args.a} {args.b}"
  case divide(args) writer."divide {args.a} {args.b}"
  case modulo(args) writer."modulo {args.a} {args.b}"
  case compare(args) writer."compare {args.a} {args.b}"
  case call(call) {
    writer."call {call.a} with"
    for arg in call.b do writer." {arg}"
  }
  case switch_(switch_) {
    writer."switch {switch_.a}"
    for case_ in switch_.b.iter().enumerate() do {
      writer."\n"
      for i in 0..indentation do writer."  "
      writer."  case {case_.index}"
      writer.write(case_.item, ir, indentation + 2)
    }
  }
  case crash(message) writer."crash {message}"
}

| Compiling code into the IR.

struct IrBuilder { nodes: List[IrNode], params: List[IrId] }
struct IrBodyBuilder {
  parent: &IrBuilder, ids: List[IrId], bindings: List[Tuple2[String, IrId]]
}

fun ir_builder(): IrBuilder {
  IrBuilder { nodes = list[IrNode](), params = list[IrId]() }
}
fun body(builder: &IrBuilder): IrBodyBuilder {
  IrBodyBuilder {
    parent = builder,
    ids = list[IrId](),
    bindings = list[Tuple2[String, IrId]](),
  }
}
fun create(builder: &IrBuilder, node: IrNode): IrId {
  var id = IrId { index = builder.nodes.len }
  builder.nodes.&.push(node)
  id
}
fun create_and_push(body: &IrBodyBuilder, node: IrNode): IrId {
  var id = body.parent.create(node)
  body.ids.&.push(id)
  id
}
fun child_body(body: IrBodyBuilder): IrBodyBuilder {
  IrBodyBuilder { parent = body.parent, ids = list[IrId](), bindings = body.bindings }
}
fun get(body: IrBodyBuilder, id: IrId): IrNode { body.parent.nodes.get(id.index) }
fun bind(body: &IrBodyBuilder, name: String, id: IrId) {
  body.bindings.&.push(tuple(name, id))
}
fun get(body: &IrBodyBuilder, name: String): IrId {
  for binding in body.bindings do
    if binding.a == name then return binding.b
  panic("{name} not in scope")
}
fun finish(body: IrBodyBuilder, returns: IrId): IrBody {
  IrBody { ids = body.ids.to_slice(), returns }
}
fun finish(builder: IrBuilder, body: IrBody): Ir {
  Ir {
    nodes = builder.nodes.to_slice(), params = builder.params.to_slice(), body
  }
}

fun param(builder: &IrBuilder): IrId {
  var id = builder.create(IrNode.param)
  builder.params.&.push(id)
  id
}
fun word(body: &IrBodyBuilder, word: Int): IrId {
  body.create_and_push(IrNode.word(word))
}
fun obj(body: &IrBodyBuilder, obj: Int): IrId {
  body.create_and_push(IrNode.obj(obj))
}
fun new(body: &IrBodyBuilder, words: Slice[IrId]): IrId {
  body.create_and_push(IrNode.new(words))
}
fun load(body: &IrBodyBuilder, base: IrId, offset: IrId): IrId {
  body.create_and_push(IrNode.load(tuple(base, offset)))
}
fun add(body: &IrBodyBuilder, left: IrId, right: IrId): IrId {
  body.create_and_push(IrNode.add(tuple(left, right)))
}
fun subtract(body: &IrBodyBuilder, left: IrId, right: IrId): IrId {
  body.create_and_push(IrNode.subtract(tuple(left, right)))
}
fun multiply(body: &IrBodyBuilder, left: IrId, right: IrId): IrId {
  body.create_and_push(IrNode.multiply(tuple(left, right)))
}
fun divide(body: &IrBodyBuilder, left: IrId, right: IrId): IrId {
  body.create_and_push(IrNode.divide(tuple(left, right)))
}
fun modulo(body: &IrBodyBuilder, left: IrId, right: IrId): IrId {
  body.create_and_push(IrNode.modulo(tuple(left, right)))
}
fun compare(body: &IrBodyBuilder, left: IrId, right: IrId): IrId {
  body.create_and_push(IrNode.compare(tuple(left, right)))
}
fun call(body: &IrBodyBuilder, callee: IrId, args: Slice[IrId]): IrId {
  body.create_and_push(IrNode.call(tuple(callee, args)))
}
fun switch_(body: &IrBodyBuilder, condition: IrId, cases: Slice[IrBody]): IrId {
  body.create_and_push(IrNode.switch_(tuple(condition, cases)))
}
fun crash(body: &IrBodyBuilder, message: IrId): IrId {
  body.create_and_push(IrNode.crash(message))
}

fun new_words(body: &IrBodyBuilder, words: Slice[IrId]): IrId {
  var words = list(body.word(tag_words))
  words.&.push(body.word(words.len))
  for word in words do words.&.push(word)
  body.new(words.to_slice())
}
fun new_string(body: &IrBodyBuilder, string: String): IrId {
  var words = list[IrId]()
  for byte in string.bytes() do words.&.push(body.word(byte.to_int()))
  body.new_words(words.to_slice())
}

fun assert_equals(body: &IrBodyBuilder, a: IrId, b: IrId) {
  body.switch_(
    body.compare(a, b),
    list(
      body.child_body().finish_with_zero(),
      body.child_body().finish_with_crash("assert failed"),
      body.child_body().finish_with_crash("assert failed"),
    ).to_slice(),
  ).ignore()
}

fun new_int(body: &IrBodyBuilder, value: IrId): IrId {
  body.new(list(body.word(tag_int), value).to_slice())
}
fun assert_is_int(body: &IrBodyBuilder, obj: IrId) {
  body.assert_equals(body.load(obj, body.word(0)), body.word(tag_int))
}
fun get_int_value(body: &IrBodyBuilder, int: IrId): IrId {
  body.load(int, body.word(1))
}

fun new_array(body: &IrBodyBuilder, items: Slice[IrId]): IrId {
  var words = list(body.word(tag_array), body.word(items.len))
  for item in items do words.&.push(item)
  body.new(words.to_slice())
}

fun new_struct(body: &IrBodyBuilder, fields: Map[String, IrId]): IrId {
  var fields_object = {
    var field_names = list[IrId]()
    for field in fields do
      field_names.&.push(body.new_string(field.key))
    body.new_array(field_names.to_slice())
  }
  var words = list(body.word(tag_struct), fields_object)
  for field in fields do words.&.push(field.value)
  body.new(words.to_slice())
}

fun new_enum(body: &IrBodyBuilder, variant: String, payload: IrId): IrId {
  body.new(list(
    body.word(tag_enum), body.new_string(variant), payload
  ).to_slice())
}

fun new_fun(body: &IrBodyBuilder, ir: Ir): IrId {
  body.new(list(
    body.word(tag_function),
    body.word(ir.params.len),
    body.word(ir.put_on_heap().to_address().to_int()),
  ).to_slice())
}

fun new_closure(body: &IrBodyBuilder, captured: Slice[IrId]): IrId {
  var words = list(body.word(tag_array), body.word(captured.len))
  for capture in captured do words.&.push(capture)
  body.new(words.to_slice())
}
fun get_closure_var(body: &IrBodyBuilder, closure: IrId, index: Int): IrId {
  body.load(closure, body.word(2 + index))
}

fun new_lambda(body: &IrBodyBuilder, fun_: IrId, closure: IrId): IrId {
  body.new(list(body.word(tag_lambda), fun_, closure).to_slice())
}
fun assert_is_lambda(body: &IrBodyBuilder, obj: IrId) {
  body.assert_equals(body.load(obj, body.word(0)), body.word(tag_lambda))
}
fun get_lambda_fun(body: &IrBodyBuilder, lambda: IrId): IrId {
  body.load(lambda, body.word(1))
}
fun get_lambda_closure(body: &IrBodyBuilder, lambda: IrId): IrId {
  body.load(lambda, body.word(2))
}

fun finish_with_zero(body: IrBodyBuilder): IrBody {
  body.finish(body.&.word(0))
}
fun finish_with_crash(body: IrBodyBuilder, message: String): IrBody {
  body.finish(body.&.crash(body.&.new_string(message)))
}

fun compile(body: &IrBodyBuilder, code: Code): IrId {
  switch code
  case name(name) body.get(name)
  case int(int) body.new_int(body.word(int))
  case struct_(struct_) {
    var fields = map[String, IrId]()
    for field in struct_ do fields.&.put(field.key, body.compile(field.value))
    body.new_struct(fields)
  }
  case enum_(enum_) body.new_enum(enum_.variant, body.compile(enum_.payload.*))
  case lambda(lambda) {
    var captured = lambda.captured_names()
    body.new_lambda(
      {
        var inner = ir_builder().&
        var params = list[IrId]()
        for param in lambda.params do params.&.push(inner.param())
        var closure = inner.param()

        var inner_body = inner.body().&
        for param in zip(lambda.params.iter(), params.iter()) do
          inner_body.bind(param.a, param.b)
        for capture in captured.iter().enumerate() do
          inner_body.bind(
            capture.item, inner_body.get_closure_var(closure, capture.index)
          )
        var ir = inner.finish(
          inner_body.finish(inner_body.compile(lambda.body.*))
        )
        body.new_fun(ir)
      },
      {
        var captured_ids = list[IrId]()
        for capture in captured do captured_ids.&.push(body.get(capture))
        body.new_closure(captured_ids.to_slice())
      },
    )
  }
  case call(call) {
    var lambda = body.compile(call.callee.*)
    body.assert_is_lambda(lambda)
    var args = list[IrId]()
    for arg in call.args do args.&.push(body.compile(arg))
    args.&.push(body.get_lambda_closure(lambda))
    body.call(body.get_lambda_fun(lambda), args.to_slice())
  }
}

| Optimizing

fun optimize(object: Int, heap: &Heap): Int {
  var tag = heap.get(object, 0)

  if tag == tag_int then object
  else if tag == tag_array then {
    var len = heap.get(object, 1)
    var items = list[Int](tag_array, len)
    for i in 0..len do items.&.push(heap.get(object, 2 + i).optimize(heap))
    heap.new(items.to_slice())
  }
  else if tag == tag_struct then {
    var num_fields = heap.get(heap.get(object, 1), 1)
    var fields = list[Int]()
    for i in 0..{num_fields} do
      fields.&.push(heap.get(object, 2 + i).optimize(heap))
    heap.new({list(tag_struct, heap.get(object, 1)) + fields}.to_slice())
  }
  else if tag == tag_enum then
    heap.new(list(
      tag_enum, heap.get(object, 1), heap.get(object, 2).optimize(heap)
    ).to_slice())
  else if tag == tag_function then object
  else if tag == tag_lambda then {
    var fun_ = heap.get(object, 1)
    var num_params = heap.get(fun_, 1)
    var closure = heap.get(object, 2)
    var num_captured = heap.get(closure, 1)
    if num_captured == 0 then object else {
      var builder = ir_builder().&
      var args = list[IrId]()
      for param in 0..num_params do args.&.push(builder.param())
      var body = builder.body().&
      args.&.last_ref().* = body.obj(closure)
      var result = body.call(body.obj(fun_), args.to_slice())
      var ir = builder.finish(body.finish(result))
      var ir = ir.optimize(heap)
      heap.new(list(
        tag_lambda,
        heap.new(list(
          tag_function, num_params, ir.put_on_heap().to_address().to_int()
        ).to_slice()),
        heap.new(list(tag_array, 0).to_slice())
      ).to_slice())
    }
  }
  else todo("object with unknown tag {tag}")
}
fun optimize(ir: Ir, heap: &Heap): Ir {
  var new = ir_builder().&
  var mapping = map[IrId, IrId]().&
  for param in ir.params do mapping.put(param, new.param())
  var new_body = ir.body.optimize(ir, new, mapping, list[IrId]().&, heap)
  new.finish(new_body)
}
fun optimize(
  body: IrBody, ir: Ir, new_ir: &IrBuilder, mapping: &Map[IrId, IrId],
  in_scope: &List[IrId], heap: &Heap,
): IrBody {
  var num_in_scope = in_scope.len
  var new = new_ir.body().&
  for id in body.ids do
    mapping.put(id, id.optimize(ir, new, mapping, in_scope, heap))
  in_scope.len = num_in_scope
  new.finish(mapping.get(body.returns))
}
fun optimize(
  id: IrId, ir: Ir, new_ir: &IrBodyBuilder, mapping: &Map[IrId, IrId],
  in_scope: &List[IrId], heap: &Heap,
): IrId {
  var new =
    switch ir.get(id)
    case param unreachable()
    case word(word) IrNode.word(word)
    case obj(obj) IrNode.obj(obj)
    case new(new) {
      var words = list[IrId]()
      for word in new do words.&.push(mapping.get(word))
      IrNode.new(words.to_slice())
    }
    case load(args) IrNode.load(tuple(mapping.get(args.a), mapping.get(args.b)))
    case add(args) IrNode.add(tuple(mapping.get(args.a), mapping.get(args.b)))
    case subtract(args)
      IrNode.subtract(tuple(mapping.get(args.a), mapping.get(args.b)))
    case multiply(args)
      IrNode.multiply(tuple(mapping.get(args.a), mapping.get(args.b)))
    case divide(args)
      IrNode.divide(tuple(mapping.get(args.a), mapping.get(args.b)))
    case modulo(args)
      IrNode.modulo(tuple(mapping.get(args.a), mapping.get(args.b)))
    case compare(args)
      IrNode.compare(tuple(mapping.get(args.a), mapping.get(args.b)))
    case call(call) {
      var callee = mapping.get(call.a)
      var args = list[IrId]()
      for arg in call.b do args.&.push(mapping.get(arg))
      IrNode.call(tuple(callee, args.to_slice()))
    }
    case switch_(switch_) {
      var cases = list[IrBody]()
      for case_ in switch_.b do
        cases.&.push(case_.optimize(ir, new_ir.parent, mapping, in_scope, heap))
      IrNode.switch_(tuple(mapping.get(switch_.a), cases.to_slice()))
    }
    case crash(message) IrNode.crash(mapping.get(message))
  var new = new.optimize_mapped(new_ir, in_scope, heap)
  in_scope.push(new)
  new
}
fun optimize_mapped(
  node: IrNode, body: &IrBodyBuilder, in_scope: &List[IrId], heap: &Heap
): IrId {
  | Deduplicate
  for id in in_scope do if body.get(id) == node then return id

  switch node
  case param unreachable()
  case word(word) body.word(word)
  case obj(obj) body.obj(obj)
  case new(words) {
    | Create the value directly.
    var all_known = true
    for word in words do
      if not({body.get(word) is word} or {body.get(word) is obj}) then
        all_known = false
    if all_known then {
      var known_words = list[Int]()
      for word in words do
        known_words.&.push(
          switch body.get(word)
          case word(word) word
          case obj(obj) obj
          default panic()
        )
      return body.obj(heap.new(known_words.to_slice()))
    }

    body.new(words)
  }
  case load(args) body.load(args.a, args.b)
  case add(args) body.add(args.a, args.b)
  case subtract(args) body.subtract(args.a, args.b)
  case multiply(args) body.multiply(args.a, args.b)
  case divide(args) body.divide(args.a, args.b)
  case modulo(args) body.modulo(args.a, args.b)
  case compare(args) body.compare(args.a, args.b)
  case call(call) {
    var callee = call.a
    var args = call.b
    if body.get(callee) is word(fun_) then {
      var ir = heap.get(fun_, 1).to_address().to_reference[Ir]().&
      var mapping = map[IrId, IrId]()
      for both in zip(ir.params.iter(), args.iter()) do
        mapping.&.put(both.a, both.b)
      | for id in ir.body.ids do
      |   body.word(123)
      | return body.word(123)
      todo("call")
    }
    body.call(callee, args)
  }
  case switch_(switch_) {
    body.switch_(switch_.a, switch_.b)
  }
  case crash(message) body.crash(message)
}

| Running Code

struct Vm { heap: Heap, bindings: Map[String, Int], heap_printed: Int }
fun vm(): Vm {
  var vm = Vm { heap = heap(), bindings = map[String, Int](), heap_printed = 0 }

  var empty_closure = vm.heap.&.new(list(tag_array, 0).to_slice())

  var add_lambda = vm.heap.&.new(list(
    tag_lambda,
    vm.heap.&.new(list(tag_function, 3, {
      var builder = ir_builder().&
      var a = builder.param()
      var b = builder.param()
      var closure = builder.param()
      var body = builder.body().&
      body.assert_is_int(a)
      body.assert_is_int(b)
      var a = body.get_int_value(a)
      var b = body.get_int_value(b)
      builder.finish(body.finish(body.new_int(body.add(a, b))))
    }.optimize(vm.heap.&).put_on_heap().to_address().to_int()).to_slice()),
    empty_closure,
  ).to_slice())

  var subtract_lambda = vm.heap.&.new(list(
    tag_lambda,
    vm.heap.&.new(list(tag_function, 3, {
      var builder = ir_builder().&
      var a = builder.param()
      var b = builder.param()
      var closure = builder.param()
      var body = builder.body().&
      body.assert_is_int(a)
      body.assert_is_int(b)
      var a = body.get_int_value(a)
      var b = body.get_int_value(b)
      builder.finish(body.finish(body.new_int(body.subtract(a, b))))
    }.optimize(vm.heap.&).put_on_heap().to_address().to_int()).to_slice()),
    empty_closure,
  ).to_slice())

  var multiply_lambda = vm.heap.&.new(list(
    tag_lambda,
    vm.heap.&.new(list(tag_function, 3, {
      var builder = ir_builder().&
      var a = builder.param()
      var b = builder.param()
      var closure = builder.param()
      var body = builder.body().&
      body.assert_is_int(a)
      body.assert_is_int(b)
      var a = body.get_int_value(a)
      var b = body.get_int_value(b)
      builder.finish(body.finish(body.new_int(body.multiply(a, b))))
    }.optimize(vm.heap.&).put_on_heap().to_address().to_int()).to_slice()),
    empty_closure,
  ).to_slice())

  var divide_lambda = vm.heap.&.new(list(
    tag_lambda,
    vm.heap.&.new(list(tag_function, 3, {
      var builder = ir_builder().&
      var a = builder.param()
      var b = builder.param()
      var closure = builder.param()
      var body = builder.body().&
      body.assert_is_int(a)
      body.assert_is_int(b)
      var a = body.get_int_value(a)
      var b = body.get_int_value(b)
      builder.finish(body.finish(body.new_int(body.divide(a, b))))
    }.optimize(vm.heap.&).put_on_heap().to_address().to_int()).to_slice()),
    empty_closure,
  ).to_slice())

  var modulo_lambda = vm.heap.&.new(list(
    tag_lambda,
    vm.heap.&.new(list(tag_function, 3, {
      var builder = ir_builder().&
      var a = builder.param()
      var b = builder.param()
      var closure = builder.param()
      var body = builder.body().&
      body.assert_is_int(a)
      body.assert_is_int(b)
      var a = body.get_int_value(a)
      var b = body.get_int_value(b)
      builder.finish(body.finish(body.new_int(body.modulo(a, b))))
    }.optimize(vm.heap.&).put_on_heap().to_address().to_int()).to_slice()),
    empty_closure,
  ).to_slice())

  vm.bindings.&.put("+", add_lambda)
  vm.bindings.&.put("-", subtract_lambda)
  vm.bindings.&.put("*", multiply_lambda)
  vm.bindings.&.put("/", divide_lambda)
  vm.bindings.&.put("mod", modulo_lambda)
  vm
}
fun print_heap_updates(vm: &Vm) {
  stderr.write(vm.heap, vm.heap_printed)
  vm.heap_printed = vm.heap.objects.len
  eprintln()
}
fun eval(vm: &Vm, name: String, code: Code) {
  var builder = ir_builder().&
  var body = builder.body().&
  for binding in vm.bindings do
    body.bindings.&.push(tuple(
      binding.key, body.create_and_push(IrNode.obj(binding.value))
    ))
  var ir = builder.finish(body.finish(body.compile(code))).optimize(vm.heap.&)
  eprintln("defining {name}")
  eprintln(ir)
  var result = ir.run(vm.heap.&, empty_slice[Int]()).optimize(vm.heap.&)
  vm.bindings.&.put(name, result)
  vm.print_heap_updates()
}
fun run(ir: Ir, heap: &Heap, args: Slice[Int]): Int {
  var env = map[IrId, Int]()
  for both in zip(ir.params.iter(), args.iter()) do
    env.&.put(both.a, both.b)
  ir.body.run(ir, heap, env.&)
}
fun run(body: IrBody, ir: Ir, heap: &Heap, env: &Map[IrId, Int]): Int {
  for id in body.ids do env.put(id, id.run(ir, heap, env))
  env.get(body.returns)
}
fun run(id: IrId, ir: Ir, heap: &Heap, env: &Map[IrId, Int]): Int {
  switch ir.get(id)
  case param unreachable()
  case word(word) word
  case obj(obj) obj
  case new(new) {
    var words = list[Int]()
    for word in new do words.&.push(env.get(word))
    heap.new(words.to_slice())
  }
  case load(load) heap.get(env.get(load.a), env.get(load.b))
  case add(args) env.get(args.a) + env.get(args.b)
  case subtract(args) env.get(args.a) - env.get(args.b)
  case multiply(args) env.get(args.a) * env.get(args.b)
  case divide(args) env.get(args.a) / env.get(args.b)
  case modulo(args) env.get(args.a) % env.get(args.b)
  case compare(args) {
    switch env.get(args.a) <=> env.get(args.b)
    case equal 0
    case greater 1
    case less 2
  }
  case call(call) {
    var callee = env.get(call.a)
    var args = list[Int]()
    for arg in call.b do args.&.push(env.get(arg))
    var ir = heap.get(callee, 1).to_address().to_reference[Ir]().*
    ir.run(heap, args.to_slice())
  }
  case switch_(switch_) {
    var condition = env.get(switch_.a)
    switch_.b.get(condition).run(ir, heap, env)
  }
  case crash(crash) todo("crash")
}

fun main() {
  eprintln("Welcome to the Thyme compiler!")

  var vm = vm()
  vm.&.print_heap_updates()
  vm.&.eval("two", Code.int(2))
  vm.&.eval("point", Code.struct_(map(
    "x" -> Code.name("two"), "y" -> Code.int(4)
  )))
  vm.&.eval("true", Code.enum_(EnumCode {
    variant = "true", payload = Code.struct_(map[String, Code]()).put_on_heap()
  }))
  vm.&.eval("identity", Code.lambda(LambdaCode {
    params = list("x").to_slice(), body = Code.name("x").put_on_heap()
  }))
  vm.&.eval("inc", Code.lambda(LambdaCode {
    params = list("a").to_slice(),
    body = Code.call(CallCode {
      callee = Code.name("+").put_on_heap(),
      args = list(Code.name("a"), Code.int(1)).to_slice(),
    }).put_on_heap(),
  }))
  vm.&.eval("three", Code.call(CallCode {
    callee = Code.name("inc").put_on_heap(),
    args = list(Code.name("two")).to_slice(),
  }))
}
