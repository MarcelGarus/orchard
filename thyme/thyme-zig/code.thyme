(:
  # (
  intro (:
    # (There are 64-bit, signed integer number literals.)
    _ 1
    # (There are Unicode strings.)
    _ "Hello, world!"
    # (There are structs and you can access their members.)
    _ (& foo 1 bar 2)
    _ (. (& x 1 y 2) x)
    # (There are enums and you can switch on them.)
    _ (| foo)
    _ (% (| foo 1) foo 2 bar 4)
    # (You can define new variables.)
    _ (: a 4 a)
    _ (: a 4 b (& x a y a) (. b x))
    0
  )
  )

  nil (&)

  true (| true)
  false (| false)

  crash (\ (message) ((. @ crash) message))
  unreachable (\ () (crash "unreachable"))
  ... (\ () (crash "todo"))
  assert (\ (check) (% check true nil false (crash "assert failed")))

  _ (assert true)

  + (\ (a b) ((. @ add) a b))
  - (\ (a b) ((. @ subtract) a b))
  * (\ (a b) ((. @ multiply) a b))
  / (\ (a b) ((. @ divide) a b))
  mod (\ (a b) ((. @ modulo) a b))

  rec (\ (state fun) (: rec (\ (rec state) (fun (\ (state) (rec rec state)) state)) (rec rec state)))

  # (Linked Lists)
  empty_list (| empty)
  cons (\ (head tail) (| more (& head head tail tail)))
  push (\ (list item)
    (rec list (\ (rec list) (% list empty (cons item empty_list) (more m) (cons (. m head) (rec (. m tail)))))))

  # (Strings)
  # (Sort of built into the language.)
  string_get (. @ string_get)

  # (Parsing)
  parse (\ (text) (:
    # (The parsers take an index into the text and return (& index: Int result: ...))
    parse_number (\ (i) (:
      rec (\ (rec so_far i) (...))
      (rec rec 0 i)))
    parse_string (...)
    parse_word (...)
    parse_exprs (...)
    parse_expr (...)
    specialize (...)
    (specialize (. (parse_expr (& exprs parse_exprs expr parse_expr) 0) result))
  ))

  # (push (push empty_list 1) 2)
  ((. @ compare) 1 2)
)


parse = |text| {
  parse_number_rec = |rec, so_far, i| {
    char = text.get_char(i)
    if char.>=("0").and(char.<=("9")) then
      rec(rec, so_far.*(10).+(char.-("0")), i.+(1))
    else
      [so_far i]
  }
  parse_number = |i| parse_number_rec(parse_number_rec, 0, i)
  parse_string = |i| {}
  parse_word_rec = |rec, i| {
    char = text.get_char(i)
    if char.==(" ").or(char.==(10)).or(char.==("(")).or(char.==(")")) then [nil i] else {
      rest = rec(rec, i.+(1))
      [cons(char, rest:0) rest:1]
    }
  }
  parse_word = |i| parse_word_rec(parse_word_rec, i)
  # parsers will contain parsers for [exprs expr]
  parse_exprs = |parsers, i| {
    char = text.get_char(i)
    if char.==(" ").or(char.==(10)) then parsers:0(parsers, i.+(1))
    else if char.==(")") then [nil i]
    else {
      parsed = parsers:1(parsers, i)
      expr = parsed:0
      new_i = parsed:1
      rest = parsers:0(parsers, new_i)
      [cons(expr, rest:0) rest:1]
    }
  }
  parse_expr = |parsers, i| {
    char = text.get_char(i)
    if char.>=("0").and(char.<=("9")) then {
      parsed = parse_number(i)
      [["number" parsed:0] parsed:1]
    }
    #else if char.==(""") then parse_string(i)
    else if char.==("(") then {
      parsed = parsers:0(parsers, i.+(1))
      [["group" parsed:0] parsed:1.+(1)]
    } else {
      parsed = parse_word(i)
      [["word" parsed:0] parsed:1]
    }
  }
  specialize_rec = |rec, tree| {
    if tree:0.!=("group") then tree else {
      first_node = tree:1:0
      rest = tree:1:1
      #if first_node:0.==("word") then {
      #  if first_node:1:0.==(":") then {
      #    ["let" rest:0 rest:1:0]
      #  } else ["call" first_node rest]
      #} else
      ["call" first_node rest]
    }
  }
  specialize = |tree| specialize_rec(specialize_rec, tree)
  parse_expr([parse_exprs parse_expr], 0):0.specialize()
}

foo = parse("(foo 1 42)")


== = |a, b| if -(a, b) then false else true
!= = |a, b| if -(a, b) then true else false
<  = |a, b| ==(@compare(a, b), 2)
>  = |a, b| ==(@compare(a, b), 1)
<= = |a, b| !=(@compare(a, b), 1)
>= = |a, b| !=(@compare(a, b), 2)

pow_rec = |rec, base, so_far, i| if i.==(0) then so_far else rec(rec, base, so_far.*(base), i.-(1))
pow = |base, i| pow_rec(pow_rec, base, 1, i)

assert(==(+(1, 1), 2))
assert(==(-(10, 1), 9))
assert(==(*(3, 5), 15))
assert(==(/(8, 2), 4))
assert(10.mod(10).==(0))
assert(12.mod(10).==(2))

min = |a, b| if a.<(b) then a else b
max = |a, b| if a.>(b) then a else b
abs = |a| if a.>=(0) then a else 0.-(a)

is_nil = |obj| ==(@num_words(obj), 0)

# Bool Operations

not = |a| if a then false else true
and = |a, b| if a then b else false
or  = |a, b| if a then true else b
xor = |a, b| if a then not(b) else b

assert(not(false))
assert(not(not(true)))

assert(and(true, true))
assert(not(and(true, false)))
assert(not(and(false, true)))
assert(not(and(false, false)))

assert(or(true, true))
assert(or(true, false))
assert(or(false, true))
assert(not(or(false, false)))

assert(not(xor(true, true)))
assert(xor(true, false))
assert(xor(false, true))
assert(not(xor(false, false)))

# Linked Lists
cons = |head, tail| [head tail]
head = |list| list:0
tail = |list| list:1
push_rec = |rec, list, item| if is_nil(list) then cons(item, nil) else cons(head(list), rec(rec, tail(list), item))
push = |list, item| push_rec(push_rec, list, item)
get_rec = |rec, list, index| if index.==(0) then list:0 else rec(rec, list:1, index.-(1))
get = |list, index| get_rec(get_rec, list, index)
insert_rec = |rec, list, index, item| {
  if index.==(0) then
    cons(item, list)
  else {
    if list.is_nil() then crash("bad index") else {}
    cons(list:0, rec(rec, list:1, index.-(1), item))
  }
}
insert = |list, index, item| insert_rec(insert_rec, list, index, item)
remove_rec = |rec, list, index| if index.==(0) then list:1 else cons(list:0, rec(rec, list:1, index.-(1)))
remove = |list, index| remove_rec(remove_rec, list, index)
skip_rec = |rec, list, n| if n.==(0) then list else rec(rec, list:1, n.-(1))
skip = |list, n| skip_rec(skip_rec, list, n)
take_rec = |rec, list, n| if n.==(0) then nil else cons(list:0, rec(rec, list:1, n.-(1)))
take = |list, n| take_rec(take_rec, list, n)
remove_range_rec = |rec, list, start, end| {
  if start.==(0) then list.skip(end) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1)))
}
remove_range = |list, range| remove_range_rec(remove_range_rec, list, range:0, range:1)
replace_range_rec = |rec, list, start, end, item| {
  if start.==(0) then cons(item, list.skip(end)) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1), item))
}
replace_range = |list, range, item| replace_range_rec(replace_range_rec, list, range:0, range:1, item)
concat_rec = |rec, a, b| if is_nil(a) then b else cons(head(a), rec(rec, tail(a), b))
concat = |a, b| concat_rec(concat_rec, a, b)
pop_rec = |rec, list| if list.tail().is_nil() then nil else cons(list.head(), rec(rec, list.tail()))
pop = |list| pop_rec(pop_rec, list)
len_rec = |rec, list| if list.is_nil() then 0 else rec(rec, list.tail()).+(1)
len = |list| len_rec(len_rec, list)
take_and_reverse_rec = |rec, list, n, so_far| {
  if list.is_nil().or(n.==(0)) then so_far else rec(rec, list:1, n.-(1), cons(list:0, so_far))
}
take_and_reverse = |list, n| take_and_reverse_rec(take_and_reverse_rec, list, n, nil)
slice = |list, range| list.skip(range:0).take(range:1.-(range:0))
