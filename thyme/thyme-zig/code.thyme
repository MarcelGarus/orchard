# Thyme
#
# Welcome to Thyme code! Thyme is a functional language that only operations on
# immutable values. It has the following kinds of values:
#
# - nil: {}
# - numbers: 1          [0] 1
# - strings: "hi"       [0] (utf8-encoded literals words)
# - composites: [a, b]  [0] a b
# - functions: |a| a    [1] ir instructions num_args
#
# Other Expressions:
# - builtins:
#   @load(a, b)            %0 = load a b
#   @add(a, b)             %0 = load a 0
#                          %1 = load b 0
#                          %2 = add %0 %1
#                          %3 = new [0] %2
#   @subtract(a, b)        ...
#   @multiply(a, b)        ...
#   @divide(a, b)          ...
#   @modulo(a, b)          ...
#   @compare(a, b)         ...
#   @collect_garbage(fun)  ...

# Nil
#
# Nil is a value that is used when we don't really need a value. If you have an
# empty body, it implicitly evaluates to nil.

nil = {}

# Crashing

crash = |message| @crash(message)
unreachable = || crash("unreachable")
todo = || crash("todo")
assert = |check| if check then nil else crash("assert failed")

# Basic Bool Definitions

true  = 1
false = 0

assert(true)

# Basic Int Operations

+   = |a, b| @add(a, b)
-   = |a, b| @subtract(a, b)
*   = |a, b| @multiply(a, b)
/   = |a, b| @divide(a, b)
#mod = |a, b| @modulo(a, b)

== = |a, b| if -(a, b) then false else true
!= = |a, b| if -(a, b) then true else false
<  = |a, b| ==(@compare(a, b), 2)
>  = |a, b| ==(@compare(a, b), 1)
<= = |a, b| !=(@compare(a, b), 1)
>= = |a, b| !=(@compare(a, b), 2)

assert(==(+(1, 1), 2))
assert(==(-(10, 1), 9))
assert(==(*(3, 5), 15))
assert(==(/(8, 2), 4))

# Bool Operations

not = |a| if a then false else true
and = |a, b| if a then b else false
or  = |a, b| if a then true else b
xor = |a, b| if a then not(b) else b

assert(not(false))
assert(not(not(true)))

assert(and(true, true))
assert(not(and(true, false)))
assert(not(and(false, true)))
assert(not(and(false, false)))

assert(or(true, true))
assert(or(true, false))
assert(or(false, true))
assert(not(or(false, false)))

assert(not(xor(true, true)))
assert(xor(true, false))
assert(xor(false, true))
assert(not(xor(false, false)))

# Linked Lists

cons = |head, tail| [head tail]
head = |list| list:0
tail = |list| list:1

# Color

color = |r, g, b| [r g b]

# Drawing

draw_rectangle = |position, size, color|
  ["draw rectangle" position:0 position:1 size:0 size:1 color:0 color:1 color:2]

# Example

red = color(1, 175, 218)
blue = color(254, 159, 171)
yellow = color(254, 228, 113)

|width, height| {
  cons(
    draw_rectangle([30 30], [100 100], red),
    cons(
      draw_rectangle([-(width, 200) -(height, 200)], [100 100], blue),
      cons(
        draw_rectangle([100 100], [30 30], yellow),
        nil
      )
    )
  )
}

# More advanced int stuff

#round_up_to_power_of = |number, base| {
#  recursive(number, base, 1, |number, base, candidate| {
#    if >=(candidate, number) then
#      candidate
#    else
#      recurse(number, base, *(candidate, base))
#  })
#}
#
#assert(==(round_up_to_power_of(0, 2), 1), "round up to power of is bad")
#assert(==(round_up_to_power_of(1, 2), 1), "round up to power of is bad")
#assert(==(round_up_to_power_of(2, 2), 2), "round up to power of is bad")
#assert(==(round_up_to_power_of(3, 2), 4), "round up to power of is bad")
#assert(==(round_up_to_power_of(9, 2), 16), "round up to power of is bad")
#
## log_2 returns the floored result
#log_2 = |number| {
#  assert(>(number, 0), [log_arg_must_be_positive])
#  rec2(0, 1, |candidate, two_pow_candidate, rec| {
#    next_candidate = +(candidate, 1)
#    next_two_pow_candidate = *(two_pow_candidate, 2)
#    >(next_two_pow_candidate, number) % {
#      true -> candidate
#      false -> rec(next_candidate, next_two_pow_candidate)
#    }
#  })
#}
##assert(==(log_2(1), 0), [log_2_is_bad])
##assert(==(log_2(2), 1), [log_2_is_bad])
##assert(==(log_2(3), 1), [log_2_is_bad])
##assert(==(log_2(4), 2), [log_2_is_bad])
##assert(==(log_2(5), 2), [log_2_is_bad])
##assert(==(log_2(7), 2), [log_2_is_bad])
##assert(==(log_2(8), 3), [log_2_is_bad])
#
## Collect garbage
#
#collect_garbage = |lambda| @collect_garbage(lambda)
#
## Lists
##
## Lists are stored as a binary tree of minimal height, where nodes are
## filled from the left. The length tells us exactly the layout of this
## tree. For example, a list of 1, 2, 3, 4, 5 is the following tree:
##
## [[[[0, 1], [2, 3]], [[4 0], [0, 0]]]; 5]
#
#list_empty = [nil; 0]
#
#list_push = {
#  create_empty_tree = |depth| {
#    rec1(depth, |depth, rec| {
#      ==(depth, 0) % {
#        true -> nil
#        false -> {
#          child = rec(-(depth, 1))
#          [left: child right: child]
#        }
#      }
#    })
#  }
#  create_tree_with_single_item = |depth, item| {
#    rec2(depth, item, |depth, item, rec| {
#      ==(depth, 0) % {
#        true -> item
#        false -> [
#          left: rec(-(depth, 1), item)
#          right: create_empty_tree(-(depth, 1))
#        ]
#      }
#    })
#  }
#  set_in_tree = |items, length, index, item| {
#    rec4(items, length, index, item, |items, length, index, item, rec| {
#      ==(length, 1) % {
#        true -> item
#        false -> {
#          num_child = /(length, 2)  # TODO: shift
#          <(index, num_child) % {
#            true -> [
#              left: rec(items:left, num_child, index, item) right: items:right
#            ]
#            false -> [
#              left: items:left
#              right: rec(items:right, num_child, -(index, num_child), item)
#            ]
#          }
#        }
#      }
#    })
#  }
#  |list, item| {
#    length = list:length
#    ==(length, 0) % {
#      true -> [length: 1 items: item]
#      false -> [
#        length: +(length, 1)
#        items: ==(length, round_up_to_power_of(length, 2)) % {
#          true -> [
#            left: list:items
#            right: create_tree_with_single_item(log_2(length), item)
#          ]
#          false -> set_in_tree(
#            list:items, round_up_to_power_of(length, 2), length, item
#          )
#        }
#      ]
#    }
#  }
#}
#
#list_get = |list, index| {
#  >=(index, list:length) % {
#    true -> crash([out_of_bounds])
#    false -> rec3(
#      list:items,
#      round_up_to_power_of(list:length, 2),
#      index,
#      |items, cap, index, rec| {
#        cap_child = /(cap, 2)  # TODO: shift
#        <(index, cap_child) % {
#          true -> rec(items:left, cap_child, index)
#          false -> rec(items:right, cap_child, -(index, cap_child))
#        }
#      },
#    )
#  }
#}
#
#core = [
#  crash: crash
#  collect_garbage: collect_garbage
#  unreachable
#  todo
#  assert
#  rec1
#  rec2
#  rec3
#  rec4
#  loop
#  bool: [true false not and or xor]
#  int: [+ - * / mod == != < > <= >= round_up_to_power_of log_2]
#  list: [empty: list_empty push: list_push get: list_get]
#]
#
#collect_garbage = core:collect_garbage
#empty = core:list:empty
#push = core:list:push
#
#foo = collect_garbage(|| push(empty, 2))
#
#push(foo, 3)
#
#push
#
##push(push(push(push(push(empty, 1), 2), 3), 4), 5)
#
