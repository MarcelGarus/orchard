(:
  # (
    Welcome to Thyme. This is a tiny programming language with Lisp-like syntax that is closely modeled
    after the untyped lambda calculus. As values, only has ints, strings, structs, enums, and lambdas.
    For ints and strings, operations are available via builtin functions (available in the @ struct that is
    magically in scope). For structs, enums, and lambdas, there are language-level operations for accessing
    struct members, switching on enums, and calling lambdas.
  )

  # (Nil is used whenever we don't actually want to provide a useful value. Functions that only have
    side-effects (aka they may crash but that's all they do) return nil. See the assert function for an
    example.)
  nil (&)

  # (Functions related to crashing.)
  crash (\ (message) ((. @ crash) message))
  unreachable (\ () (crash "unreachable"))
  ... (\ () (crash "todo"))
  assert (\ (check) (% check true nil false (crash "assert failed")))

  # (Your typical boolean values are just enums.)
  true (| true)
  false (| false)
  not (\ (a) (% a true false false true))
  and (\ (a b) (% a true b false false))
  or (\ (a b) (% a true true false b))
  xor (\ (a b) (% a true (not b) false b))
  _ (assert true)
  _ (assert (not false))
  _ (assert (not (not true)))
  _ (assert (and true true))
  _ (assert (not (and true false)))
  _ (assert (not (and false true)))
  _ (assert (not (and false false)))
  _ (assert (or true true))
  _ (assert (or true false))
  _ (assert (or false true))
  _ (assert (not (or false false)))
  _ (assert (not (xor true true)))
  _ (assert (xor true false))
  _ (assert (xor false true))
  _ (assert (not (xor false false)))

  # (Int stuff)
  + (\ (a b) ((. @ add) a b))
  - (\ (a b) ((. @ subtract) a b))
  * (\ (a b) ((. @ multiply) a b))
  / (\ (a b) ((. @ divide) a b))
  mod (\ (a b) ((. @ modulo) a b))
  compare (\ (a b) ((. @ compare) a b))
  == (\ (a b) (% (compare a b) equal true greater false less false))
  != (\ (a b) (% (compare a b) equal false greater true less true))
  < (\ (a b) (% (compare a b) equal false greater false less true))
  > (\ (a b) (% (compare a b) equal false greater true less false))
  <= (\ (a b) (% (compare a b) equal true greater false less true))
  >= (\ (a b) (% (compare a b) equal true greater true less false))
  _ (assert (== (+ 1 1) 2))
  _ (assert (== (- 10 1) 9))
  _ (assert (== (* 3 5) 15))
  _ (assert (== (/ 8 2) 4))
  _ (assert (== (mod 10 10) 0))
  _ (assert (== (mod 12 10) 2))
  _ (assert (>= 5 4))
  min (\ (a b) (% (< a b) true a false b))
  max (\ (a b) (% (> a b) true a false b))
  abs (\ (a) (% (>= a 0) true a false (- 0 a)))

  # (A function for making recursive stuff easier.)
  rec (\ (state fun) (: rec (\ (rec state) (fun (\ (state) (rec rec state)) state)) (rec rec state)))

  # (Linked Lists)
  empty_list (| empty)
  cons (\ (head tail) (| more (& head head tail tail)))
  push (\ (list item)
    (rec list (\ (rec list) (% list empty (cons item empty_list) (more m) (cons (. m head) (rec (. m tail)))))))
  list_map (\ (list mapper)
    (rec list (\ (rec list) (% list empty empty_list (more m) (cons (mapper (. m head)) (rec (. m tail)))))))
  array_from_linked_list (\ (list) ((. @ array_from_linked_list) list))

  # (String stuff.)
  get_char (. @ string_get)
  substr (\ (str start end)
    (rec start (\ (rec i) (% (== i end) true empty_list false (cons (get_char str i) (rec (+ i 1)))))))
  ascii_0 (get_char "0" 0)
  ascii_9 (get_char "9" 0)
  ascii_space (get_char " " 0)
  ascii_newline (get_char "\n" 0)
  ascii_opening_paren (get_char "(" 0)
  ascii_closing_paren (get_char ")" 0)
  ascii_quote (get_char "\"" 0)
  ascii_backslash (get_char "\\" 0)

  # (Parsing)
  parse (\ (text) (:
    is_digit (\ (char) (and (>= char ascii_0) (<= char ascii_9)))
    _ (assert (is_digit 50))
    is_whitespace (\ (char) (or (== char ascii_space) (== char ascii_newline)))
    consume_whitespace (\ (i) (rec i (\ (rec i) (% (is_whitespace (get_char text i)) true (rec (+ i 1)) false i))))
    # (The parsers take an index into the text and return (& index Int result ...).)
    parse_number (\ (i) (:
      rec (\ (rec so_far i) (:
        char (get_char text i)
        (% (is_digit char) true (rec rec (+ (* so_far 10) (- char ascii_0)) (+ i 1)) false (& index i result so_far))))
      (rec rec 0 i)))
    parse_string (\ (i) (:
      rec (\ (rec i) (:
        char (get_char text i)
        (% (== char ascii_backslash)
          true (crash "escape")
          false (% (== char ascii_quote)
            true (& index (+ i 1) result empty_list)
            false (: result (rec rec (+ i 1)) (& index (. result index) result (cons char (. result result))))))))
      (rec rec (+ i 1))
    ))
    parse_word (\ (start) (:
      (rec start (\ (rec i) (:
        char (get_char text i)
        (% (or (is_whitespace char) (or (== char ascii_opening_paren) (== char ascii_closing_paren)))
          true (& index i result (substr text start i))
          false (rec (+ i 1))))))))
    parse_expr (\ (parse_exprs i) (:
      i (consume_whitespace i)
      char (get_char text i)
      (% (== char ascii_opening_paren)
        true (:
          result (parse_exprs parse_exprs (+ i 1))
          i (consume_whitespace (. result index))
          (% (== (get_char text i) ascii_closing_paren)
            true (& index (+ i 1) result (| group (. result result)))
            false (crash "expected closing paren to end group")))
        false (% (is_digit char)
          true (: result (parse_number i) (& index (. result index) result (| number (. result result))))
          false (% (== char ascii_quote)
            true (: result (parse_string i) (& index (. result index) result (| string (. result result))))
            false (: result (parse_word i) (& index (. result index) result (| word (. result result)))))))))
    parse_exprs (\ (rec i) (:
      i (consume_whitespace i)
      char (get_char text i)
      (% (== char ascii_closing_paren)
        true (& index i result empty_list)
        false (:
          first (parse_expr rec i)
          rest (rec rec (. first index))
          (& index (. rest index) result (cons (. first result) (. rest result)))))))
    # (The above parsers are enough to parse a string into a tree of words (such as foo, bar), numbers
      (such as 1, 2, or 3), strings (such as "hi" or "blub"), and groups (such as (hi there)). Thyme has some
      specific semantics attached to some constellations of these. For example, if a group starts with the
      word "&", then it's actually a struct. This semantic transformation is what we do next.)
    add_semantics (\ (tree)
      (rec tree (\ (rec tree)
        (% tree
          number tree
          string tree
          (word w) (| name w)
          (group g) (% g
            empty (crash "empty group")
            (more node)
              (% (. node head)
                number (| call (& callee (. node head) args (array_from_linked_list (list_map (. node tail) (\ (t) (rec t))))))
                string (| call (& callee (. node head) args (array_from_linked_list (list_map (. node tail) (\ (t) (rec t))))))
                (word w) (| call (& callee (. node head) args (array_from_linked_list (list_map (. node tail) (\ (t) (rec t))))))
                group (| call (& callee (rec (. node head)) args (array_from_linked_list (list_map (. node tail) (\ (t) (rec t))))))))))))
    (add_semantics (. (parse_expr parse_exprs 0) result))))

  # (push (push (push (push (push empty_list 1) 2) 3) 4) 5)
  # (substr "hello world" 2 7)

  (parse "(+ 2 3)")
)

pow_rec = |rec, base, so_far, i| if i.==(0) then so_far else rec(rec, base, so_far.*(base), i.-(1))
pow = |base, i| pow_rec(pow_rec, base, 1, i)

is_nil = |obj| ==(@num_words(obj), 0)

# Linked Lists
head = |list| list:0
tail = |list| list:1
push_rec = |rec, list, item| if is_nil(list) then cons(item, nil) else cons(head(list), rec(rec, tail(list), item))
push = |list, item| push_rec(push_rec, list, item)
get_rec = |rec, list, index| if index.==(0) then list:0 else rec(rec, list:1, index.-(1))
get = |list, index| get_rec(get_rec, list, index)
insert_rec = |rec, list, index, item| {
  if index.==(0) then
    cons(item, list)
  else {
    if list.is_nil() then crash("bad index") else {}
    cons(list:0, rec(rec, list:1, index.-(1), item))
  }
}
insert = |list, index, item| insert_rec(insert_rec, list, index, item)
remove_rec = |rec, list, index| if index.==(0) then list:1 else cons(list:0, rec(rec, list:1, index.-(1)))
remove = |list, index| remove_rec(remove_rec, list, index)
skip_rec = |rec, list, n| if n.==(0) then list else rec(rec, list:1, n.-(1))
skip = |list, n| skip_rec(skip_rec, list, n)
take_rec = |rec, list, n| if n.==(0) then nil else cons(list:0, rec(rec, list:1, n.-(1)))
take = |list, n| take_rec(take_rec, list, n)
remove_range_rec = |rec, list, start, end| {
  if start.==(0) then list.skip(end) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1)))
}
remove_range = |list, range| remove_range_rec(remove_range_rec, list, range:0, range:1)
replace_range_rec = |rec, list, start, end, item| {
  if start.==(0) then cons(item, list.skip(end)) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1), item))
}
replace_range = |list, range, item| replace_range_rec(replace_range_rec, list, range:0, range:1, item)
concat_rec = |rec, a, b| if is_nil(a) then b else cons(head(a), rec(rec, tail(a), b))
concat = |a, b| concat_rec(concat_rec, a, b)
pop_rec = |rec, list| if list.tail().is_nil() then nil else cons(list.head(), rec(rec, list.tail()))
pop = |list| pop_rec(pop_rec, list)
len_rec = |rec, list| if list.is_nil() then 0 else rec(rec, list.tail()).+(1)
len = |list| len_rec(len_rec, list)
take_and_reverse_rec = |rec, list, n, so_far| {
  if list.is_nil().or(n.==(0)) then so_far else rec(rec, list:1, n.-(1), cons(list:0, so_far))
}
take_and_reverse = |list, n| take_and_reverse_rec(take_and_reverse_rec, list, n, nil)
slice = |list, range| list.skip(range:0).take(range:1.-(range:0))
