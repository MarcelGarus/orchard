(:
  # (
    Welcome to Thyme. This is a tiny programming language with Lisp-like syntax that is closely modeled
    after the untyped lambda calculus. As values, only has ints, strings, structs, enums, and lambdas.
    For ints and strings, operations are available via builtin functions (available in the @ struct that is
    magically in scope). For structs, enums, and lambdas, there are language-level operations for accessing
    struct members, switching on enums, and calling lambdas.
  )

  # (Nil is used whenever we don't actually want to provide a useful value. Functions that only have
    side-effects (aka they may crash but that's all they do) return nil. See the assert function for an
    example.)
  nil (&)

  # (Functions related to crashing.)
  crash (\ (message) ((. @ crash) message))
  unreachable (\ () (crash "unreachable"))
  ... (\ () (crash "todo"))
  assert (\ (check) (% check true nil false (crash "assert failed")))

  # (Your typical boolean values are just enums.)
  true (| true)
  false (| false)
  not (\ (a) (% a true false false true))
  and (\ (a b) (% a true b false false))
  or (\ (a b) (% a true true false b))
  xor (\ (a b) (% a true (not b) false b))
  _ (assert true)
  _ (assert (not false))
  _ (assert (not (not true)))
  _ (assert (and true true))
  _ (assert (not (and true false)))
  _ (assert (not (and false true)))
  _ (assert (not (and false false)))
  _ (assert (or true true))
  _ (assert (or true false))
  _ (assert (or false true))
  _ (assert (not (or false false)))
  _ (assert (not (xor true true)))
  _ (assert (xor true false))
  _ (assert (xor false true))
  _ (assert (not (xor false false)))

  # (Int stuff)
  + (\ (a b) ((. @ add) a b))
  - (\ (a b) ((. @ subtract) a b))
  * (\ (a b) ((. @ multiply) a b))
  / (\ (a b) ((. @ divide) a b))
  mod (\ (a b) ((. @ modulo) a b))
  compare (\ (a b) ((. @ compare) a b))
  == (\ (a b) (% (compare a b) equal true greater false less false))
  != (\ (a b) (% (compare a b) equal false greater true less true))
  < (\ (a b) (% (compare a b) equal false greater false less true))
  > (\ (a b) (% (compare a b) equal false greater true less false))
  <= (\ (a b) (% (compare a b) equal true greater false less true))
  >= (\ (a b) (% (compare a b) equal true greater true less false))
  _ (assert (== (+ 1 1) 2))
  _ (assert (== (- 10 1) 9))
  _ (assert (== (* 3 5) 15))
  _ (assert (== (/ 8 2) 4))
  _ (assert (== (mod 10 10) 0))
  _ (assert (== (mod 12 10) 2))
  _ (assert (>= 5 4))
  min (\ (a b) (% (< a b) true a false b))
  max (\ (a b) (% (> a b) true a false b))
  abs (\ (a) (% (>= a 0) true a false (- 0 a)))
  is_even (\ (a) (== (mod a 2) 0))
  is_odd (\ (a) (== (mod a 2) 1))

  # (A function for making recursive stuff easier.)
  rec (\ (state fun) (: rec (\ (rec state) (fun (\ (state) (rec rec state)) state)) (rec rec state)))

  # (Linked Lists)
  empty_list (| empty)
  cons (\ (head tail) (| more (& head head tail tail)))
  push (\ (list item)
    (rec list (\ (rec list) (% list empty (cons item empty_list) (more m) (cons (. m head) (rec (. m tail)))))))
  list_map (\ (list mapper)
    (rec list (\ (rec list) (% list empty empty_list (more m) (cons (mapper (. m head)) (rec (. m tail)))))))
  array_from_list (\ (list) ((. @ array_from_list) list))
  list_len (\ (list) (rec list (\ (rec list) (% list empty 0 (more m) (+ (rec (. m tail)) 1)))))
  list_get (\ (list index) (:
    rec (\ (rec list index) (% list
        empty (crash "index out of bounds")
        (more m) (% (== index 0) true (. m head) false (rec rec (. m tail) (- index 1)))))
    (rec rec list index)))
  list_skip (\ (list amount) (:
    rec (\ (rec list amount)
      (% (== amount 0)
        true list
        false (rec rec (% list empty (crash "bad skip") (more m) (. m tail)) (- amount 1))))
    (rec rec list amount)))

  # (String stuff.)
  get_char (. @ string_get)
  string_from_chars (\ (chars) ((. @ string_from_chars) chars))
  substr (\ (str start end)
    (string_from_chars
      (array_from_list
        (rec start (\ (rec i) (% (== i end) true empty_list false (cons (get_char str i) (rec (+ i 1)))))))))
  str== (\ (a b) ((. @ string_equals) a b))
  ascii_0 (get_char "0" 0)
  ascii_9 (get_char "9" 0)
  ascii_space (get_char " " 0)
  ascii_newline (get_char "\n" 0)
  ascii_opening_paren (get_char "(" 0)
  ascii_closing_paren (get_char ")" 0)
  ascii_quote (get_char "\"" 0)
  ascii_backslash (get_char "\\" 0)

  # (Parsing)
  parse (\ (text) (:
    is_digit (\ (char) (and (>= char ascii_0) (<= char ascii_9)))
    _ (assert (is_digit 50))
    is_whitespace (\ (char) (or (== char ascii_space) (== char ascii_newline)))
    consume_whitespace (\ (i) (rec i (\ (rec i) (% (is_whitespace (get_char text i)) true (rec (+ i 1)) false i))))
    # (The parsers take an index into the text and return (& index Int result ...).)
    parse_number (\ (i) (:
      rec (\ (rec so_far i) (:
        char (get_char text i)
        (% (is_digit char) true (rec rec (+ (* so_far 10) (- char ascii_0)) (+ i 1)) false (& index i result so_far))))
      (rec rec 0 i)))
    parse_string (\ (i) (:
      rec (\ (rec i) (:
        char (get_char text i)
        (% (== char ascii_backslash)
          true (crash "escape")
          false (% (== char ascii_quote)
            true (& index (+ i 1) result empty_list)
            false (: result (rec rec (+ i 1)) (& index (. result index) result (cons char (. result result))))))))
      (rec rec (+ i 1))
    ))
    parse_word (\ (start)
      (rec start (\ (rec i) (:
        char (get_char text i)
        (% (or (is_whitespace char) (or (== char ascii_opening_paren) (== char ascii_closing_paren)))
          true (& index i result (substr text start i))
          false (rec (+ i 1)))))))
    parse_expr (\ (parse_exprs i) (:
      i (consume_whitespace i)
      char (get_char text i)
      (% (== char ascii_opening_paren)
        true (:
          result (parse_exprs parse_exprs (+ i 1))
          i (consume_whitespace (. result index))
          (% (== (get_char text i) ascii_closing_paren)
            true (& index (+ i 1) result (| group (. result result)))
            false (crash "expected closing paren to end group")))
        false (% (is_digit char)
          true (: result (parse_number i) (& index (. result index) result (| number (. result result))))
          false (% (== char ascii_quote)
            true (: result (parse_string i) (& index (. result index) result (| string (. result result))))
            false (: result (parse_word i) (& index (. result index) result (| word (. result result)))))))))
    parse_exprs (\ (rec i) (:
      i (consume_whitespace i)
      char (get_char text i)
      (% (== char ascii_closing_paren)
        true (& index i result empty_list)
        false (:
          first (parse_expr rec i)
          rest (rec rec (. first index))
          (& index (. rest index) result (cons (. first result) (. rest result)))))))
    # (The above parsers are enough to parse a string into a tree of words (such as foo, bar), numbers
      (such as 1, 2, or 3), strings (such as "hi" or "blub"), and groups (such as (hi there)). Thyme has some
      specific semantics attached to some constellations of these. For example, if a group starts with the
      word "&", then it's actually a struct. This semantic transformation is what we do next.)
    add_semantics (\ (tree)
      (rec tree (\ (add_semantics tree)
        (% tree
          number tree
          string tree
          (word w) (| name w)
          (group g) (% g
            empty (crash "empty group")
            (more m) (:
              head (. m head)
              tail (. m tail)
              (% head
                number (| call (& callee head args (array_from_list (list_map tail (\ (t) (add_semantics t))))))
                string (| call (& callee head args (array_from_list (list_map tail (\ (t) (add_semantics t))))))
                (word w)
                  (% (str== w "&")
                    true (% (is_even (list_len tail))
                      false (crash "bad struct")
                      true (:
                        extract_fields_rec (\ (extract_fields_rec list)
                          (% list
                            empty empty_list
                            (more m) (% (. m head)
                              number (crash "bad struct")
                              string (crash "bad struct")
                              group (crash "bad struct")
                              (word field_name) (% (. m tail)
                                empty (unreachable)
                                (more m)
                                  (cons
                                    (& name field_name value (add_semantics (. m head)))
                                    (extract_fields_rec extract_fields_rec (. m tail)))))))
                        (| struct (array_from_list (extract_fields_rec extract_fields_rec tail)))))
                    false (% (str== w ".")
                      true (% (== (list_len tail) 2)
                        true (% (list_get tail 1)
                          number (crash "members need to have the form (. of name)")
                          string (crash "members need to have the form (. of name)")
                          (word w) (| member (& of (add_semantics (list_get tail 0)) name w))
                          group (crash "members need to have the form (. of name)"))
                        false (crash "members need to have the form (. of name)"))
                      false (% (str== w "|")
                        true (% tail
                          empty (crash "bad enum")
                          (more m) (% (. m head)
                            number (crash "bad enum")
                            string (crash "bad enum")
                            (word variant) (:
                              payload (% (. m tail)
                                empty (| struct (array_from_list empty_list))
                                (more m) (% (. m tail)
                                  more (crash "bad enum")
                                  empty (add_semantics (. m head))))
                              (| enum (& variant variant payload payload)))
                            group (crash "bad enum")))
                        false (% (str== w "%")
                          true (% tail
                            empty (crash "bad switch")
                            (more m) (:
                              condition (add_semantics (. m head))
                              cases
                                (% (is_even (list_len (. m tail)))
                                  false (crash "bad switch")
                                  true (:
                                    extract_cases_rec (\ (extract_cases_rec list)
                                      (% list
                                        empty empty_list
                                        (more m) (:
                                          match (% (. m head)
                                            number (crash "bad switch")
                                            string (crash "bad switch")
                                            (group g) (% (== (list_len g) 2)
                                              false (crash "bad switch")
                                              true (&
                                                variant (% (list_get g 0)
                                                  number (crash "bad switch")
                                                  string (crash "bad switch")
                                                  group (crash "bad switch")
                                                  (word w) w)
                                                binding (| some
                                                  (% (list_get g 1)
                                                    number (crash "bad switch")
                                                    string (crash "bad switch")
                                                    group (crash "bad switch")
                                                    (word w) w))))
                                            (word variant) (& variant variant binding (| none)))
                                          (% (. m tail)
                                            empty (unreachable)
                                            (more m)
                                              (cons
                                                (&
                                                  variant (. match variant)
                                                  binding (. match binding)
                                                  body (add_semantics (. m head)))
                                                (extract_cases_rec extract_cases_rec (. m tail)))))))
                                    (array_from_list (extract_cases_rec extract_cases_rec (. m tail)))))
                                (| switch (& condition condition cases cases))))
                          false (% (str== w "\\")
                            true (% (== (list_len tail) 2)
                              true (:
                                args (% (list_get tail 0)
                                  number (crash "bad lambda")
                                  string (crash "bad lambda")
                                  word (crash "bad lambda")
                                  (group g)
                                    (array_from_list
                                      (list_map g (\ (item)
                                        (% item
                                          (word w) w
                                          number (crash "bad lambda")
                                          string (crash "bad lambda")
                                          group (crash "bad lambda"))))))
                                body (add_semantics (list_get tail 1))
                                (| lambda (& args args body body)))
                              false (crash "bad lambda"))
                            false (% (str== w ":")
                              true (:
                                _ (% (is_odd (list_len tail)) true nil false (crash "bad let"))
                                extract_bindings_rec (\ (extract_bindings_rec list)
                                  (% (== (list_len list) 1)
                                    true (add_semantics (list_get list 0))
                                    false (| let (&
                                      name (% (list_get list 0)
                                        number (crash "bad let")
                                        string (crash "bad let")
                                        group (crash "bad let")
                                        (word name) name)
                                      def (add_semantics (list_get list 1))
                                      expr (extract_bindings_rec extract_bindings_rec (list_skip list 2))))
                                  ))
                                (extract_bindings_rec extract_bindings_rec tail)
                              )
                              false
                                (| call (& callee head args (array_from_list (list_map tail (\ (t) (add_semantics t))))))))))))
                group
                  (| call (&
                    callee (add_semantics head)
                    args (array_from_list (list_map tail (\ (t) (add_semantics t)))))))))))))
    (add_semantics (. (parse_expr parse_exprs 0) result))))

  # (push (push (push (push (push empty_list 1) 2) 3) 4) 5)
  # (substr "hello world" 2 7)

  # (| more (& head 102 tail (| more (& head 111 tail (| more (& head 111 tail (| empty (&))))))))
  # (string_from_chars (array_from_list chars))
  (parse "(: f 2 g (+ f f) (& x f y g))")
)

pow_rec = |rec, base, so_far, i| if i.==(0) then so_far else rec(rec, base, so_far.*(base), i.-(1))
pow = |base, i| pow_rec(pow_rec, base, 1, i)

is_nil = |obj| ==(@num_words(obj), 0)

# Linked Lists
head = |list| list:0
tail = |list| list:1
push_rec = |rec, list, item| if is_nil(list) then cons(item, nil) else cons(head(list), rec(rec, tail(list), item))
push = |list, item| push_rec(push_rec, list, item)
get_rec = |rec, list, index| if index.==(0) then list:0 else rec(rec, list:1, index.-(1))
get = |list, index| get_rec(get_rec, list, index)
insert_rec = |rec, list, index, item| {
  if index.==(0) then
    cons(item, list)
  else {
    if list.is_nil() then crash("bad index") else {}
    cons(list:0, rec(rec, list:1, index.-(1), item))
  }
}
insert = |list, index, item| insert_rec(insert_rec, list, index, item)
remove_rec = |rec, list, index| if index.==(0) then list:1 else cons(list:0, rec(rec, list:1, index.-(1)))
remove = |list, index| remove_rec(remove_rec, list, index)
skip_rec = |rec, list, n| if n.==(0) then list else rec(rec, list:1, n.-(1))
skip = |list, n| skip_rec(skip_rec, list, n)
take_rec = |rec, list, n| if n.==(0) then nil else cons(list:0, rec(rec, list:1, n.-(1)))
take = |list, n| take_rec(take_rec, list, n)
remove_range_rec = |rec, list, start, end| {
  if start.==(0) then list.skip(end) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1)))
}
remove_range = |list, range| remove_range_rec(remove_range_rec, list, range:0, range:1)
replace_range_rec = |rec, list, start, end, item| {
  if start.==(0) then cons(item, list.skip(end)) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1), item))
}
replace_range = |list, range, item| replace_range_rec(replace_range_rec, list, range:0, range:1, item)
concat_rec = |rec, a, b| if is_nil(a) then b else cons(head(a), rec(rec, tail(a), b))
concat = |a, b| concat_rec(concat_rec, a, b)
pop_rec = |rec, list| if list.tail().is_nil() then nil else cons(list.head(), rec(rec, list.tail()))
pop = |list| pop_rec(pop_rec, list)
len_rec = |rec, list| if list.is_nil() then 0 else rec(rec, list.tail()).+(1)
len = |list| len_rec(len_rec, list)
take_and_reverse_rec = |rec, list, n, so_far| {
  if list.is_nil().or(n.==(0)) then so_far else rec(rec, list:1, n.-(1), cons(list:0, so_far))
}
take_and_reverse = |list, n| take_and_reverse_rec(take_and_reverse_rec, list, n, nil)
slice = |list, range| list.skip(range:0).take(range:1.-(range:0))
