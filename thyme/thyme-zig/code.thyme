unreachable = || crash([unreachable])
todo = || crash([todo])

equals = |a, b| if_not_zero(subtract(a, b), [false], [true])
not_equals = |a, b| if_not_zero(subtract(a, b), [true], [false])
is_less = |a, b| equals(int_compare_to_num(a, b), 2)
is_greater = |a, b| equals(int_compare_to_num(a, b), 1)
is_less_equal = |a, b|
  if_not_zero(subtract(int_compare_to_num(a, b), 1), [true], [false])
is_greater_equal = |a, b|
  if_not_zero(subtract(int_compare_to_num(a, b), 2), [true], [false])

rec1 = |a, fun| {
  rec = |rec, a| fun(|a| rec(rec, a), a)
  rec(rec, a)
}
rec2 = |a, b, fun| {
  rec = |rec, a, b| fun(|a, b| rec(rec, a, b), a, b)
  rec(rec, a, b)
}
rec3 = |a, b, c, fun| {
  rec = |rec, a, b, c| fun(|a, b, c| rec(rec, a, b, c), a, b, c)
  rec(rec, a, b, c)
}

loop = |state, body| {
  rec1(state, |rec, state| {
    body(state) % { break: result -> result continue: next -> rec(next) }
  })
}

assert = |check, message| check % { true -> nil false -> crash(message) }

round_up_to_power_of = |number, base| {
  loop(1, |candidate| {
    is_greater_equal(candidate, number) % {
      true -> [break: candidate]
      false -> [continue: multiply(candidate, base)]
    }
  })
}
assert(equals(round_up_to_power_of(0, 2), 1), [round_up_to_power_of_is_bad])
assert(equals(round_up_to_power_of(1, 2), 1), [round_up_to_power_of_is_bad])
assert(equals(round_up_to_power_of(2, 2), 2), [round_up_to_power_of_is_bad])
assert(equals(round_up_to_power_of(3, 2), 4), [round_up_to_power_of_is_bad])
assert(equals(round_up_to_power_of(9, 2), 16), [round_up_to_power_of_is_bad])

# log_2 returns the floored result
log_2 = |number| {
  assert(is_greater(number, 0), [log_arg_must_be_positive])
  rec2(0, 1, |rec, candidate, two_pow_candidate| {
    next_candidate = add(candidate, 1)
    next_two_pow_candidate = multiply(two_pow_candidate, 2)
    is_greater(next_two_pow_candidate, number) % {
      true -> candidate
      false -> rec(next_candidate, next_two_pow_candidate)
    }
  })
}
assert(equals(log_2(1), 0), [log_2_is_bad])
assert(equals(log_2(2), 1), [log_2_is_bad])
assert(equals(log_2(3), 1), [log_2_is_bad])
assert(equals(log_2(4), 2), [log_2_is_bad])
assert(equals(log_2(5), 2), [log_2_is_bad])
assert(equals(log_2(7), 2), [log_2_is_bad])
assert(equals(log_2(8), 3), [log_2_is_bad])

# List stuff
#
# Lists are stored as a binary tree of minimal height, where nodes are
# filled from the left. The length tells us exactly the layout of this
# tree. For example, a list of 5 items results in the following tree:
# [
#   length: 5
#   items: [
#     left: [left: [left: 0 right: 1] right: [left: 2 right: 3]]
#     right: [left: [left: 4 right: nil] right: nil]
#   ]
# ]

list_empty = [length: 0 items: nil]

list_push = {
  create_list_with_depth = |depth, item| {
    rec2(depth, item, |rec, depth, item| {
      equals(depth, 0) % {
        true -> item
        false -> [left: rec(subtract(depth, 1), item) right: nil]
      }
    })
  }
  build_new_items = |items, length, item| {
    rec3(items, length, item, |rec, items, length, item| {
      equals(length, round_up_to_power_of(length, 2)) % {
        true -> {
          [left: items right: create_list_with_depth(log_2(length), item)]
        }
        false -> {
          crash(123456)
          #num_left = divide(length, 2)  # TODO: shift
          #num_right = subtract(length, num_left)
          #[left: (items:left) right: rec(items:right, num_right, item)]
        }
      }
    })
  }
  |list, item| {
    equals(list:length, 0) % {
      true -> [length: 1 items: item]
      false -> [
        length: add(list:length, 1)
        items: build_new_items(list:items, list:length, item)
      ]
    }
  }
}

list_get = |list, index| {
  is_greater_equal(index, list:length) % {
    true -> crash([out_of_bounds])
    false -> rec3(
      list:items,
      round_up_to_power_of(list:length, 2),
      index,
      |rec, items, cap, index| {
        cap_child = divide(cap, 2)  # TODO: shift
        is_less(index, cap_child) % {
          true -> rec(items:left, cap_child, index)
          false -> rec(items:right, cap_child, subtract(index, cap_child))
        }
      }
    )
  }
}

core = [
  unreachable: unreachable
  equals: equals
  not_equals: not_equals
  is_less: is_less
  is_greater: is_greater
  is_less_equal: is_less_equal
  is_greater_equal is_greater_equal
  loop: loop
  round_up_to_power_of: round_up_to_power_of
  list: [
    empty: list_empty
    get: list_get
    push: list_push
  ]
]


empty = core:list:empty
push = core:list:push

push(push(push(empty, 1), 2), 3)

core
