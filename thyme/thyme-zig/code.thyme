(:
  # (
    Time to Thyme! This is a tiny programming language with Lisp-like syntax that is closely modeled after
    the untyped lambda calculus. It has the following types of values: ints, strings, structs, enums, arrays,
    and functions. With each of these types, you can do different things:

    Ints: You can create ints by writing a number in the code like this: 3. Ints are 64-bit signed integers.
      You can do stuff with ints using these builtin functions:
      - add
      - subtract
      - multiply
      - divide
      - modulo
      - and
      - or
      - xor
      - shift_left
      - shift_right
      - compare (returns an enum; either (| less), (| greater), or (| equal)).

    Strings: You can create strings using double quotes in your code like this: "hello". Strings can go over
      multiple lines. Inside strings, you can use a backslash \ followed by a backslash, quote, or "n" to mean
      a backslash, quote, or newline. You can do stuff with strings using these builtin functions:
      - string_len
      - get_char
      - string_from_chars

    Structs: You can create structs by writing a parenthesized group where the first word is "&", like this:
      (& x 1 y 4). You can access the fields of structs like this: (. some_struct x). You can also do stuff with
      structs using these builtin functions:
      - make_struct: Turns an array of (& name ... value ...) structs into an actual struct.
      - field: Takes a struct and a string, returns the field.

    Enums: You can create enums by writing a parenthesized group where the first word is "|", like this:
      (| foo). You can switch on an enum like this: (% some_enum foo 2 bar 5 (baz binding) binding). You can
      also do stuff with enums using these builtin functions:
      - make_enum: Turns a string and a payload value into an enum: (make_enum "foo" 3) is (| foo 3).
      - variant: Takes an enum, returns the variant as a string: (variant (| foo)) is "foo".
      - payload: Takes an enum, returns the payload: (payload (| some 4)) is 4.

    Arrays: They exist.

    Functions: They exist.
  )

  # (Nil is used whenever we don't actually want to provide a useful value. Functions that only have
    side-effects (aka they may crash but that's all they do) return nil. See the assert function for an
    example.)
  nil (&)

  # (Functions related to crashing.)
  crash (\ (message) ((. @ crash) message))
  unreachable (\ () (crash "unreachable"))
  ... (\ () (crash "todo"))
  assert (\ (check) (% check true nil false (crash "assert failed")))

  # (Your typical boolean values are just enums.)
  true (| true)
  false (| false)
  not (\ (a) (% a true false false true))
  and (\ (a b) (% a true b false false))
  or (\ (a b) (% a true true false b))
  xor (\ (a b) (% a true (not b) false b))
  _ (assert true)
  _ (assert (not false))
  _ (assert (not (not true)))
  _ (assert (and true true))
  _ (assert (not (and true false)))
  _ (assert (not (and false true)))
  _ (assert (not (and false false)))
  _ (assert (or true true))
  _ (assert (or true false))
  _ (assert (or false true))
  _ (assert (not (or false false)))
  _ (assert (not (xor true true)))
  _ (assert (xor true false))
  _ (assert (xor false true))
  _ (assert (not (xor false false)))

  # (Int stuff)
  + (\ (a b) ((. @ add) a b))
  - (\ (a b) ((. @ subtract) a b))
  * (\ (a b) ((. @ multiply) a b))
  / (\ (a b) ((. @ divide) a b))
  mod (\ (a b) ((. @ modulo) a b))
  compare (\ (a b) ((. @ compare) a b))
  == (\ (a b) (% (compare a b) equal true greater false less false))
  != (\ (a b) (% (compare a b) equal false greater true less true))
  < (\ (a b) (% (compare a b) equal false greater false less true))
  > (\ (a b) (% (compare a b) equal false greater true less false))
  <= (\ (a b) (% (compare a b) equal true greater false less true))
  >= (\ (a b) (% (compare a b) equal true greater true less false))
  _ (assert (== (+ 1 1) 2))
  _ (assert (== (- 10 1) 9))
  _ (assert (== (* 3 5) 15))
  _ (assert (== (/ 8 2) 4))
  _ (assert (== (mod 10 10) 0))
  _ (assert (== (mod 12 10) 2))
  _ (assert (>= 5 4))
  min (\ (a b) (% (< a b) true a false b))
  max (\ (a b) (% (> a b) true a false b))
  abs (\ (a) (% (>= a 0) true a false (- 0 a)))
  is_even (\ (a) (== (mod a 2) 0))
  is_odd (\ (a) (== (mod a 2) 1))

  # (A function for making recursive stuff easier.)
  rec (\ (state fun) (: rec (\ (rec state) (fun (\ (state) (rec rec state)) state)) (rec rec state)))
  rec_2 (\ (a b fun) (: rec (\ (rec a b) (fun (\ (a b) (rec rec a b)) a b)) (rec rec a b)))

  # (Linked Lists)
  empty_list (| empty)
  cons (\ (head tail) (| more (& head head tail tail)))
  push (\ (list item)
    (rec list (\ (rec list) (% list empty (cons item empty_list) (more m) (cons (. m head) (rec (. m tail)))))))
  list_map (\ (list mapper)
    (rec list (\ (rec list) (% list empty empty_list (more m) (cons (mapper (. m head)) (rec (. m tail)))))))
  list_len (\ (list) (rec list (\ (rec list) (% list empty 0 (more m) (+ (rec (. m tail)) 1)))))
  list_get (\ (list index)
    (rec_2 list index (\ (get list index)
      (% list
        empty (crash "The index is out of bounds.")
        (more m) (% (== index 0) true (. m head) false (get (. m tail) (- index 1)))))))
  list_skip (\ (list amount)
    (rec_2 list amount (\ (rec list amount)
      (% (== amount 0)
        true list
        false (rec (% list empty (crash "bad skip") (more m) (. m tail)) (- amount 1))))))
  list_find (\ (list check)
    (rec list (\ (rec list)
      (% list
        empty (| none)
        (more m) (: current (. m head) (% (check current) true (| some current) false (rec (. m tail))))))))

  # (Arrays)
  array_len (\ (array) ((. @ array_len) array))
  array_get (\ (array index) ((. @ array_get) array index))
  array_from_list (\ (list) ((. @ array_from_list) list))
  list_from_array (\ (array)
    (rec 0 (\ (rec i) (% (== i (array_len array)) true empty_list false (cons (array_get array i) (rec (+ i 1)))))))
  array_map (\ (array mapper)
    (array_from_list
      (rec 0 (\ (rec i)
        (% (== i (array_len array)) true empty_list false (cons (mapper (array_get array i)) (rec (+ i 1))))))))
  array_find (\ (array check)
    (rec 0 (\ (find i)
      (% (== i (array_len array))
        true (| none)
        false (: item (array_get array i) (% (check item) true (| some item) false (find (+ i 1))))))))

  # (String stuff.)
  get_char (. @ string_get)
  string_from_chars (\ (chars) ((. @ string_from_chars) chars))
  substr (\ (str start end)
    (string_from_chars
      (array_from_list
        (rec start (\ (rec i) (% (== i end) true empty_list false (cons (get_char str i) (rec (+ i 1)))))))))
  str== (\ (a b) ((. @ string_equals) a b))
  ascii_0 (get_char "0" 0)
  ascii_9 (get_char "9" 0)
  ascii_space (get_char " " 0)
  ascii_newline (get_char "\n" 0)
  ascii_opening_paren (get_char "(" 0)
  ascii_closing_paren (get_char ")" 0)
  ascii_quote (get_char "\"" 0)
  ascii_backslash (get_char "\\" 0)

  # (Parsing)
  parse (\ (text) (:
    is_digit (\ (char) (and (>= char ascii_0) (<= char ascii_9)))
    _ (assert (is_digit 50))
    is_whitespace (\ (char) (or (== char ascii_space) (== char ascii_newline)))
    consume_whitespace (\ (i)
      (rec i (\ (continue i) (% (is_whitespace (get_char text i)) true (continue (+ i 1)) false i))))
    # (The parsers take an index into the text and return (& index Int result ...).)
    parse_number (\ (i)
      (rec_2 0 i (\ (rec so_far i) (:
        char (get_char text i)
        (% (is_digit char) true (rec (+ (* so_far 10) (- char ascii_0)) (+ i 1)) false (& index i result so_far))))))
    parse_string (\ (i)
      (rec (+ i 1) (\ (rec i) (:
        char (get_char text i)
        (% (== char ascii_backslash)
          true (crash "escape")
          false (% (== char ascii_quote)
            true (& index (+ i 1) result empty_list)
            false (: result (rec (+ i 1)) (& index (. result index) result (cons char (. result result))))))))))
    parse_word (\ (start)
      (rec start (\ (rec i) (:
        char (get_char text i)
        (% (or (is_whitespace char) (or (== char ascii_opening_paren) (== char ascii_closing_paren)))
          true (& index i result (substr text start i))
          false (rec (+ i 1)))))))
    parse_expr (\ (parse_exprs i) (:
      i (consume_whitespace i)
      char (get_char text i)
      (% (== char ascii_opening_paren)
        true (:
          result (parse_exprs parse_exprs (+ i 1))
          i (consume_whitespace (. result index))
          (% (== (get_char text i) ascii_closing_paren)
            true (& index (+ i 1) result (| group (. result result)))
            false (crash "expected closing paren to end group")))
        false (% (is_digit char)
          true (: result (parse_number i) (& index (. result index) result (| number (. result result))))
          false (% (== char ascii_quote)
            true (: result (parse_string i) (& index (. result index) result (| string (. result result))))
            false (: result (parse_word i) (& index (. result index) result (| word (. result result)))))))))
    parse_exprs (\ (rec i) (:
      i (consume_whitespace i)
      char (get_char text i)
      (% (== char ascii_closing_paren)
        true (& index i result empty_list)
        false (:
          first (parse_expr rec i)
          rest (rec rec (. first index))
          (& index (. rest index) result (cons (. first result) (. rest result)))))))
    # (The above parsers are enough to parse a string into a tree of words (such as foo, bar), numbers
      (such as 1, 2, or 3), strings (such as "hi" or "blub"), and groups (such as (hi there)). Thyme has some
      specific semantics attached to some constellations of these. For example, if a group starts with the
      word "&", then it's actually a struct. This semantic transformation is what we do next.)
    add_semantics (\ (tree)
      (rec tree (\ (add_semantics tree)
        (% tree
          number tree
          string tree
          (word w) (| name w)
          (group g) (% g
            empty (crash "empty group")
            (more m) (:
              head (. m head)
              tail (. m tail)
              (% head
                number (| call (& callee head args (array_from_list (list_map tail (\ (t) (add_semantics t))))))
                string (| call (& callee head args (array_from_list (list_map tail (\ (t) (add_semantics t))))))
                (word w)
                  (% (str== w "&")
                    true (% (is_even (list_len tail))
                      false (crash "bad struct")
                      true (:
                        extract_fields_rec (\ (extract_fields_rec list)
                          (% list
                            empty empty_list
                            (more m) (% (. m head)
                              number (crash "bad struct")
                              string (crash "bad struct")
                              group (crash "bad struct")
                              (word field_name) (% (. m tail)
                                empty (unreachable)
                                (more m)
                                  (cons
                                    (& name field_name value (add_semantics (. m head)))
                                    (extract_fields_rec extract_fields_rec (. m tail)))))))
                        (| struct (array_from_list (extract_fields_rec extract_fields_rec tail)))))
                    false (% (str== w ".")
                      true (% (== (list_len tail) 2)
                        true (% (list_get tail 1)
                          (word w) (| field (& of (add_semantics (list_get tail 0)) name w))
                          _ (crash "field access needs to have the form (. of name)"))
                        false (crash "field access needs to have the form (. of name)"))
                      false (% (str== w "|")
                        true (% tail
                          empty (crash "bad enum")
                          (more m) (% (. m head)
                            (word variant) (:
                              payload (% (. m tail)
                                empty (| struct (array_from_list empty_list))
                                (more m) (% (. m tail)
                                  more (crash "bad enum")
                                  empty (add_semantics (. m head))))
                              (| enum (& variant variant payload payload)))
                            _ (crash "bad enum")))
                        false (% (str== w "%")
                          true (% tail
                            empty (crash "bad switch")
                            (more m) (:
                              condition (add_semantics (. m head))
                              cases
                                (% (is_even (list_len (. m tail)))
                                  false (crash "bad switch")
                                  true (:
                                    extract_cases_rec (\ (extract_cases_rec list)
                                      (% list
                                        empty empty_list
                                        (more m) (:
                                          match (% (. m head)
                                            (word variant) (& variant variant binding (| none))
                                            (group g) (% (== (list_len g) 2)
                                              false (crash "bad switch")
                                              true (&
                                                variant (% (list_get g 0) (word w) w _ (crash "bad switch"))
                                                binding (| some (% (list_get g 1) (word w) w _ (crash "bad switch")))))
                                            _ (crash "bad switch"))
                                          (% (. m tail)
                                            empty (unreachable)
                                            (more m)
                                              (cons
                                                (&
                                                  variant (. match variant)
                                                  binding (. match binding)
                                                  body (add_semantics (. m head)))
                                                (extract_cases_rec extract_cases_rec (. m tail)))))))
                                    (array_from_list (extract_cases_rec extract_cases_rec (. m tail)))))
                                (| switch (& condition condition cases cases))))
                          false (% (str== w "\\")
                            true (% (== (list_len tail) 2)
                              true (:
                                args (% (list_get tail 0)
                                  (group g)
                                    (array_from_list (list_map g (\ (item) (% item (word w) w _ (crash "bad function")))))
                                  _ (crash "bad function"))
                                body (add_semantics (list_get tail 1))
                                (| function (& args args body body)))
                              false (crash "bad function"))
                            false (% (str== w ":")
                              true (:
                                _ (% (is_odd (list_len tail)) true nil false (crash "bad let"))
                                (rec tail (\ (extract_bindings list)
                                  (% (== (list_len list) 1)
                                    true (add_semantics (list_get list 0))
                                    false
                                      (| let (&
                                        name (% (list_get list 0) (word name) name _ (crash "bad let"))
                                        def (add_semantics (list_get list 1))
                                        expr (extract_bindings (list_skip list 2))))))))
                              false
                                (| call
                                  (& callee (| name w) args (array_from_list (list_map tail (\ (t) (add_semantics t))))))))))))
                group
                  (| call (&
                    callee (add_semantics head)
                    args (array_from_list (list_map tail (\ (t) (add_semantics t)))))))))))))
    (add_semantics (. (parse_expr parse_exprs 0) result))))

  no_bindings empty_list
  bindings_add (\ (bindings name value) (cons (& name name value value) bindings))
  bindings_get (\ (bindings name)
    (% (list_find bindings (\ (binding) (str== (. binding name) name)))
      none (crash "A name is not defined.")
      (some binding) (. binding value)))
  eval (\ (code bindings)
    (rec_2 code bindings (\ (eval code bindings)
      (% code
        (name name) (bindings_get bindings name)
        (number n) n
        (add args) (+ (eval (. args left) bindings) (eval (. args right) bindings))
        (let let) (eval (. let expr) (bindings_add bindings (. let name) (eval (. let def) bindings)))
        (struct fields)
          ((. @ make_struct)
            (array_map fields (\ (field) (& name (. field name) value (eval (. field value) bindings)))))
        (field field) ((. @ field) (eval (. field of) bindings) (. field name))
        (enum enum) ((. @ make_enum) (. enum variant) (eval (. enum payload) bindings))
        (switch switch) (:
          enum (eval (. switch condition) bindings)
          variant ((. @ variant) enum)
          payload ((. @ payload) enum)
          case
            (% (array_find (. switch cases) (\ (case) (str== (. case variant) variant)))
              none (crash "Unhandled variant.")
              (some case) case)
          new_bindings
            (% (. case binding) none bindings (some name) (bindings_add bindings name payload))
          (eval (. case body) new_bindings))
        (function function) (&
          args (. function args)
          body (. function body)
          captured ((. @ make_struct) (array_from_list bindings)))
        (call call) (:
          callee (eval (. call callee) bindings)
          args (array_map (. call args) (\ (arg) (eval arg bindings)))
          inner_bindings (rec 0 (\ (rec i)
            (% (== i (array_len args))
              true (list_from_array ((. @ fields) (. callee captured)))
              false (cons (& name (array_get (. callee args) i) value (array_get args i)) (rec (+ i 1))))))
          (eval (. callee body) inner_bindings))
        ))))

  # (push (push (push (push (push empty_list 1) 2) 3) 4) 5)
  # (substr "hello world" 2 7)

  # (eval (parse "(% (| bar 5) foo 1 (bar b) b baz 3)") no_bindings)
  # (eval (parse "(: a 5 (+ a 1))") no_bindings)
  virtual_builtins (&
    add (&
      args (array_from_list (push (push empty_list "a") "b"))
      body (| add (& left (| name "a") right (| name "b")))
      captured (&))
  )
  # (crash (parse "((. @ add) 1 2)"))
  code (parse "((. @ add) 1 2)")
  result (eval code (bindings_add no_bindings "@" virtual_builtins))
  (& code code result result)
)

pow_rec = |rec, base, so_far, i| if i.==(0) then so_far else rec(rec, base, so_far.*(base), i.-(1))
pow = |base, i| pow_rec(pow_rec, base, 1, i)

is_nil = |obj| ==(@num_words(obj), 0)

# Linked Lists
head = |list| list:0
tail = |list| list:1
push_rec = |rec, list, item| if is_nil(list) then cons(item, nil) else cons(head(list), rec(rec, tail(list), item))
push = |list, item| push_rec(push_rec, list, item)
get_rec = |rec, list, index| if index.==(0) then list:0 else rec(rec, list:1, index.-(1))
get = |list, index| get_rec(get_rec, list, index)
insert_rec = |rec, list, index, item| {
  if index.==(0) then
    cons(item, list)
  else {
    if list.is_nil() then crash("bad index") else {}
    cons(list:0, rec(rec, list:1, index.-(1), item))
  }
}
insert = |list, index, item| insert_rec(insert_rec, list, index, item)
remove_rec = |rec, list, index| if index.==(0) then list:1 else cons(list:0, rec(rec, list:1, index.-(1)))
remove = |list, index| remove_rec(remove_rec, list, index)
skip_rec = |rec, list, n| if n.==(0) then list else rec(rec, list:1, n.-(1))
skip = |list, n| skip_rec(skip_rec, list, n)
take_rec = |rec, list, n| if n.==(0) then nil else cons(list:0, rec(rec, list:1, n.-(1)))
take = |list, n| take_rec(take_rec, list, n)
remove_range_rec = |rec, list, start, end| {
  if start.==(0) then list.skip(end) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1)))
}
remove_range = |list, range| remove_range_rec(remove_range_rec, list, range:0, range:1)
replace_range_rec = |rec, list, start, end, item| {
  if start.==(0) then cons(item, list.skip(end)) else cons(list:0, rec(rec, list:1, start.-(1), end.-(1), item))
}
replace_range = |list, range, item| replace_range_rec(replace_range_rec, list, range:0, range:1, item)
concat_rec = |rec, a, b| if is_nil(a) then b else cons(head(a), rec(rec, tail(a), b))
concat = |a, b| concat_rec(concat_rec, a, b)
pop_rec = |rec, list| if list.tail().is_nil() then nil else cons(list.head(), rec(rec, list.tail()))
pop = |list| pop_rec(pop_rec, list)
len_rec = |rec, list| if list.is_nil() then 0 else rec(rec, list.tail()).+(1)
len = |list| len_rec(len_rec, list)
take_and_reverse_rec = |rec, list, n, so_far| {
  if list.is_nil().or(n.==(0)) then so_far else rec(rec, list:1, n.-(1), cons(list:0, so_far))
}
take_and_reverse = |list, n| take_and_reverse_rec(take_and_reverse_rec, list, n, nil)
slice = |list, range| list.skip(range:0).take(range:1.-(range:0))
