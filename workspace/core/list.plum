# Lists
#
# In Plum, Lists are array lists.

import
  "..array"
    Array t
    generate_array Int (\ Int -> t)
    get (Array t) Int
    get_maybe (Array t) Int
    set (Array t) Int t
    slice (Array t) (Range Int)
    len (Array t)
    copy (Array t) (Array t) (Range Int)
  "..bool" Bool
  "..int"
    Int, == Int Int, + Int Int, * Int Int, max Int Int, < Int Int,
    round_up_to_power_of Int Int
  "..iterator" Iterator t, next (Iterator t)
  "..maybe" Maybe t, unwrap (Maybe t) String, else (Maybe t) t
  "..never" crash String
  "..string" String
  "..range" Range t, to t t, len (Range Int), contains (Range Int) Int
  "..test" assert Bool
  "..type" Type

List t = & array: (Array t) len: Int

#empty_list t: Type -> (List t) =
#  & array: generate_array 0 \ index: Int -> crash "not called" .as t
#    len: 0
#list a: t -> (List t) = empty_list t .reserve 1 a .push a
#list a: t b: t -> (List t) = empty_list t .reserve 2 a .push a .push b
#list a: t b: t c: t -> (List t) =
#  empty_list t .reserve 3 a .push a .push b .push c

# Makes sure that the list can reach the target_len without allocating.
reserve list: (List t) target_len: Int default_item: t -> (List t) =
  & array:
      list.array.len .< target_len
      % true ->
          generate_array
            target_len .round_up_to_power_of 2
            \ index: Int -> list.array .get_maybe index .else default_item
        false -> list.array
    len: list.len

is_empty list: (List t) -> Bool = list.len .== 0

push list: (List t) item: t -> (List t) =
  # TODO: hack so that we don't use list after the array.set
  len = list.len
  new_len = len .+ 1
  & array: (list .reserve new_len item .array .set len item) len: new_len

get_maybe list: (List t) index: Int -> (Maybe t) =
  0 .to (list.len) .contains index
  % true -> | some: list.array .get index
    false -> | none

get list: (List t) index: Int -> t =
  list .get_maybe index .unwrap "out of bounds"

slice list: (List t) range: (Range Int) -> (List t) =
  & array: list.array .slice range
    len: range.len

shrink list: (List t) -> (List t) = list .slice (0 .to (list.len))

iterate list: (List t) -> (Iterator t) =
  \ ->
    list.get_maybe 0
    % none -> | empty
      some: first ->
        | more: & item: first rest: (list .slice (1 .to (list.len)) .iterate)

#to_list iterator: (Iterator t) -> (List t) =
#  iterator.next
#  % empty -> | empty
#    more: more -> | more: & item: more.item rest: more.rest.to_list
