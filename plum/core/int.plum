## Integers
#
# If you write a number such as 3 in the code, it's an Int.

export
  Int
  + Int Int -> Int
  - Int Int -> Int
  * Int Int -> Int
  / Int Int -> Int
  == Int Int -> Bool
  != Int Int -> Bool
  < Int Int -> Bool
  <= Int Int -> Bool
  > Int Int -> Bool
  >= Int Int -> Bool
  << Int Int -> Int
  >> Int Int -> Int
  abs Int -> Int
  and Int Int -> Int
  compare Int Int -> Ordering
  format Int -> String
  is_negative Int -> Bool
  is_non_negative Int -> Bool
  is_non_positive Int -> Bool
  is_positive Int -> Bool
  log_2 Int -> Int
  max Int Int -> Int
  min Int Int -> Int
  mod Int Int -> Int
  negate Int -> Int
  or Int Int -> Int
  pow Int Int -> Int
  round_up_to_multiple_of Int Int -> Int
  round_up_to_power_of Int Int -> Int
  sqrt Int -> Int
  xor Int Int -> Int
  binary String -> Int
  hex String -> Int

import
  builtins
  ..array
  ..bool
  ..byte
  ..ordering
  ..string
  ..test
  ..never
  ..loop

# var max_int = 9223372036854775806
# var min_int = max_int + 1  # wraps around

# assert min_int < max_int

+ a: Int b: Int -> Int = add_ints a b
- a: Int b: Int -> Int = sub_ints a b
* a: Int b: Int -> Int = mul_ints a b
/ a: Int b: Int -> Int = div_ints a b
mod a: Int b: Int -> Int = mod_ints a b
and a: Int b: Int -> Int = and_ints a b
or a: Int b: Int -> Int = or_ints a b
xor a: Int b: Int -> Int = xor_ints a b

compare a: Int b: Int -> Ordering = compare_ints a b

== a: Int b: Int -> Bool = compare a b .is_==
!= a: Int b: Int -> Bool = compare a b .is_!=
<  a: Int b: Int -> Bool = compare a b .is_<
>  a: Int b: Int -> Bool = compare a b .is_>
<= a: Int b: Int -> Bool = compare a b .is_<=
>= a: Int b: Int -> Bool = compare a b .is_>=

is_positive a: Int -> Bool = a .> 0
is_negative a: Int -> Bool = a .< 0
is_non_negative a: Int -> Bool = a .>= 0
is_non_positive a: Int -> Bool = a .<= 0

<< int: Int by: Int -> Int =
  by .== 0
  % true -> int
    false -> int .* 2 .<< (by .- 1)

>> int: Int by: Int -> Int =
  by .== 0
  % true -> int
    false -> int ./ 2 .>> (by .- 1)

pow base: Int exponent: Int -> Int =
  exponent .== 0
  % true -> 1
    false -> base .* (pow base (exponent .- 1))

negate int: Int -> Int = 0 .- int

abs int: Int -> Int =
  compare int 0
  % less -> negate int
    equal -> 0
    greater -> int

round_up_to_multiple_of number: Int factor: Int -> Int =
  number .+ factor .- 1 ./ factor .* factor

round_up_to_power_of number: Int base: Int -> Int =
  loop
    1
    \ candidate: Int ->
      candidate .>= number
      % true -> | break: candidate
        false -> | continue: candidate .* base

sqrt num: Int -> Int =
  assert (num .>= 0) "you can't take the sqrt of a negative number"
  loop
    0
    \ candidate: Int ->
      next = candidate .+ 1
      next .* next .compare num
      % less -> | continue: next
        equal -> | break: next
        greater -> | break: candidate

log_2 value: Int -> Int =
  value .== 1
  % true -> 0
    false -> log_2 (value ./ 2) .+ 1

min a: Int b: Int -> Int = if (a .< b) a b
max a: Int b: Int -> Int = if (a .> b) a b

#fun parse_int(string: String): Maybe[Int] {
#  var num = 0
#  for char in string do {
#    if not({#0..=#9}.contains(char))
#    then return none[Int]()
#    num = num * 10 + {char - #0}.to_int()
#  }
#  some(num)
#}

# TODO: support different radixes
format int: Int -> String =
  int.is_negative
  % true -> "-" .++ (int.negate.format_non_negative)
    false -> int.format_non_negative

format_non_negative int: Int -> String =
  ++
    int .< 10
    % true -> ""
      false -> int ./ 10 .format
    int .mod 10 .format_digit

format_digit digit: Int -> String =
  ascii_of_zero = "0".utf8_bytes .get 0
  ascii_of_digit = ascii_of_zero.to_int .+ digit .lower_byte
  & utf8_bytes: (array ascii_of_digit)
