## Hashing
#
# You should implement a hash(&Hasher, T) function for types that can be hashed.
# In this function, they can contribute some uniqueness/entropy to the Hasher by
# calling other hash functions on it. In the end, all hash functions boil down
# to hash(&Hasher, Int). The Hasher uses the djb2 algorithm.

export
  Hash
  to_int Hash -> Int
  combine Hash Hash -> Hash
  default_hash t -> Hash
  hash (Array t) (\ t -> Hash) -> Hash
  hash Bool -> Hash
  hash Byte -> Hash
  hash Dynamic -> Hash
  hash Int -> Hash
  hash (Iterator t) (\ t -> Hash) -> Hash
  hash String -> Hash

import
  ..array
  ..bool
  ..byte
  ..dynamic
  ..int
  ..iterator
  ..list
  ..string

Hash = | hash: Int

# base_hash: Hash = | hash: Int

combine a: Hash b: Hash -> Hash = | hash: a.to_int .* 33 .+ (b.to_int)
combine_commutative a: Hash b: Hash -> Hash = | hash: a.to_int .xor (b.to_int)

to_int hash: Hash -> Int =
  hash
  % hash: value -> value

# Hashers for standard library types

default_hash value: t -> Hash = value.to_dynamic.hash

hash int: Int -> Hash = | hash: int

hash bool: Bool -> Hash =
  bool
  % false -> 0.hash
    true  -> 1.hash

hash byte: Byte -> Hash = byte.to_int.hash

hash iterator: (Iterator t) hash_item: (\ t -> Hash) -> Hash =
  iterator
  . fold (| hash: 5381) (\ hash: Hash item: t -> combine hash (item.hash_item))

hash_commutative iterator: (Iterator t) hash_item: (\ t -> Hash) -> Hash =
  iterator
  . fold
      | hash: 5381
      \ hash: Hash item: t -> combine_commutative hash (item.hash_item)

hash array: (Array t) hash_item: (\ t -> Hash) -> Hash =
  combine (array.length.hash) (array.iterate .hash hash_item)

hash string: String -> Hash =
  string.utf8_bytes .hash (\ byte: Byte -> byte.hash)

hash dynamic: Dynamic -> Hash =
  dynamic
  % byte: byte -> "byte".hash .combine (byte.hash)
    int: int -> "int".hash .combine (int.hash)
    type -> "type".hash
    box: inner -> "box".hash .combine (inner.hash)
    array: items ->
      "array".hash .combine (items.hash (\ item: Dynamic -> item.hash))
    struct: fields ->
      "struct".hash
      . combine
          fields.iterate
          . hash_commutative
              \ field: (& name: String value: Dynamic) ->
                combine (field.name.hash) (field.value.hash)
    enum: (& name value) ->
      "enum".hash .combine (name.hash) .combine (value.hash)
    lambda -> "lambda".hash
