# Byte
# A value from 0 to 255. All arithmetic operations wrap around. TODO: do they?

export
  Byte
  + Byte Byte -> Byte
  - Byte Byte -> Byte
  * Byte Byte -> Byte
  / Byte Byte -> Byte
  == Byte Byte -> Bool
  != Byte Byte -> Bool
  < Byte Byte -> Bool
  <= Byte Byte -> Bool
  > Byte Byte -> Bool
  >= Byte Byte -> Bool
  << Byte Byte -> Byte
  >> Byte Byte -> Byte
  compare Byte Byte -> Ordering
  format Byte -> String
  lower_byte Int -> Byte
  to_byte Int -> Byte
  to_int Byte -> Int
  and Byte Byte -> Byte
  or Byte Byte -> Byte
  xor Byte Byte -> Byte

import
  builtins
  ..bool
  ..int
  ..string
  ..test
  ..ordering

to_int byte: Byte -> Int = byte.byte_to_int

to_byte int: Int -> Byte =
  assert ((int .>= 0) .and (int .< 256))
  int.lower_byte

+   a: Byte b: Byte -> Byte = a.to_int .+   (b.to_int) .lower_byte
-   a: Byte b: Byte -> Byte = a.to_int .-   (b.to_int) .lower_byte
*   a: Byte b: Byte -> Byte = a.to_int .*   (b.to_int) .lower_byte
/   a: Byte b: Byte -> Byte = a.to_int ./   (b.to_int) .lower_byte
mod a: Byte b: Byte -> Byte = a.to_int .mod (b.to_int) .lower_byte
and a: Byte b: Byte -> Byte = a.to_int .and (b.to_int) .lower_byte
or  a: Byte b: Byte -> Byte = a.to_int .or  (b.to_int) .lower_byte
xor a: Byte b: Byte -> Byte = a.to_int .xor (b.to_int) .lower_byte

compare a: Byte b: Byte -> Ordering = a.to_int .compare (b.to_int)

== a: Byte b: Byte -> Bool = a.to_int .== (b.to_int)
!= a: Byte b: Byte -> Bool = a.to_int .!= (b.to_int)
<  a: Byte b: Byte -> Bool = a.to_int .<  (b.to_int)
>  a: Byte b: Byte -> Bool = a.to_int .>  (b.to_int)
<= a: Byte b: Byte -> Bool = a.to_int .<= (b.to_int)
>= a: Byte b: Byte -> Bool = a.to_int .>= (b.to_int)

<< byte: Byte by: Byte -> Byte = byte.to_int .<< (by.to_int) .lower_byte
>> byte: Byte by: Byte -> Byte = byte.to_int .>> (by.to_int) .lower_byte

min a: Byte b: Byte -> Byte = if (a .< b) a b
max a: Byte b: Byte -> Byte = if (a .> b) a b

format byte: Byte -> String = byte.to_int.format
