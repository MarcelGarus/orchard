export
  Array t
  empty_array a:Type -> (Array a)
  filled_array Int a -> (Array a)
  array a -> (Array a)
  array a a -> (Array a)
  array a a a -> (Array a)
  array a a a a -> (Array a)
  array a a a a a -> (Array a)
  array a a a a a a -> (Array a)
  array a a a a a a a -> (Array a)
  get (Array a) Int -> a
  get_maybe (Array a) Int -> (Maybe a)
  set (Array a) Int a -> (Array a)
  slice (Array a) (Range Int) -> (Array a)
  length (Array a) -> Int
  is_empty (Array a) -> Bool
  concat (Array a) (Array a) -> (Array a)
  iterate (Array a) -> (Iterator a)
  == (Array a) (\ a a -> Bool) -> Bool
  == (Array Byte) (Array Byte)
  starts_with (Array a) (Array a) (\ a a -> Bool) -> Bool
  starts_with (Array Byte) (Array Byte) -> Bool

import
  "builtins"
  "..bool"
  "..byte"
  "..int"
  "..iterator"
  "..maybe"
  "..never"
  "..range"
  "..string"
  "..test"
  "..type"

empty_array t: Type -> (Array t) =
  generate_array 0 \ index: Int -> crash "never called" .as t

filled_array length: Int item: t -> (Array t) =
  generate_array length \ index: Int -> item

array a: t -> (Array t) = filled_array 1 a
array a: t b: t -> (Array t) = filled_array 2 a .set 1 b
array a: t b: t c: t -> (Array t) = filled_array 3 a .set 1 b .set 2 c
array a: t b: t c: t d: t -> (Array t) =
  filled_array 4 a .set 1 b .set 2 c .set 3 d
array a: t b: t c: t d: t e: t -> (Array t) =
  filled_array 5 a .set 1 b .set 2 c .set 3 d .set 4 e
array a: t b: t c: t d: t e: t f: t -> (Array t) =
  filled_array 6 a .set 1 b .set 2 c .set 3 d .set 4 e .set 5 f

get array: (Array t) index: Int -> t = array .array_get index

get_maybe array: (Array t) index: Int -> (Maybe t) =
  (0 .to (array.length)) .contains index
  % true -> | some: (array .get index)
    false -> | none

set array: (Array t) index: Int item: t -> (Array t) =
  array .array_set index item

slice array: (Array t) range: (Range Int) -> (Array t) =
  array .array_slice range

length array: (Array t) -> Int = array.array_len

is_empty array: (Array t) -> Bool = array.length .== 0

copy destination: (Array t) source: (Array t) range: (Range Int) -> (Array t) =
  # Copies to source items into the destination array at the range.
  assert (source.length .== (range.length))
  range.is_empty
  % true -> destination
    false ->
      copy
        destination .set (range.start) (source .get 0)
        source .slice (1 .to (source.length))
        range.start .+ 1 .to (range.end)

concat a: (Array t) b: (Array t) -> (Array t) =
  generate_array
    a.length .+ (b.length)
    \ index: Int ->
      index .< (a.length)
      % true -> a .get index
        false -> b .get (index .- (a.length))

iterate array: (Array t) -> (Iterator t) =
  \ ->
    array.is_empty
    % true -> | empty
      false ->
        | more:
            & item: array .get 0
              rest: array .slice (1 .to (array.length)) .iterate

== a: (Array t) b: (Array t) comparer: (\ t t -> Bool) -> Bool =
  a.length .== (b.length)
  % false -> | false
    true ->
      zip (a.iterate) (b.iterate)
      . all \ both: (& a: t b: t) -> comparer (both.a) (both.b)

== a: (Array Byte) b: (Array Byte) -> Bool = == a b \ a: Byte b: Byte -> a .== b

starts_with array: (Array t) prefix: (Array t) comparer: (\ t t -> Bool) -> Bool
= array.length .>= (prefix.length)
  % false -> | false
    true -> compare (array .slice (0 .to (prefix.length))) prefix comparer

starts_with array: (Array Byte) prefix: (Array Byte) -> Bool =
  array .starts_with prefix (\ a: Byte b: Byte -> a .== b)
