import
  "..any" any Type
  "..array" Array t, generate_array Int (\ Int -> t), get (Array t) Int, set (Array t) Int t
  "..int" Int, * Int Int, mod Int Int, + Int Int, / Int Int, == Int Int
  "..type" Type

Position = & x: Int y: Int

Size = & width: Int height: Int

+ a: Size b: Size -> Size =
  & width: (a.width .+ (b.width)) height: (a.height .+ (b.height))

Matrix t = & cells: (Array t) size: Size

generate_matrix size: Size generator: (\ Int Int -> t) -> (Matrix t) =
  # Note: Because division and modulo operations are rather expensive, we
  # generate an uninitialized array and then fill it while keeping track of the
  # x and y coordinates rather than using the generate_array builtin and then
  # calculating the x and y matching the index.
  (& width height) = size
  placeholder = any t
  cells =
    generate_array (width .* height) (\ i: Int -> placeholder)
    . init 0 width height generator
  & cells size
  #& cells:
  #    generate_array
  #      (size.width) .* (size.height)
  #      \ i: Int -> generator (i .mod (size.width)) (i ./ (size.width))
  #  size
init cells: (Array t) y: Int width: Int height: Int generator: (\ Int Int -> t) -> (Array t) =
  y .== height
  % true -> cells
    false ->
      cells
      .init 0 y width height generator
      .init (y .+ 1) width height generator
init cells: (Array t) x: Int y: Int width: Int height: Int generator: (\ Int Int -> t) -> (Array t) =
  x .== width
  % true -> cells
    false ->
      cells
      .set (width .* y .+ x) (generator x y)
      .init (x .+ 1) y width height generator

get matrix: (Matrix t) x: Int y: Int -> t =
  matrix.cells .get (y .* (matrix.size.width) .+ x)

get matrix: (Matrix t) at: Position -> t = matrix .get (at.x) (at.y)

set matrix: (Matrix t) x: Int y: Int value: t -> (Matrix t) =
  & size: matrix.size
    cells: matrix.cells .set (y .* (matrix.size.width) .+ x) value

set matrix: (Matrix t) at: Position value: t -> (Matrix t) =
  matrix .set (at.x) (at.y) value
