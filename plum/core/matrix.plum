import "..any" "..array" "..int" "..type"

Position = & x: Int y: Int

+ a: Position b: Position -> Position = & x: (a.x .+ (b.x)) y: (a.y .+ (b.y))

Size = & width: Int height: Int

+ a: Size b: Size -> Size =
  & width: (a.width .+ (b.width)) height: (a.height .+ (b.height))

Matrix t = & cells: (Array t) size: Size

filled_matrix size: Size item: t -> (Matrix t) =
  (& width height) = size
  & size cells: (generate_array (width .* height) (\ i: Int -> item))

generate_matrix size: Size generator: (\ Int Int -> t) -> (Matrix t) =
  # Note: Because division and modulo operations are rather expensive, we
  # generate an uninitialized array and then fill it while keeping track of the
  # x and y coordinates rather than using the generate_array builtin and then
  # calculating the x and y matching the index.
  (& width height) = size
  placeholder = any t
  cells =
    generate_array (width .* height) (\ i: Int -> placeholder)
    . init 0 width height generator
  & cells size
  #& cells:
  #    generate_array
  #      (size.width) .* (size.height)
  #      \ i: Int -> generator (i .mod (size.width)) (i ./ (size.width))
  #  size
init cells: (Array t) y: Int width: Int height: Int generator: (\ Int Int -> t) -> (Array t) =
  y .== height
  % true -> cells
    false ->
      cells
      . init 0 y width height generator
      . init (y .+ 1) width height generator
init cells: (Array t) x: Int y: Int width: Int height: Int generator: (\ Int Int -> t) -> (Array t) =
  x .== width
  % true -> cells
    false ->
      cells
      . set (width .* y .+ x) (generator x y)
      . init (x .+ 1) y width height generator

get matrix: (Matrix t) x: Int y: Int -> t =
  matrix.cells .get (y .* (matrix.size.width) .+ x)

get matrix: (Matrix t) at: Position -> t = matrix .get (at.x) (at.y)

set matrix: (Matrix t) x: Int y: Int value: t -> (Matrix t) =
  & size: matrix.size
    cells: matrix.cells .set (y .* (matrix.size.width) .+ x) value

set matrix: (Matrix t) at: Position value: t -> (Matrix t) =
  matrix .set (at.x) (at.y) value
