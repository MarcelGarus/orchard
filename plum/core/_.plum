# Welcome to Plum!

export
  any t:Type -> t
  Array t
  empty_array a:Type -> (Array a)
  filled_array Int a -> (Array a)
  array a -> (Array a)
  array a a -> (Array a)
  array a a a -> (Array a)
  array a a a a -> (Array a)
  array a a a a a -> (Array a)
  array a a a a a a -> (Array a)
  array a a a a a a a -> (Array a)
  get (Array a) Int -> a
  get_maybe (Array a) Int -> (Maybe a)
  set (Array a) Int a -> (Array a)
  slice (Array a) (Range Int) -> (Array a)
  length (Array a) -> Int
  is_empty (Array a) -> Bool
  concat (Array a) (Array a) -> (Array a)
  iterate (Array a) -> (Iterator a)
  == (Array a) (\ a a -> Bool) -> Bool
  == (Array Byte) (Array Byte)
  starts_with (Array a) (Array a) (\ a a -> Bool) -> Bool
  starts_with (Array Byte) (Array Byte) -> Bool
  Bool
  not Bool -> Bool
  == Bool Bool -> Bool
  and Bool Bool -> Bool
  format Bool -> String
  if Bool t t -> t
  if Bool t (\ -> t) -> t
  if Bool (\ -> t) t -> t
  implies Bool Bool -> Bool
  or Bool Bool -> Bool
  xor Bool Bool -> Bool
  Box t
  box t -> (Box t)
  unbox (Box t) -> t
  Byte
  == Byte Byte -> Bool
  format Byte -> String
  lower_byte Int -> Byte
  to_byte Int -> Byte
  to_int Byte -> Int
  call (\ -> t) -> t
  Dynamic
  format Dynamic -> String
  to_dynamic t -> Dynamic
  to_static Dynamic a:Type -> a
  debug_format t -> String
  Hash
  to_int Hash -> Int
  combine Hash Hash -> Hash
  default_hash t -> Hash
  hash (Array t) (\ t -> Hash) -> Hash
  hash Bool -> Hash
  hash Byte -> Hash
  hash Dynamic -> Hash
  hash Int -> Hash
  hash (Iterator t) (\ t -> Hash) -> Hash
  hash String -> Hash
  Int
  + Int Int -> Int
  - Int Int -> Int
  * Int Int -> Int
  / Int Int -> Int
  == Int Int -> Bool
  != Int Int -> Bool
  < Int Int -> Bool
  <= Int Int -> Bool
  > Int Int -> Bool
  >= Int Int -> Bool
  << Int Int -> Int
  >> Int Int -> Int
  abs Int -> Int
  and Int Int -> Int
  compare Int Int -> Ordering
  format Int -> String
  is_negative Int -> Bool
  is_non_negative Int -> Bool
  is_non_positive Int -> Bool
  is_positive Int -> Bool
  log_2 Int -> Int
  max Int Int -> Int
  min Int Int -> Int
  mod Int Int -> Int
  negate Int -> Int
  or Int Int -> Int
  pow Int Int -> Int
  round_up_to_multiple_of Int -> Int
  round_up_to_power_of Int -> Int
  sqrt Int -> Int
  xor Int Int -> Int
  binary String -> Int
  hex String -> Int
  Iterator a
  next (Iterator a) -> (| empty more: (& item: a rest: (Iterator t)))
  filter_map (Iterator a) (\ a -> (Maybe b)) -> (Iterator b)
  map (Iterator a) (\ a -> b) -> (Iterator b)
  filter (Iterator a) (\ a -> Bool) -> (Iterator a)
  skip (Iterator a) Int -> (Iterator a)
  take (Iterator a) Int -> (Iterator a)
  skip_while (Iterator a) (\ a -> Bool) -> (Iterator a)
  take_while (Iterator a) (\ a -> Bool) -> (Iterator a)
  map_while (Iterator a) (\ a -> (Maybe b)) -> (Iterator b)
  zip (Iterator a) (Iterator b) -> (Iterator (& a: a b: b))
  enumerate (Iterator a) -> (Iterator (& index: Int item: a))
  first (Iterator a) -> (Maybe a)
  last (Iterator a) -> (Maybe a)
  nth (Iterator a) Int -> (Maybe a)
  step_by (Iterator a) Int -> (Iterator a)
  chain (Iterator a) (Iterator a) -> (Iterator a)
  flat_map (Iterator a) mapper: (\ a -> (Iterator b)) -> (Iterator b)
  intersperse (Iterator a) a -> (Iterator a)
  flatten (Iterator (Iterator a))
  fold (Iterator a) state (\ state a -> state)
  reduce (Iterator a) reducer: (\ a a -> a) -> (Maybe a)
  count (Iterator a) -> Int
  sum (Iterator Int) -> Int
  min (Iterator Int) -> (Maybe Int)
  max (Iterator Int) -> (Maybe Int)
  cycle (Iterator a) -> (Iterator a)
  find (Iterator a) (\ a -> Bool) -> (Maybe a)
  all_true (Iterator Bool) -> Bool
  all (Iterator a) (\ a -> Bool) -> Bool
  any_true (Iterator Bool) -> Bool
  any (Iterator a) (\ a -> Bool) -> Bool
  join (Iterator String) -> String
  join (Iterator String) String -> String
  List a
  empty_list a:Type -> (List a)
  list a -> (List a)
  list a a -> (List a)
  list a a a -> (List a)
  list a a a a -> (List a)
  reserve_for_length (List a) Int -> (List a)
  reserve_for_extra (List a) Int -> (List a)
  is_empty (List a) -> Bool
  push (List a) a -> (List a)
  push_without_growing (List a) a -> (Result (List a) Nothing)
  push_all (List a) (Iterator a) -> (List a)
  get_maybe (List a) Int -> (Maybe a)
  get (List a) Int -> a
  slice (List a) (Range Int) -> (List a)
  shrink (List a) -> (List a)
  to_array (List a) -> (Array a)
  iterate (List a) -> (Iterator a)
  to_list (Iterator a) -> (List a)
  Map k v
  => k v -> (Entry k v)
  empty_map
    k:Type v:Type capacity:Int (\ k -> Hash) (\ k k -> Bool) -> (Map k v)
  empty_map k:Type v:Type (\ k -> Hash) (\ k k -> Bool) -> (Map k v)
  reserve_for_size (Map k v) Int -> (Map k v)
  put (Map k v) (Entry k v) -> (Map k v)
  put (Map k v) k v -> (Map k v)
  put_all (Map k v) (Iterator (Entry k v)) -> (Map k v)
  get (Map k v) k -> v
  get_maybe (Map k v) k -> (Maybe v)
  remove (Map k v) k -> (Map k v)
  iterate (Map k v) -> (Iterator (Entry k v))
  keys (Map k v) -> (Iterator k)
  values (Map k v) -> (Iterator v)
  contains (Map k v) k -> Bool
  empty_int_map v:Type -> (Map Int v)
  empty_string_map v:Type -> (Map String v)
  map (List (Entry Int v)) -> (Map Int v)
  map (List (Entry String v)) -> (Map String v)
  Maybe a
  is_some (Maybe a) -> Bool
  is_none (Maybe a) -> Bool
  unwrap (Maybe a) -> a
  unwrap (Maybe a) String -> a
  else (Maybe a) a -> a
  map (Maybe a) (\ a -> b) -> (Maybe b)
  flatten (Maybe (Maybe a)) -> (Maybe a)
  Never
  crash String -> Never
  Nothing
  format Nothing
  ignore t
  Ordering
  flip Ordering -> Ordering
  is_== Ordering -> Bool
  is_!= Ordering -> Bool
  is_< Ordering -> Bool
  is_> Ordering -> Bool
  is_<= Ordering -> Bool
  is_>= Ordering -> Bool
  OpenRange a
  Range a
  contains (Range Int) Int -> Bool
  is_empty (Range Int) -> Bool
  iterate (OpenRange Int) -> (Iterator Int)
  iterate (Range Int) -> (Iterator Int)
  length (Range Int) -> Int
  through Int Int -> (Range Int)
  to a a -> (Range a)
  to_infinity a -> (OpenRange a)
  Result o e
  is_ok (Result o e) -> Bool
  is_error (Result o e) -> Bool
  unwrap (Result o e) -> o
  unwrap (Result o e) String -> o
  map (Result a e) (\ a -> b) -> (Result b e)
  map_error (Result o a) (\ a -> b) -> (Result o b)
  Set a
  empty_set a capacity:Int (\ a -> Hash) (\ a a -> Bool) -> (Set a)
  empty_set a (\ a -> Hash) (\ a a -> Bool) -> (Set a)
  put (Set a) a -> (Set a)
  String
  + String String -> String
  == String String -> String
  length String -> Int
  slice String (Range Int) -> String
  starts_with String String -> Bool
  assert Bool -> Nothing
  assert Bool String -> Nothing
  Type
  TypeInfo
  type_of t -> Type
  type_info Type -> TypeInfo
  as t t:Type -> t
  format TypeInfo -> String

import
  ".any"
  ".array"
  ".bool"
  ".box"
  ".byte"
  ".call"
  ".dynamic"
  ".format"
  ".hash"
  ".int"
  ".iterator"
  ".list"
  ".map"
  ".matrix"
  ".maybe"
  ".never"
  ".nothing"
  ".ordering"
  ".range"
  ".result"
  ".set"
  ".string"
  ".test"
  ".type"
