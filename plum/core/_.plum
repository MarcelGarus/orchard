# Welcome to Plum!

export
  Array t
  Bool
  Box t
  Byte
  Dynamic
  Hash
  Int
  Iterator a
  List a
  Map k v
  MapEntry k v
  Maybe a
  Never
  Nothing
  OpenRange a
  Ordering
  Range a
  Result o e
  Set a
  String
  Type
  TypeInfo
  - Byte Byte -> Byte
  - Int Int -> Int
  != Byte Byte -> Bool
  != Int Int -> Bool
  * Byte Byte -> Byte
  * Int Int -> Int
  / Byte Byte -> Byte
  / Int Int -> Int
  + Byte Byte -> Byte
  + Int Int -> Int
  ++ String String -> String
  < Byte Byte -> Bool
  < Int Int -> Bool
  << Byte Byte -> Byte
  << Int Int -> Int
  <= Byte Byte -> Bool
  <= Int Int -> Bool
  == (Array a) (Array a) (\ a a -> Bool) -> Bool
  == (Array Byte) (Array Byte)
  == Bool Bool -> Bool
  == Byte Byte -> Bool
  == Byte Byte -> Bool
  == Int Int -> Bool
  == String String -> String
  => k v -> (MapEntry k v)
  > Byte Byte -> Bool
  > Int Int -> Bool
  >= Byte Byte -> Bool
  >= Int Int -> Bool
  >> Byte Byte -> Byte
  >> Int Int -> Int
  and Byte Byte -> Byte
  or Byte Byte -> Byte
  xor Byte Byte -> Byte
  compare Byte Byte -> Ordering
  abs Int -> Int
  all (Iterator a) (\ a -> Bool) -> Bool
  all_true (Iterator Bool) -> Bool
  and Bool Bool -> Bool
  and Int Int -> Int
  any (Iterator a) (\ a -> Bool) -> Bool
  any t:Type -> t
  any_true (Iterator Bool) -> Bool
  array a -> (Array a)
  array a a -> (Array a)
  array a a a -> (Array a)
  array a a a a -> (Array a)
  array a a a a a -> (Array a)
  array a a a a a a -> (Array a)
  array a a a a a a a -> (Array a)
  as t t:Type -> t
  assert Bool -> Nothing
  assert Bool String -> Nothing
  binary String -> Int
  box t -> (Box t)
  call (\ -> t) -> t
  chain (Iterator a) (Iterator a) -> (Iterator a)
  combine Hash Hash -> Hash
  compare Int Int -> Ordering
  concat (Array a) (Array a) -> (Array a)
  contains (Map k v) k -> Bool
  contains (Range Int) Int -> Bool
  count (Iterator a) -> Int
  crash String -> Never
  cycle (Iterator a) -> (Iterator a)
  debug_format t -> String
  default_hash t -> Hash
  else (Maybe a) a -> a
  empty_array a:Type -> (Array a)
  empty_int_map v:Type -> (Map Int v)
  empty_list a:Type -> (List a)
  empty_map
    k:Type v:Type capacity:Int (\ k -> Hash) (\ k k -> Bool) -> (Map k v)
  empty_map k:Type v:Type (\ k -> Hash) (\ k k -> Bool) -> (Map k v)
  empty_set a (\ a -> Hash) (\ a a -> Bool) -> (Set a)
  empty_set a capacity:Int (\ a -> Hash) (\ a a -> Bool) -> (Set a)
  empty_string_map v:Type -> (Map String v)
  enumerate (Iterator a) -> (Iterator (& index: Int item: a))
  filled_array Int a -> (Array a)
  filter (Iterator a) (\ a -> Bool) -> (Iterator a)
  filter_map (Iterator a) (\ a -> (Maybe b)) -> (Iterator b)
  find (Iterator a) (\ a -> Bool) -> (Maybe a)
  first (Iterator a) -> (Maybe a)
  flat_map (Iterator a) mapper: (\ a -> (Iterator b)) -> (Iterator b)
  flatten (Iterator (Iterator a))
  flatten (Maybe (Maybe a)) -> (Maybe a)
  flip Ordering -> Ordering
  fold (Iterator a) state (\ state a -> state)
  format Bool -> String
  format Byte -> String
  format Dynamic -> String
  format Int -> String
  format Nothing
  format TypeInfo -> String
  generate_array Int (\ Int -> a) -> (Array a)
  get (Array a) Int -> a
  get (List a) Int -> a
  get (Map k v) k -> v
  get_maybe (Array a) Int -> (Maybe a)
  get_maybe (List a) Int -> (Maybe a)
  get_maybe (Map k v) k -> (Maybe v)
  hash (Array t) (\ t -> Hash) -> Hash
  hash (Iterator t) (\ t -> Hash) -> Hash
  hash Bool -> Hash
  hash Byte -> Hash
  hash Dynamic -> Hash
  hash Int -> Hash
  hash String -> Hash
  hex String -> Int
  if Bool (\ -> t) t -> t
  if Bool t (\ -> t) -> t
  if Bool t t -> t
  ignore t
  implies Bool Bool -> Bool
  intersperse (Iterator a) a -> (Iterator a)
  is_!= Ordering -> Bool
  is_< Ordering -> Bool
  is_<= Ordering -> Bool
  is_== Ordering -> Bool
  is_> Ordering -> Bool
  is_>= Ordering -> Bool
  is_empty (Array a) -> Bool
  is_empty (List a) -> Bool
  is_empty (Range Int) -> Bool
  is_error (Result o e) -> Bool
  is_negative Int -> Bool
  is_non_negative Int -> Bool
  is_non_positive Int -> Bool
  is_none (Maybe a) -> Bool
  is_ok (Result o e) -> Bool
  is_positive Int -> Bool
  is_some (Maybe a) -> Bool
  iterate (Array a) -> (Iterator a)
  iterate (List a) -> (Iterator a)
  iterate (Map k v) -> (Iterator (MapEntry k v))
  iterate (OpenRange Int) -> (Iterator Int)
  iterate (Range Int) -> (Iterator Int)
  join (Iterator String) -> String
  join (Iterator String) String -> String
  keys (Map k v) -> (Iterator k)
  last (Iterator a) -> (Maybe a)
  length (Array a) -> Int
  length (Range Int) -> Int
  length String -> Int
  list a -> (List a)
  list a a -> (List a)
  list a a a -> (List a)
  list a a a a -> (List a)
  list a a a a a -> (List a)
  list a a a a a a -> (List a)
  list a a a a a a a -> (List a)
  list a a a a a a a a -> (List a)
  list a a a a a a a a a -> (List a)
  list a a a a a a a a a a -> (List a)
  log_2 Int -> Int
  loop s (\ s -> (| break: r continue: s)) -> r
  lower_byte Int -> Byte
  map (Iterator a) (\ a -> b) -> (Iterator b)
  map (List (MapEntry Int v)) -> (Map Int v)
  map (List (MapEntry String v)) -> (Map String v)
  map (Maybe a) (\ a -> b) -> (Maybe b)
  map (Result a e) (\ a -> b) -> (Result b e)
  map_error (Result o a) (\ a -> b) -> (Result o b)
  map_while (Iterator a) (\ a -> (Maybe b)) -> (Iterator b)
  max (Iterator Int) -> (Maybe Int)
  max Int Int -> Int
  min (Iterator Int) -> (Maybe Int)
  min Int Int -> Int
  mod Int Int -> Int
  negate Int -> Int
  next (Iterator a) -> (| empty more: (& item: a rest: (Iterator t)))
  not Bool -> Bool
  nth (Iterator a) Int -> (Maybe a)
  or Bool Bool -> Bool
  or Int Int -> Int
  pow Int Int -> Int
  push (List a) a -> (List a)
  push_all (List a) (Iterator a) -> (List a)
  push_without_growing (List a) a -> (Result (List a) Nothing)
  put (Map k v) (MapEntry k v) -> (Map k v)
  put (Map k v) k v -> (Map k v)
  put (Set a) a -> (Set a)
  put_all (Map k v) (Iterator (MapEntry k v)) -> (Map k v)
  reduce (Iterator a) reducer: (\ a a -> a) -> (Maybe a)
  remove (Map k v) k -> (Map k v)
  reserve_for_extra (List a) Int -> (List a)
  reserve_for_length (List a) Int -> (List a)
  reserve_for_size (Map k v) Int -> (Map k v)
  round_up_to_multiple_of Int -> Int
  round_up_to_power_of Int -> Int
  set (Array a) Int a -> (Array a)
  shrink (List a) -> (List a)
  skip (Iterator a) Int -> (Iterator a)
  skip_while (Iterator a) (\ a -> Bool) -> (Iterator a)
  slice (Array a) (Range Int) -> (Array a)
  slice (List a) (Range Int) -> (List a)
  slice String (OpenRange Int) -> String
  slice String (Range Int) -> String
  sqrt Int -> Int
  starts_with (Array a) (Array a) (\ a a -> Bool) -> Bool
  starts_with (Array Byte) (Array Byte) -> Bool
  starts_with String String -> Bool
  step_by (Iterator a) Int -> (Iterator a)
  sum (Iterator Int) -> Int
  take (Iterator a) Int -> (Iterator a)
  take_while (Iterator a) (\ a -> Bool) -> (Iterator a)
  through Int Int -> (Range Int)
  to a a -> (Range a)
  to_array (List a) -> (Array a)
  to_byte Int -> Byte
  to_dynamic t -> Dynamic
  to_end a -> (OpenRange a)
  to_infinity a -> (OpenRange a)
  to_int Byte -> Int
  to_int Hash -> Int
  to_list (Iterator a) -> (List a)
  to_static Dynamic a:Type -> a
  type_info Type -> TypeInfo
  type_of t -> Type
  unbox (Box t) -> t
  unwrap (Maybe a) -> a
  unwrap (Maybe a) String -> a
  unwrap (Result o e) -> o
  unwrap (Result o e) String -> o
  values (Map k v) -> (Iterator v)
  xor Bool Bool -> Bool
  xor Int Int -> Int
  zip (Iterator a) (Iterator b) -> (Iterator (& a: a b: b))

import
  .any
  .array
  .bool
  .box
  .byte
  .call
  .dynamic
  .format
  .hash
  .int
  .iterator
  .list
  .loop
  .map
  .maybe
  .never
  .nothing
  .ordering
  .range
  .result
  .set
  .string
  .test
  .type
