export
  Font
  Glyph
  draw_text Texture String Position width:Int Font Color -> Texture

import
  ...core
  ..color
  ..texture
  ..rectangle
  ..matrix
  ...bit_patterns

Grapheme = String
# A grapheme is a (usually) short string that represents one visible character
# when rendering text. For ASCII strings, every grapheme is a single byte. For
# Unicode strings, graphemes can be longer, i.e. complicated characters or
# emojis.

break_into_graphemes text: String -> (List Grapheme) =
  loop
    & graphemes_so_far:
        empty_list Grapheme .reserve_for_length (text.utf8_bytes.length)
      rest: text 
    \ state: (& graphemes_so_far: (List Grapheme) rest: String) ->
      (& graphemes_so_far rest) = state
      rest.utf8_bytes.length .== 0
      % true -> | break: graphemes_so_far
        false ->
          byte = rest.utf8_bytes .get 0
          num_bytes =
            byte .matches_mask "0xxx xxxx"
            % true -> 1
              false ->
                byte .matches_mask "10xx xxxx"
                % true -> 2
                  false ->
                    byte.matches_mask "110x xxxx"
                    % true -> 3
                      false ->
                        byte.matches_mask "1110 xxxx"
                        % true -> 4
                          false -> crash "unsupported UTF encoding"
          | continue:
              & graphemes_so_far:
                  graphemes_so_far
                  . push_without_growing (rest .slice (0 .to num_bytes))
                  . unwrap
                rest: (rest .slice (num_bytes .to_end))

may_replace_by_wrap grapheme: String -> Bool =
  # TODO: Have better logic here.
  grapheme .== " "

# Fonts are a collection of glyphs, descriptions of how to render characters.

Font =
  & line_height: Int
    glyphs: (Map Grapheme Glyph)
    tofu: Glyph
Glyph = Matrix Bool
# TODO: This doesn't correctly model i.e. emojis that are colored.

get_or_tofu font: Font grapheme: String -> Glyph =
  font.glyphs .get_maybe grapheme .else (font.tofu)

PositionedGlyph = & position: Position glyph: Glyph

layout
  graphemes: (List Grapheme) font: Font width: Int -> (List PositionedGlyph)
= # TODO: word wrap
  graphemes
  . iterate
  . fold
      & glyphs: (empty_list PositionedGlyph) x: 0
      \ state: (& glyphs: (List PositionedGlyph) x: Int) grapheme: Grapheme ->
        (& glyphs x) = state
        glyph = font .get_or_tofu grapheme
        & glyphs: glyphs .push (& position: (& x y: 0) glyph)
          x: x .+ (glyph.size.width)
  . glyphs

draw_text
  texture: Texture
  text: String
  where: Position
  width: Int
  font: Font
  color: Color
  -> Texture
= text
  . break_into_graphemes
  . layout font width
  . iterate
  . fold
      texture
      \ texture: Texture glyph: PositionedGlyph ->
        texture .draw_glyph (glyph.glyph) (where .+ (glyph.position)) color

draw_glyph texture: Texture glyph: Glyph where: Position color: Color -> Texture
= texture
  . update_area
      where .by (glyph.size)
      \ position: Position old: Color ->
        glyph .get position
        % true -> color
          false -> old
