export
  Font
  Glyph
  draw_text Texture String Position width:Int Font Color -> Texture

import "...core" "..color" "..texture" "..rectangle"

Grapheme = String
# A grapheme is a (usually) short string that represents one visible character
# when rendering text. For ASCII strings, every grapheme is a single byte. For
# Unicode strings, graphemes can be longer, i.e. complicated characters or
# emojis.

break_into_graphemes text: String -> (List Grapheme) =
  text
  .break_into_graphemes (empty_list Grapheme .reserve (text.utf8_bytes.length))
break_into_graphemes text: String graphemes_so_far: (List Grapheme) -> (List Grapheme)
= # TODO: Do this properly.
  text.utf8_bytes.length .== 0
  % true -> graphemes_so_far
    false ->
      byte = text.utf8_bytes .get 0
      num_bytes =
        byte .matches_mask "0XXX XXXX"
        % true -> 1
          false ->
            byte .matches_mask "10XX XXXX"
            % true -> 2
              false ->
                byte.matches_mask "110X XXXX"
                % true -> 3
                  false ->
                    byte.matches_mask "1110 XXXX"
                    % true -> 4
                      false -> crash "unsupported UTF encoding"
      break_into_graphemes
        text .slice (num_bytes .to_end)
        graphemes_so_far
        . push_without_growing (text .slice (0 .to num_bytes))
        . unwrap

#  text
#  . utf8_bytes
#  . iterate
#  . map \ byte: Byte -> & utf8_bytes: (array byte)
#  . to_list

may_replace_by_wrap grapheme: String -> Bool =
  # TODO: Have better logic here.
  grapheme .== " "

# Fonts are a collection of glyphs, descriptions of how to render characters.

Font =
  & line_height: Int
    glyphs: (Map Grapheme Glyph)
    tofu: Glyph
Glyph = Matrix Bool
# TODO: This doesn't correctly model i.e. emojis that are colored.

get_or_tofu font: Font grapheme: String -> Glyph =
  font.glyphs .get_maybe grapheme .else (font.tofu)

PositionedGlyph = & position: Position glyph: Glyph

layout
  graphemes: (List Grapheme) font: Font width: Int -> (List PositionedGlyph)
= # TODO: word wrap
  graphemes
  . iterate
  . fold
      & glyphs: (empty_list PositionedGlyph) x: 0
      \ state: (& glyphs: (List PositionedGlyph) x: Int) grapheme: Grapheme ->
        (& glyphs x) = state
        glyph = font .get_or_tofu grapheme
        & glyphs: glyphs .push (& position: (& x y: 0) glyph)
          x: x .+ (glyph.size.width)
  . glyphs

draw_text
  texture: Texture
  text: String
  where: Position
  width: Int
  font: Font
  color: Color
  -> Texture
= text
  . break_into_graphemes
  . layout font width
  . iterate
  . fold
      texture
      \ texture: Texture glyph: PositionedGlyph ->
        texture .draw_glyph (glyph.glyph) (where .+ (glyph.position)) color

draw_glyph texture: Texture glyph: Glyph where: Position color: Color -> Texture
= texture
  . update_area
      where .by (glyph.size)
      \ x: Int y: Int old: Color ->
        glyph .get x y
        % true -> color
          false -> old
