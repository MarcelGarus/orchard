export
  Color
  rgb Byte Byte Byte -> Color
  rgb Int Int Int -> Color
  rgba Byte Byte Byte -> Color
  rgba Int Int Int Int -> Color
  color String -> Color
  blend bottom:Color top:Color -> Color

import ...core

Color = & red: Byte blue: Byte green: Byte alpha: Byte

rgba red: Int green: Int blue: Int alpha: Int -> Color =
  & red: red.to_byte green: green.to_byte blue: blue.to_byte alpha: 255.to_byte

rgb red: Int green: Int blue: Int -> Color = rgba red green blue 255

color hex_string: String -> Color =
  assert (hex_string.utf8_bytes.length .== 7)
  assert (hex_string.utf8_bytes .get 0 .== ("#".utf8_bytes .get 0))
  & red:
      parse_hex_color_component
        hex_string.utf8_bytes .get 1
        hex_string.utf8_bytes .get 2
    green:
      parse_hex_color_component
        hex_string.utf8_bytes .get 3
        hex_string.utf8_bytes .get 4
    blue:
      parse_hex_color_component
        hex_string.utf8_bytes .get 5
        hex_string.utf8_bytes .get 6
    alpha: 255.to_byte

parse_hex_color_component a: Byte b: Byte -> Byte =
  parse_hex_digit a .to_int .<< 4 .+ (parse_hex_digit b .to_int) .lower_byte

parse_hex_digit char: Byte -> Byte =
  ascii_0 = "0".utf8_bytes .get 0
  ascii_9 = "9".utf8_bytes .get 0
  ascii_a = "a".utf8_bytes .get 0
  ascii_f = "f".utf8_bytes .get 0
  char .>= ascii_0 .and (char .<= ascii_9)
  % true -> char .- ascii_0
    false ->
      char .>= ascii_a .and (char .<= ascii_f)
      % true -> char .- ascii_a .+ (10.to_byte)
        false -> crash "invalid hex digit"


blend bottom: Color top: Color -> Color =
  top.alpha.to_int .== 0
  % true -> bottom
    false -> top
