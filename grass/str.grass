# A str of bytes. With two pointer indirections to the data, the memory
# representation is not as efficient as most other languages, but the bottleneck
# for Grass is not the runtime speed, but the complexity of implementing code.
# And it's easier to write code if most variables have the word size.
#
# ┌────────┐
# │ str    │
# └────────┘
#     │
#     v
# ┌────────┬────────┐
# │ ptr    | len    │
# └────────┴────────┘
#     │
#     v
# ┌───────────────────────────────────────────┐
# │ bytes                                     │
# └───────────────────────────────────────────┘

# (ptr len -> str)
@str.make  call ^slots.make_ab  call ^slots.keep_set_b  call ^slots.set_a  return

# (str -> ptr)
@str.ptr  call ^slots.get_a  return

# (str -> len)
@str.len  call ^slots.get_b  return

# (str str -> bool)
@str.==               # a b
 over  call ^str.len  # a b a_len
 over  call ^str.len  # a b a_len b_len
 call ^==             # a b same_len?
 jump_table 02 ^str.==.different_len ^str.==.same_len
@str.==.different_len  # a b
 pop 10  push_byte false  return
@str.==.same_len       # a b
 over   call ^str.ptr  # a b a_ptr
 over   call ^str.ptr  # a b a_ptr b_ptr
 over2  call ^str.len  # a b a_ptr b_ptr len
 push_word _0          # a b a_ptr b_ptr len cursor
@str.==.loop           # a b a_ptr b_ptr len cursor
 over  over  call ^==  # a b a_ptr b_ptr len cursor at_end?
 jump_table 02 ^str.==.compare_bytes ^str.==.done
@str.==.compare_bytes   # a b a_ptr b_ptr len cursor
 over3  over   add      # a b a_ptr b_ptr len cursor a_ptr+cursor
 load_byte byte_to_int  # a b a_ptr b_ptr len cursor a_byte
 over3  over2  add      # a b a_ptr b_ptr len cursor a_byte b_ptr+cursor
 load_byte byte_to_int  # a b a_ptr b_ptr len cursor a_byte b_byte
 call ^==               # a b a_ptr b_ptr len cursor byte_equal?
 jump_table 02 ^str.==.different_bytes ^str.==.same_byte
@str.==.different_bytes  # a b a_ptr b_ptr len cursor
 pop 30                  #
 push_byte 00            # 0
 return
@str.==.same_byte   # a b a_ptr b_ptr len cursor
 push_word _1  add  # a b a_ptr b_ptr len cursor+1
 jump ^str.==.loop
@str.==.done  # a_ptr a_len b_ptr b_len
 pop 20              #
 push_byte 00        # 0
 return

@str.starts_with  # str prefix
 
 TODO

@str.starts_with_byte  # str byte
 TODO

