# The Grass Compiler  
# (written in Grass)
#
# The compiler uses a continuation-passing style to request imported files from
# the surrounding environment. Here's pseudocode on how to use the compiler:
#
# task = 0.run(ptr, len)
# loop {
#   match task {
#     [ptr len ctx cont 00] -> task = cont.run(ctx, read_file(ptr, len))
#     [ptr len _0  _0   01] -> break (ptr, len)
#   }
# }





# Numbers  
# Full-word numbers.

:   0 00 00 00 00 00 00 00 00 ;
:   1 00 00 00 00 00 00 00 01 ;
:   2 00 00 00 00 00 00 00 02 ;
:   4 00 00 00 00 00 00 00 04 ;
:   8 00 00 00 00 00 00 00 08 ;
: _16 00 00 00 00 00 00 00 10 ;
: _24 00 00 00 00 00 00 00 18 ;
: _32 00 00 00 00 00 00 00 20 ;
:  -1 ff ff ff ff ff ff ff ff ;


: . ; # Allows us to use dots for aligning code.

# Instructions  

# mnemonic          opcode    immediates    stack
: nop . . . . . . . . . 00 ;#             |               ->
: add . . . . . . . . . a0 ;#             |       a:8 b:8 -> (a+b):8
: sub . . . . . . . . . a1 ;#             |       a:8 b:8 -> (a-b):8
: mul . . . . . . . . . a2 ;#             |       a:8 b:8 -> (a*b):8
: div . . . . . . . . . a3 ;#             |       a:8 b:8 -> (a/b):8
: mod . . . . . . . . . a4 ;#             |       a:8 b:8 -> (a%b):8
: compare_zero  . . . . a5 ;#             |           a:8 -> ordering:1
: and . . . . . . . . . b0 ;#             |       a:8 b:8 -> (a&b):8
: or  . . . . . . . . . b1 ;#             |       a:8 b:8 -> (a|b):8
: xor . . . . . . . . . b2 ;#             |       a:8 b:8 -> (a^b):8
: lower_byte  . . . . . b3 ;#             |           a:8 -> a:1
: byte_to_word  . . . . b4 ;#             |           a:1 -> a:8
: push_padding  . . . . c0 ;#             |           n:1 -> padding:n
: push_byte . . . . . . c1 ;# a:1         |               -> a:1
: push_word . . . . . . c2 ;# a:8         |               -> a:8
: push_byte_from_stack  c3 ;# offset:8    |               -> byte
: push_word_from_stack  c4 ;# offset:8    |               -> word
: pop . . . . . . . . . c5 ;# amount:1    |      _:amount ->
: pop_below_top . . . . c6 ;# a:8 b:1     |    _:b kept:a -> kept:a
: malloc_word_aligned . d0 ;#             |        size:8 -> ptr:8
: free_word_aligned . . d1 ;#             |  ptr:8 size:8 ->
: store_byte  . . . . . d2 ;#             |     ptr:8 b:1 ->
: store_word  . . . . . d3 ;#             |     ptr:8 w:8 ->
: load_byte . . . . . . d4 ;#             |         ptr:8 -> b:1
: load_word . . . . . . d5 ;#             |         ptr:8 -> w:8
: store_bytes . . . . . d6 ;# len:8 b:len |         ptr:8 ->
: malloc_byte_aligned . d7 ;#             |        size:8 -> ptr:8
: free_byte_aligned . . d8 ;#             |  ptr:8 size:8 ->
: crash . . . . . . . . e0 ;#             |   ptr:8 len:8 -> BANG
: jump  . . . . . . . . f0 ;# target:8    |               ->
: jump_table  . . . . . f1 ;# len:1 targets:8*len | b:1   ->
: call  . . . . . . . . f2 ;# target:8    |               ->
: push_indirect . . . . f3 ;# target:8    |               -> token:8
: call_indirect . . . . f4 ;# pop:1       | _:pop token:8 ->
: return  . . . . . . . f5 ;#             |               ->

: 0w _0 ;
: 1w _8 ;
: 2w _16 ;
: 3w _24 ;
: 4w _32 ;
: 5w _40 ;



: dup   push_word_from_stack 0w ;
: over  push_word_from_stack 1w ;
: over2 push_word_from_stack 2w ;
: over3 push_word_from_stack 3w ;
: over4 push_word_from_stack 4w ;
: over5 push_word_from_stack 5w ;
: pop_over  pop_below_top _8  ;
: pop_over2 pop_below_top _16 ;

jump ^main

# Low-level memory operations.

# Allocates memory and also makes sure that the allocation succeeded.
@safe_malloc_word_aligned  # length
 malloc_word_aligned       # ptr
 dup                       # ptr ptr
 compare_zero              # ptr worked?
 jump_table ^oom ^safe_malloc_word_aligned.yeah ^safe_malloc_word_aligned.yeah
@safe_malloc_word_aligned.yeah  # ptr
 return

# Allocates memory and also makes sure that the allocation succeeded.
@safe_malloc_byte_aligned  # length
 malloc_byte_aligned       # ptr
 dup                       # ptr ptr
 compare_zero              # ptr worked?
 jump_table ^oom ^safe_malloc_byte_aligned.yeah ^safe_malloc_byte_aligned.yeah
@safe_malloc_byte_aligned.yeah  # ptr
 return

# Copies memory from one location to another.
@memcopy       # from to amount
 push_word _0  # from to amount cursor
@memcopy.loop  # from to amount cursor
 over          # from to amount cursor amount
 over2         # from to amount cursor amount cursor
 compare       # from to amount cursor done?
 jump_table 03 ^@memcopy.done ^memcopy.copy_byte ^unreachable
@memcopy.copy_byte  # from to amount cursor
 over2              # from to amount cursor to
 over               # from to amount cursor to cursor
 add                # from to amount cursor to+cursor
 over4              # from to amount cursor to+cursor from
 over2              # from to amount cursor to+cursor from cursor
 add                # from to amount cursor to+cursor from+cursor
 load_byte          # from to amount cursor to+cursor byte
 store_byte         # from to amount cursor
 push_word _1       # from to amount cursor 1
 add                # from to amount cursor+1
 jump ^memcopy.loop
@memcopy.done  # from to amount cursor
 pop 20        #
 return


# Before calling, make sure that len > 0.
@keep_starts_with  # ptr len byte
 byte_to_int       # ptr len byte
 over2             # ptr len byte ptr
 load_byte         # ptr len byte actual_byte
 compare           # ptr len same?
 jump_table 03 ^keep_starts_with.yes ^keep_starts_with.no ^keep_starts_with.no
@keep_starts_with.yes  # ptr len
 push_byte 01          # ptr len 01
 return
@keep_starts_with.no  # ptr len
 push_byte 00         # ptr len 00
 return


# Called when we are out of memory (an allocation failed).
@oom
 TODO

@unreachable
 TODO


# Many data structures have a similar memory layout: Rather than keeping data
# directly on the stack, they enable mutation of a single source of truth by
# allocating fields on the heap and only maintaining a pointer on the stack.
#
# ┌────────┐
# │ slots  │
# └────────┘
#     │
#     v
# ┌────────┬────────┬────────┐
# │ a      | b      | c      │
# └────────┴────────┴────────┘
#
# This file contains utility procedures for allocating such a data structure and
# for loading and storing the slots.

# ( -> slots)
@slots.make_a      push_word _8   call ^safe_malloc_word_aligned  return
@slots.make_ab     push_word _16  call ^safe_malloc_word_aligned  return
@slots.make_abc    push_word _24  call ^safe_malloc_word_aligned  return
@slots.make_abcd   push_word _32  call ^safe_malloc_word_aligned  return
@slots.make_abcde  push_word _40  call ^safe_malloc_word_aligned  return

# (slots -> )
@slots.free_a      push_word _8   free_word_aligned  return
@slots.free_ab     push_word _16  free_word_aligned  return
@slots.free_abc    push_word _24  free_word_aligned  return
@slots.free_abcd   push_word _32  free_word_aligned  return
@slots.free_abcde  push_word _40  free_word_aligned  return

# (slots -> field)
@slots.get_a                      load_word  return
@slots.get_b  push_word _8   add  load_word  return
@slots.get_c  push_word _16  add  load_word  return
@slots.get_d  push_word _24  add  load_word  return
@slots.get_e  push_word _32  add  load_word  return

# (field slots -> )
@slots.set_a                      over  store_word  pop 08  return
@slots.set_b  push_word _8   add  over  store_word  pop 08  return
@slots.set_c  push_word _16  add  over  store_word  pop 08  return
@slots.set_d  push_word _24  add  over  store_word  pop 08  return
@slots.set_e  push_word _32  add  over  store_word  pop 08  return

# (slots -> field slots)
@slots.keep_get_a  dup                      load_word  over  pop_over2 08  return
@slots.keep_get_b  dup  push_word _8   add  load_word  over  pop_over2 08  return
@slots.keep_get_c  dup  push_word _16  add  load_word  over  pop_over2 08  return
@slots.keep_get_d  dup  push_word _24  add  load_word  over  pop_over2 08  return
@slots.keep_get_e  dup  push_word _32  add  load_word  over  pop_over2 08  return

# (field slots -> slots)
@slots.keep_set_a  dup                      over2  store_word  pop_over  return
@slots.keep_set_b  dup  push_word _8   add  over2  store_word  pop_over  return
@slots.keep_set_c  dup  push_word _16  add  over2  store_word  pop_over  return
@slots.keep_set_d  dup  push_word _24  add  over2  store_word  pop_over  return
@slots.keep_set_e  dup  push_word _32  add  over2  store_word  pop_over  return

# A str of bytes. With two pointer indirections to the data, the memory
# representation is not as efficient as most other languages, but the bottleneck
# for Grass is not the runtime speed, but the complexity of implementing code.
# And it's easier to write code if most variables have the word size.
#
# ┌────────┐
# │ str    │
# └────────┘
#     │
#     v
# ┌────────┬────────┐
# │ ptr    | len    │
# └────────┴────────┘
#     │
#     v
# ┌───────────────────────────────────────────┐
# │ bytes                                     │
# └───────────────────────────────────────────┘

# (ptr len -> str)
@str.make  call ^slots.make_ab  call ^slots.keep_set_b  call ^slots.set_a  return

# (str -> ptr)
@str.ptr  call ^slots.get_a  return

# (str -> len)
@str.len  call ^slots.get_b  return

# (str str -> bool)
@str.==               # a b
 over  call ^str.len  # a b a_len
 over  call ^str.len  # a b a_len b_len
 call ^==             # a b same_len?
 jump_table 02 ^str.==.different_len ^str.==.same_len
@str.==.different_len  # a b
 pop 10  push_byte false  return
@str.==.same_len       # a b
 over   call ^str.ptr  # a b a_ptr
 over   call ^str.ptr  # a b a_ptr b_ptr
 over2  call ^str.len  # a b a_ptr b_ptr len
 push_word _0          # a b a_ptr b_ptr len cursor
@str.==.loop           # a b a_ptr b_ptr len cursor
 over  over  call ^==  # a b a_ptr b_ptr len cursor at_end?
 jump_table 02 ^str.==.compare_bytes ^str.==.done
@str.==.compare_bytes   # a b a_ptr b_ptr len cursor
 over3  over   add      # a b a_ptr b_ptr len cursor a_ptr+cursor
 load_byte byte_to_int  # a b a_ptr b_ptr len cursor a_byte
 over3  over2  add      # a b a_ptr b_ptr len cursor a_byte b_ptr+cursor
 load_byte byte_to_int  # a b a_ptr b_ptr len cursor a_byte b_byte
 call ^==               # a b a_ptr b_ptr len cursor byte_equal?
 jump_table 02 ^str.==.different_bytes ^str.==.same_byte
@str.==.different_bytes  # a b a_ptr b_ptr len cursor
 pop 30                  #
 push_byte 00            # 0
 return
@str.==.same_byte   # a b a_ptr b_ptr len cursor
 push_word _1  add  # a b a_ptr b_ptr len cursor+1
 jump ^str.==.loop
@str.==.done  # a_ptr a_len b_ptr b_len
 pop 20              #
 push_byte 00        # 0
 return

@str.starts_with  # str prefix
 
 TODO

@str.starts_with_byte  # str byte
 TODO



# Output  
# An automatically growing output buffer for bytes.
#
# ┌────────┐
# │ output │
# └────────┘
#     │
#     v
# ┌────────┬────────┬────────┐
# │ ptr    | cap    | length │
# └────────┴────────┴────────┘
#     │
#     v
# ┌───────────────────────────────────────────┐
# │ bytes                                     │
# └───────────────────────────────────────────┘

@output.make                     #
 push_word _16                   # 16
 call ^safe_malloc_byte_aligned  # ptr
 push_word _16                   # ptr 16
 push_word _0                    # ptr 16 0
 call ^slots.make_abc            # ptr 16 0 parser
 call ^slots.keep_set_c          # ptr 16 output
 call ^slots.keep_set_b          # ptr output
 call ^slots.keep_set_a          # output
 return

@output.free             # output
 call ^keep_load_a       # ptr output
 call ^keep_load_b       # ptr cap output
 call ^free_slots_a_b_c  # ptr cap
 call free_byte_aligned  #
 return

# Emits a byte into the output.
@emit             # output byte
 push_padding 07   # output byte..
 over              # output byte.. output
 call ^keep_load_b # output byte.. cap output
 call ^load_c      # output byte.. cap length
 compare           # output byte.. full?
 jump_table ^emit.make_bigger ^emit.unchecked ^unreachable
@emit.make_bigger                # output byte..
 over                            # output byte.. output
 call ^keep_load_a               # output byte.. ptr output
 call ^load_b                    # output byte.. ptr cap
 dup                             # output byte.. ptr cap cap
 push_word _2                    # output byte.. ptr cap cap 2
 multiply                        # output byte.. ptr cap new_cap
 dup                             # output byte.. ptr cap new_cap new_cap
 call ^safe_malloc_byte_aligned  # output byte.. ptr cap new_cap new_ptr
 over3                           # output byte.. ptr cap new_cap new_ptr ptr
 over                            # output byte.. ptr cap new_cap new_ptr ptr new_ptr
 over4                           # output byte.. ptr cap new_cap new_ptr ptr new_ptr cap
 call ^memcopy                   # output byte.. ptr cap new_cap new_ptr
 over5                           # output byte.. ptr cap new_cap new_ptr output
 call ^keep_store_a              # output byte.. ptr cap new_cap output
 call ^store_b                   # output byte.. ptr cap
 free_byte_aligned               # output byte..
@emit.unchecked            # output byte..
 over                      # output byte.. output
 call ^keep_load_a         # output byte.. ptr output
 call ^load_c              # output byte.. ptr length
 add                       # output byte.. ptr+length
 push_byte_from_stack _15  # output byte.. ptr+length byte
 store_byte                # output byte..
 pop 08                    # output
 dup                       # output output
 call ^load_c              # output cursor
 push_word _1              # output cursor 1
 add                       # output cursor+1
 over                      # output cursor+1 output
 call ^store_c             # output
 pop 08                    #
 return

# Emits an entire buffer into the output.
@append        # output ptr len
 push_word _0  # output ptr len cursor
@append.loop  # output ptr len cursor
 over         # output ptr len cursor len
 over         # output ptr len cursor len cursor
 compare      # output ptr len cursor at_end?
 jump_table 03 ^append.done ^append.not_done ^unreachable
@append.not_done  # output ptr len cursor
 over3            # output ptr len cursor output
 over3            # output ptr len cursor output ptr
 over2            # output ptr len cursor output ptr cursor
 add              # output ptr len cursor output ptr+cursor
 load_byte        # output ptr len cursor output byte
 call ^emit       # output ptr len cursor
 push_word _1     # output ptr len cursor 1
 add              # output ptr len cursor+1
 jump ^append.loop
@append.done  # output ptr len cursor
 pop 20       #
 return

# Turns an output into a byte array.
@shrink                          # output
 call ^keep_load_a               # ptr output
 call ^keep_load_b               # ptr cap output
 call ^keep_load_c               # ptr cap length output
 call ^free_slots_a_b_c          # ptr cap length
 dup                             # ptr cap length length
 call ^safe_malloc_byte_aligned  # ptr cap length new_ptr
 over3                           # ptr cap length new_ptr ptr
 over                            # ptr cap length new_ptr ptr new_ptr
 over3                           # ptr cap length new_ptr ptr new_ptr length
 call ^memcopy                   # ptr cap length new_ptr
 over                            # ptr cap length new_ptr length
 pop_below_top _16 18            # new_ptr length


# ┌────────┐
# │ dict   │
# └────────┘
#     │
#     v
# ┌────────┬────────┬────────┐
# │ ptr    | cap    | len    │
# └────────┴────────┴────────┘
#     │
#     v
# ┌────────┬────────┬────────┬────────┬────────┐
# │ key    | value  | key    │ value  | ...    |
# └────────┴────────┴────────┴────────┴────────┘

@make_dict  # -> dict
 


@lookup_num  # dict key_ptr key_len -> value_ptr value_len

@lookup_string  # dict key_ptr key_len -> value_ptr value_len

@put_num  # dict key_ptr key_len value ->

@put_string  # dict key_ptr key_len value ->

@free_dict_of_nums

@free_dict_of_strings






@main                  # ptr length
 call ^make_parser     # parser
 push_word _0          # parser parent
 over                  # parser parent parser
 pop_below_top _16 08  # parent parser
 call ^make_output     # parent parser output
 call ^make_dict       # parent parser output words
 TODO: init dict with hex digits
 call ^make_dict       # parent parser output words labels
 jump ^compile

@compile               # parent parser output words labels
 over3                 # parent parser output words labels parser
 call ^next            # parent parser output words labels ptr len
 dup                   # parent parser output words labels ptr len len
 compare_zero          # parent parser output words labels ptr len at_end?
 jump_table 03 ^compile.done ^compile.not_done ^compile.not_done
@compile.not_done  # parent parser output words labels ptr len
 dup               # parent parser output words labels ptr len len
 push_word _1      # parent parser output words labels ptr len len 1
 compare           # parent parser output words labels ptr len is_len_1?
 jump_table 03 ^compile.len_is_1 ^compile.len_not_1 ^unreachable
@compile.len_is_1        # parent parser output words labels ptr len
 push_byte colon         # parent parser output words labels ptr len colon
 call ^keep_starts_with  # parent parser output words labels ptr len colon?
 jump_table 02 ^compile.not_colon ^compile.is_colon
@compile.is_colon  # parent parser output words labels ptr len
 pop 10            # parent parser output words labels
 jump ^word_def
@compile.not_colon       # parent parser output words labels ptr len
 push_byte bang          # parent parser output words labels ptr len bang
 call ^keep_starts_with  # parent parser output words labels ptr len bang?
 jump_table 02 ^word_ref ^compiler.is_bang
@compile.is_bang  # parent parser output words labels ptr len
 pop 10           # parent parser output words labels
 jump ^import
@compile.len_not_1       # parent parser output words labels ptr len
 push_byte at            # parent parser output words labels ptr len at
 call ^keep_starts_with  # parent parser output words labels ptr len at?
 jump_table 02 ^compile.not_label_def ^label_def
@compile.not_label_def   # parent parser output words labels ptr len
 push_byte tick          # parent parser output words labels ptr len tick
 call ^keep_starts_with  # parent parser output words labels ptr len tick?
 jump_table 02 ^word_ref ^label_ref
@compile.done  # parent parser output words labels ptr len
 pop 10        # parent parser output words labels
 over4         # parent parser output words labels parent
 compare_zero  # parent parser output words labels has_parent?
 jump_table 03 ^compile.totally_done ^compile.back_to_parent ^compile.back_to_parent
@compile.back_to_parent  # parent parser output words labels
 pop 20                  # parent
 call ^keep_load_a       # context parent
 call ^keep_load_b       # context parser parent
 call ^keep_load_c       # context parser output parent
 call ^keep_load_d       # context parser output words parent
 call ^load_e            # context parser output words labels
 jump ^compile
@compile.totally_done        # parent parser output words labels
 call ^free_dict_of_nums     # parent parser output words
 call ^free_dict_of_strings  # parent parser output
 over                        # parent parser output parser
 call ^free_parser           # parent parser output
 pop_below_top _8 10         # output
 call ^shrink                # ptr len

# Imports a file. Pack up everything into a context closure that the environment
# will pass on to our continuation.
#
# ┌─────────┐
# │ context │
# └─────────┘
#     │
#     v
# ┌────────┬────────┬────────┬────────┬────────┐
# │ parent | parser | output | words  │ labels |
# └────────┴────────┴────────┴────────┴────────┘
@import                      # parent parser output words labels
 over3                       # parent parser output words labels parser
 call ^next                  # parent parser output words labels ptr len
 over6                       # parent parser output words labels ptr len parent
 over6                       # parent parser output words labels ptr len parent parser
 over6                       # parent parser output words labels ptr len parent parser output
 over6                       # parent parser output words labels ptr len parent parser output words
 over6                       # parent parser output words labels ptr len parent parser output words labels
 pop_below_top _56 28        # ptr len parent parser output words labels
 call ^make_slots_a_b_c_d_e  # ptr len parent parser output words labels context
 call ^keep_store_e          # ptr len parent parser output words context
 call ^keep_store_d          # ptr len parent parser output context
 call ^keep_store_c          # ptr len parent parser context
 call ^keep_store_b          # ptr len parent context
 call ^keep_store_a          # ptr len context
 push_indirect ^import.cont  # ptr len context cont
 push_byte 00                # ptr len context cont 0
 return
@import.cont        # context ptr len
 call ^make_parser  # context parser
 over               # context parser context
 call ^keep_load_c  # context parser output context
 call ^keep_load_d  # context parser output words context
 call ^load_e       # context parser output words labels
 jump ^compile 

# Compiles a definition. The colon and name have already been consumed, we only
# need to parse the actual content up to the semicolon. Note that definitions
# can't contain other definitions, imports, label definitions, or label
# references.
@word_def              # parser output words labels
 over                  # parser output words labels words
 over4                 # parser output words labels words parser
 call ^next            # parser output words labels words ptr len
 over6                 # parser output words labels words ptr len parser
 call ^make_output     # parser output words labels words ptr len parser word_output
 over4                 # parser output words labels words ptr len parser word_output words
 call ^compile_def     # parser output words labels words ptr len def_ptr def_len
 call ^make_slots_a_b  # parser output words labels words ptr len def_ptr def_len entry
 call ^keep_store_b    # parser output words labels words ptr len def_ptr entry
 call ^keep_store_a    # parser output words labels words ptr len entry
 call ^put             # parser output words labels
 jump ^compile

@compile_def   # parser output dict
 over2         # parser output dict parser
 call ^next    # parser output dict word_ptr word_len
 dup           # parser output dict word_ptr word_len word_len
 push_word _1  # parser output dict word_ptr word_len word_len 1
 compare       # parser output dict word_ptr word_len is_len_1?
 jump_table 03 ^compile_def.len_is_1 ^compile_def.not_semicolon ^unreachable
@compile_def.len_is_1  # parser output dict word_ptr word_len
 over                  # parser output dict word_ptr word_len word_ptr
 load_byte             # parser output dict word_ptr word_len byte
 byte_to_int           # parser output dict word_ptr word_len byte
 push_word TODO        # parser output dict word_ptr word_len byte ;
 compare               # parser output dict word_ptr word_len is_semicolon?
 jump_table 03 ^compile_def.is_semicolon ^compile_def.not_semicolon ^compile_def.not_semicolon
@compile_def.not_semicolon  # parser output dict word_ptr word_len
 over3                      # parser output dict word_ptr word_len output
 over3                      # parser output dict word_ptr word_len output dict
 over3                      # parser output dict word_ptr word_len output dict word_ptr
 over3                      # parser output dict word_ptr word_len output dict word_ptr word_len
 call ^lookup_string        # parser output dict word_ptr word_len output def_ptr def_len
 call ^append               # parser output dict word_ptr word_len
 pop 10                     # parser output dict
 jump ^compile_def
@compile_def.is_semicolon  # parser output dict word_ptr word_len
 pop 18                    # parser output
 pop_below_top _8 08       # output
 call ^shrink              # ptr len
 return

@word_ref      # parser output words labels ptr len
 over4         # parser output words labels ptr len output
 over4         # parser output words labels ptr len output words
 over3         # parser output words labels ptr len output words ptr
 over3         # parser output words labels ptr len output words ptr len
 call ^lookup  #


@label_def # parser output words labels ptr len
 TODO

@label_ref # parser output words labels ptr len
 TODO







@hex_to_num   # char


@unreachable
todo


# Parser  
# The parser offers a way to step through bytes (the textual input). It
# maintains a cursor that starts at the beginning. You can ^peek the current
# character, ^advance the cursor by one character, and do higher-level
# operations such as consuming all leading whitespace or consuming a word.
#
# ┌────────┐
# │ parser │
# └────────┘
#     │
#     v
# ┌────────┬────────┬────────┐
# │ ptr    | length | cursor │
# └────────┴────────┴────────┘
#     │
#     v
# ┌───────────────────────────────────────────┐
# │ bytes                                     │
# └───────────────────────────────────────────┘

@make_parser              # ptr length
 push_word _0             # ptr length 0
 call ^alloc_slots_a_b_c  # ptr length 0 parser
 call ^keep_store_c       # ptr length parser
 call ^keep_store_b       # ptr parser
 call ^keep_store_a       # parser
 return

@free_parser             # parser
 dup                     # parser parser
 call ^keep_load_a       # parser ptr parser
 call ^load_b            # parser ptr length
 free_byte_aligned       # parser
 call ^free_slots_a_b_c  #
 return

# Turns a parser into its current character or zero if it's at the end.
@peek                     # parser
 dup                      # parser parser
 call ^keep_load_b        # parser length parser
 call ^load_c             # parser length cursor
 compare                  # parser at_end?
 jump_table 03 ^peek.return_0 ^peek.get_char ^unreachable
@peek.return_0   # parser
 pop 08          #
 push_byte 00    # 0
 return
@peek.get_char      # parser
 call ^keep_load_a  # ptr parser
 call ^load_c       # ptr cursor
 add                # ptr+cursor
 load_byte          # char
 return

# Advances the parser's cursor by one character.
@advance        # parser
 dup            # parser parser
 call ^load_c   # parser cursor
 push_word _1   # parser cursor 1
 add            # parser cursor+1
 over           # parser cursor+1 parser
 call ^store_c  # parser
 pop 08         #
 return
