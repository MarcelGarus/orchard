# The Grass Compiler  
# (written in Grass)
#
# The compiler uses a continuation-passing style to request imported files from
# the surrounding environment. Here's pseudocode on how to use the compiler:
#
# task = 0.run(ptr, len)
# loop {
#   match task {
#     [ptr len ctx cont 00] -> task = cont.run(ctx, read_file(ptr, len))
#     [ptr len _0  _0   01] -> break (ptr, len)
#   }
# }

jump ^main
! core.grass
! memory.grass
! slots.grass
! parser.grass
! output.grass

@main                  # ptr length
 call ^make_parser     # parser
 push_word _0          # parser parent
 over                  # parser parent parser
 pop_below_top _16 08  # parent parser
 call ^make_output     # parent parser output
 call ^make_dict       # parent parser output words
 TODO: init dict with hex digits
 call ^make_dict       # parent parser output words labels
 jump ^compile

@compile               # parent parser output words labels
 over3                 # parent parser output words labels parser
 call ^next            # parent parser output words labels ptr len
 dup                   # parent parser output words labels ptr len len
 compare_zero          # parent parser output words labels ptr len at_end?
 jump_table 03 ^compile.done ^compile.not_done ^compile.not_done
@compile.not_done  # parent parser output words labels ptr len
 dup               # parent parser output words labels ptr len len
 push_word _1      # parent parser output words labels ptr len len 1
 compare           # parent parser output words labels ptr len is_len_1?
 jump_table 03 ^compile.len_is_1 ^compile.len_not_1 ^unreachable
@compile.len_is_1        # parent parser output words labels ptr len
 push_byte colon         # parent parser output words labels ptr len colon
 call ^keep_starts_with  # parent parser output words labels ptr len colon?
 jump_table 02 ^compile.not_colon ^compile.is_colon
@compile.is_colon  # parent parser output words labels ptr len
 pop 10            # parent parser output words labels
 jump ^word_def
@compile.not_colon       # parent parser output words labels ptr len
 push_byte bang          # parent parser output words labels ptr len bang
 call ^keep_starts_with  # parent parser output words labels ptr len bang?
 jump_table 02 ^word_ref ^compiler.is_bang
@compile.is_bang  # parent parser output words labels ptr len
 pop 10           # parent parser output words labels
 jump ^import
@compile.len_not_1       # parent parser output words labels ptr len
 push_byte at            # parent parser output words labels ptr len at
 call ^keep_starts_with  # parent parser output words labels ptr len at?
 jump_table 02 ^compile.not_label_def ^label_def
@compile.not_label_def   # parent parser output words labels ptr len
 push_byte tick          # parent parser output words labels ptr len tick
 call ^keep_starts_with  # parent parser output words labels ptr len tick?
 jump_table 02 ^word_ref ^label_ref
@compile.done  # parent parser output words labels ptr len
 pop 10        # parent parser output words labels
 over4         # parent parser output words labels parent
 compare_zero  # parent parser output words labels has_parent?
 jump_table 03 ^compile.totally_done ^compile.back_to_parent ^compile.back_to_parent
@compile.back_to_parent  # parent parser output words labels
 pop 20                  # parent
 call ^keep_load_a       # context parent
 call ^keep_load_b       # context parser parent
 call ^keep_load_c       # context parser output parent
 call ^keep_load_d       # context parser output words parent
 call ^load_e            # context parser output words labels
 jump ^compile
@compile.totally_done        # parent parser output words labels
 call ^free_dict_of_nums     # parent parser output words
 call ^free_dict_of_strings  # parent parser output
 over                        # parent parser output parser
 call ^free_parser           # parent parser output
 pop_below_top _8 10         # output
 call ^shrink                # ptr len

# Imports a file. Pack up everything into a context closure that the environment
# will pass on to our continuation.
#
# ┌─────────┐
# │ context │
# └─────────┘
#     │
#     v
# ┌────────┬────────┬────────┬────────┬────────┐
# │ parent | parser | output | words  │ labels |
# └────────┴────────┴────────┴────────┴────────┘
@import                      # parent parser output words labels
 over3                       # parent parser output words labels parser
 call ^next                  # parent parser output words labels ptr len
 over6                       # parent parser output words labels ptr len parent
 over6                       # parent parser output words labels ptr len parent parser
 over6                       # parent parser output words labels ptr len parent parser output
 over6                       # parent parser output words labels ptr len parent parser output words
 over6                       # parent parser output words labels ptr len parent parser output words labels
 pop_below_top _56 28        # ptr len parent parser output words labels
 call ^make_slots_a_b_c_d_e  # ptr len parent parser output words labels context
 call ^keep_store_e          # ptr len parent parser output words context
 call ^keep_store_d          # ptr len parent parser output context
 call ^keep_store_c          # ptr len parent parser context
 call ^keep_store_b          # ptr len parent context
 call ^keep_store_a          # ptr len context
 push_indirect ^import.cont  # ptr len context cont
 push_byte 00                # ptr len context cont 0
 return
@import.cont        # context ptr len
 call ^make_parser  # context parser
 over               # context parser context
 call ^keep_load_c  # context parser output context
 call ^keep_load_d  # context parser output words context
 call ^load_e       # context parser output words labels
 jump ^compile 

# Compiles a definition. The colon and name have already been consumed, we only
# need to parse the actual content up to the semicolon. Note that definitions
# can't contain other definitions, imports, label definitions, or label
# references.
@word_def              # parser output words labels
 over                  # parser output words labels words
 over4                 # parser output words labels words parser
 call ^next            # parser output words labels words ptr len
 over6                 # parser output words labels words ptr len parser
 call ^make_output     # parser output words labels words ptr len parser word_output
 over4                 # parser output words labels words ptr len parser word_output words
 call ^compile_def     # parser output words labels words ptr len def_ptr def_len
 call ^make_slots_a_b  # parser output words labels words ptr len def_ptr def_len entry
 call ^keep_store_b    # parser output words labels words ptr len def_ptr entry
 call ^keep_store_a    # parser output words labels words ptr len entry
 call ^put             # parser output words labels
 jump ^compile

@compile_def   # parser output dict
 over2         # parser output dict parser
 call ^next    # parser output dict word_ptr word_len
 dup           # parser output dict word_ptr word_len word_len
 push_word _1  # parser output dict word_ptr word_len word_len 1
 compare       # parser output dict word_ptr word_len is_len_1?
 jump_table 03 ^compile_def.len_is_1 ^compile_def.not_semicolon ^unreachable
@compile_def.len_is_1  # parser output dict word_ptr word_len
 over                  # parser output dict word_ptr word_len word_ptr
 load_byte             # parser output dict word_ptr word_len byte
 byte_to_int           # parser output dict word_ptr word_len byte
 push_word TODO        # parser output dict word_ptr word_len byte ;
 compare               # parser output dict word_ptr word_len is_semicolon?
 jump_table 03 ^compile_def.is_semicolon ^compile_def.not_semicolon ^compile_def.not_semicolon
@compile_def.not_semicolon  # parser output dict word_ptr word_len
 over3                      # parser output dict word_ptr word_len output
 over3                      # parser output dict word_ptr word_len output dict
 over3                      # parser output dict word_ptr word_len output dict word_ptr
 over3                      # parser output dict word_ptr word_len output dict word_ptr word_len
 call ^lookup_string        # parser output dict word_ptr word_len output def_ptr def_len
 call ^append               # parser output dict word_ptr word_len
 pop 10                     # parser output dict
 jump ^compile_def
@compile_def.is_semicolon  # parser output dict word_ptr word_len
 pop 18                    # parser output
 pop_below_top _8 08       # output
 call ^shrink              # ptr len
 return

@word_ref      # parser output words labels ptr len
 over4         # parser output words labels ptr len output
 over4         # parser output words labels ptr len output words
 over3         # parser output words labels ptr len output words ptr
 over3         # parser output words labels ptr len output words ptr len
 call ^lookup  #


@label_def # parser output words labels ptr len
 TODO

@label_ref # parser output words labels ptr len
 TODO







@hex_to_num   # char


@unreachable
todo
