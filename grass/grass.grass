## The Grass Compiler
#
# This file contains a compiler for Grass, written in Grass. Use it like this:
#
# input stack:   pointer length  (this should point to Grass source code)
# output stack:  pointer length  (this points to compiled Ground code)
#
# The compiler allocates new memory for the output, but it does not free the
# input.

## A Refresher on Grass
#
# Grass stands for Ground assembly (because I use it to write Ground byte code),
# but really it's encoding agnostic. The compiler just goes through the file
# and turns names into bytes. It's somewhat similar to Forth, but also not
# really.
#
# - The 255 names "00" to "ff" are predefined, each stands for a single byte.
# - You can define new names using:
#   - A colon (:) to start a definition.
#   - The name to be defined.
#   - The names that make up the definition (forward references allowed, but
#     please avoid cycles).
#   - A semicolon (;) to end the definition.
# - You can use @label in the top-level scope (not inside a definition) to
#   define a label. Every reference ^label (allowed in definitions) then gets
#   replaced by the absolute offset of the corresponding label (64-bits, little
#   endian encoded).

jump ^main

: . ; # Allows me to use dots for aligning code, like on a restaurant menu.

## Instructions
#
# I don't want to have to remember the opcodes, so here are aliases/mnemonics.

# mnemonic          opcode    immediates    data stack
: nop . . . . . . . . . 00 ;#             |               ->
: add . . . . . . . . . a0 ;#             |       a:8 b:8 -> (a+b):8
: subtract  . . . . . . a1 ;#             |       a:8 b:8 -> (a-b):8
: multiply  . . . . . . a2 ;#             |       a:8 b:8 -> (a*b):8
: divide  . . . . . . . a3 ;#             |       a:8 b:8 -> (a/b):8
: modulo  . . . . . . . a4 ;#             |       a:8 b:8 -> (a%b):8
: compare_zero  . . . . a5 ;#             |           a:8 -> ordering:1
: and . . . . . . . . . b0 ;#             |       a:8 b:8 -> (a&b):8
: or  . . . . . . . . . b1 ;#             |       a:8 b:8 -> (a|b):8
: xor . . . . . . . . . b2 ;#             |       a:8 b:8 -> (a^b):8
: lower_byte  . . . . . b3 ;#             |           a:8 -> a:1
: byte_to_word  . . . . b4 ;#             |           a:1 -> a:8
: push_padding  . . . . c0 ;#             |           n:1 -> _:n
: push_byte . . . . . . c1 ;# a:1         |               -> a:1
: push_word . . . . . . c2 ;# a:8         |               -> a:8
: push_byte_from_stack  c3 ;# offset:8    |               -> byte:1
: push_word_from_stack  c4 ;# offset:8    |               -> word:8
: pop . . . . . . . . . c5 ;# amount:1    |      _:amount ->
: pop_below_top . . . . c6 ;# a:8 b:1     |    _:b kept:a -> kept:a
: malloc_word_aligned . d0 ;#             |        size:8 -> ptr:8
: free_word_aligned . . d1 ;#             |  ptr:8 size:8 ->
: store_byte  . . . . . d2 ;#             |     ptr:8 b:1 ->
: store_word  . . . . . d3 ;#             |     ptr:8 w:8 ->
: load_byte . . . . . . d4 ;#             |         ptr:8 -> b:1
: load_word . . . . . . d5 ;#             |         ptr:8 -> w:8
: store_bytes . . . . . d6 ;# len:8 b:len |         ptr:8 ->
: malloc_byte_aligned . d7 ;#             |        size:8 -> ptr:8
: free_byte_aligned . . d8 ;#             |  ptr:8 size:8 ->
: crash . . . . . . . . e0 ;#             |   ptr:8 len:8 -> CRASH
: jump  . . . . . . . . f0 ;# target:8    |               ->
: jump_table  . . . . . f1 ;# len:1 targets:8*len |   b:1 ->
: call  . . . . . . . . f2 ;# target:8    |               ->
: push_indirect . . . . f3 ;# target:8    |               -> fun:8
: call_indirect . . . . f4 ;# pop:1       |   _:pop fun:8 ->
: return  . . . . . . . f5 ;#             |               ->

## Decimal Words
#
# Next, Ground requires little-endian word literals in some places. Writing
# those by hand is tedious, so I did it only once here and re-use those below.

: dec_0   00 00 00 00 00 00 00 00 ;
: dec_1   01 00 00 00 00 00 00 00 ;
: dec_2   02 00 00 00 00 00 00 00 ;
: dec_3   03 00 00 00 00 00 00 00 ;
: dec_4   04 00 00 00 00 00 00 00 ;
: dec_8   08 00 00 00 00 00 00 00 ;
: dec_16  10 00 00 00 00 00 00 00 ;
: dec_24  18 00 00 00 00 00 00 00 ;
: dec_32  20 00 00 00 00 00 00 00 ;
: dec_40  28 00 00 00 00 00 00 00 ;
: dec_-1  ff ff ff ff ff ff ff ff ;

## Character and String Constants
#
# Grass is _very_ minimal and doesn't even have string literals. Unlike all
# those developers writing code with their high-level fancy-pants assemblers,
# _real developers_ obviously first define their ASCII literals and string
# constants by hand.

# Todo: Rethink life choices.
: 'm TODO ;
: 'n TODO ;
: 'o TODO ;
: store_"oom"  store_bytes dec_3 'o 'o 'm ;
: store_"unreachable"  store_bytes dec_11 'u 'n 'r 'e 'a 'c 'h 'a 'b 'l 'e ;

## Higher Level Instructions
#
# Writing a lot of low-level stuff is cumbersome. Take this piece of assembly:
#
# push_word dec_2
# push_word dec_3
# add
#
# In order to keep my sanity, I try to get to the feeling of stack-based /
# concatenative programming languages such as Forth. In Forth, you can write
# code like this:
#
# 2 3 +
#
# My plan to get a Forth-like feel in here and to keep my sanity:
#
# - I define number literals that push their value to the stack. To avoid
#   confusion with the predefined byte literals, I use an underscore prefix.
# - I use short names and symbols for operations, like "+" instead of "add".
# - I define lots of little helper functions such as "dup", "swap", etc. that
#   make stack manipulation bearable.
# - All items on the stack are one word (8 bytes) in size, including bools,
#   chars, and strings. Operations are phrased in word-amounts: Instead of
#   "push_word_from_stack dec_16", I write "over2".
# - I avoid postfix arguments whenever possible. Instead of "pop 08", I define
#   "pop1". This allows me to visually parse names as a unit. The only situation
#   where this is not possible is for operations that expect labels, like
#   "if".
# - I use multiple operations on the same row, but I separate them with two
#   spaces to make the distinction between arguments and operations clear.
# - I define names for operations, even if those just do "call ^operation".
# - I document the stack effect of defined operations in parentheses. For
#   example, swap has the effect (a b -> b a).
# - Sometimes I document the current state of the stack in comments.

: _0          push_word dec_0 ;# ( -> 0)
: _1          push_word dec_1 ;# ( -> 1)
: _3          push_word dec_3 ;# ( -> 3)
: true        push_word dec_1 ;# ( -> bool)
: false       push_word dec_0 ;# ( -> bool)
: dup         push_word_from_stack dec_0  ;#           (a -> a a)
: over        push_word_from_stack dec_8  ;#         (a b -> a b a)
: over2       push_word_from_stack dec_16 ;#       (a b c -> a b c a)
: over3       push_word_from_stack dec_24 ;#     (a b c d -> a b c d a)
: over4       push_word_from_stack dec_32 ;#   (a b c d e -> a b c d e a)
: over5       push_word_from_stack dec_40 ;# (a b c d e f -> a b c d e f a)
: keep1_pop1  pop_below_top dec_8 08 ;#              (a b -> b)
: keep1_pop2  pop_below_top dec_8 10 ;#            (a b c -> c)
: keep2_pop1  pop_below_top dec_16 08 ;#           (a b c -> b c)
: keep2_pop2  pop_below_top dec_16 10 ;#         (a b c d -> c d)
: swap        over keep1_pop1 ;#                     (a b -> b a)
: +           add ;#         (int int -> int)
: -           subtract ;#    (int int -> int)
: *           multiply ;#    (int int -> int)
: /           divide ;#      (int int -> int)
: +1          _1  + ;#           (int -> int)
: *2          _1  << ;#          (int -> int)
: <<          shift_left ;#  (int int -> int)
: >>          shift_right ;# (int int -> int)
: compare     sub  compare_zero  byte_to_int ;# (a b -> ord)
: not         _1  swap  - ;# (bool -> bool)
: !=          compare  _3  over  shift_right  _1  and  lower_byte ;
: ==          !=  not ;
: 0?          0 == ;# (int -> bool)
: space?      push_byte 'space      byte_to_int  == ;# (word -> bool)
: newline?    push_byte 'newline    byte_to_int  == ;# (word -> bool)
: colon?      push_byte 'colon      byte_to_int  == ;# (word -> bool)
: semicolon?  push_byte 'semicolon  byte_to_int  == ;# (word -> bool)
: if          # CAREFUL: Needs postfix targets: bool if ^then ^else
              not  if_not ;
: if_not      # CAREFUL: Needs postfix targets: bool if_not ^then ^else
              jump_table 02 ;
: safe_malloc  # (size -> ptr)
              call ^safe_malloc ;
              @safe_malloc       malloc_word_aligned
                                 dup  0?  if ^safe_malloc.oom ^safe_malloc.yeah
              @safe_malloc.yeah  return
              @safe_malloc.oom   _3  malloc_byte_aligned  # allocate for "oom"
                                 dup  if_zero ^safe_malloc.shit ^safe_malloc.meh
              @safe_malloc.shit  _0  _0  crash  # not even three bytes :(
              @safe_malloc.meh   dup  store_bytes _3 "oom"  _3  crash
: safe_free   free_word_aligned ;# (ptr ->)
              # Just for symmetry with safe_malloc; freeing is always safe.
: load_byte_as_word   load_byte  byte_to_int ;# (ptr -> word)
: store_word_as_byte  lower_byte  store_byte ;# (ptr byte -> )
: unreachable  call ^unreachable ;
              @unreachable
               _11  safe_malloc_byte_aligned  dup
               store_"unreachable"  _11  crash
: memcopy     # (from to amount ->)
              call ^memcopy ;
              @memcopy       _0
              @memcopy.loop  over  over  ==  if ^@memcopy.done ^memcopy.copy
              @memcopy.copy  over2  over  +  over4  over2  +
                             load_byte  store_byte  +1  jump ^memcopy.loop
              @memcopy.done  pop4  return

## Tuples
#
# Because the bottleneck for my Grass projects is not execution speed, but
# implementation complexity, I'm not afraid of pointer indirections: Rather than
# keeping data directly on the stack, most data structures have a heap-allocated
# single source of truth and only keep pointers on the stack.
#
# ( tuple )
#   │
#   v
# ( a | b | c )

: make_a      TODO _8   safe_malloc ;#         (a -> tuple)
: make_ab     TODO _16  safe_malloc ;#         (a b -> tuple)
: make_abc    TODO _24  safe_malloc ;#         (a b c -> tuple)
: make_abcd   TODO _32  safe_malloc ;#         (a b c d -> tuple)
: make_abcde  TODO _40  safe_malloc ;#         (a b c d e -> tuple)
: free_a      _8   safe_free ;#      (tuple -> )
: free_ab     _16  safe_free ;#      (tuple -> )
: free_abc    _24  safe_free ;#      (tuple -> )
: free_abcd   _32  safe_free ;#      (tuple -> )
: free_abcde  _40  safe_free ;#      (tuple -> )
: a           load_word ;#           (tuple -> field)
: b           _8   +  load_word ;# (tuple -> field)
: c           _16  +  load_word ;# (tuple -> field)
: d           _24  +  load_word ;# (tuple -> field)
: e           _32  +  load_word ;# (tuple -> field)
: a=          store_word ;#                           (tuple field -> )
: b=          over  _8   +  over  store_word  pop2 ;# (tuple field -> )
: c=          over  _16  +  over  store_word  pop2 ;# (tuple field -> )
: d=          over  _24  +  over  store_word  pop2 ;# (tuple field -> )
: e=          over  _32  +  over  store_word  pop2 ;# (tuple field -> )

# Some of my data structures have a ptr (pointer), len (length), and
# and cap (capacity). I use the same memory layout for those: (ptr | len | cap).
# This allows me to reuse these common getters and setters.

: ptr     a ;
: len     b ;
: cap     c ;
: ptr     a= ;
: len     b= ;
: cap     c= ;
: empty?  len  0? ;

## Str
#
# ( str )
#    |
#    v
# ( ptr | len )
#    |
#    v
# ( bytes )

: make_str make_ab ;# (ptr len -> str)
: free_str free_ab ;# (str ->)  Note that this does not free the buffer.
: str==  # (str str -> bool)
         call ^se ;
         @se             over  len  over  len  ==  if ^se.len_same ^se.len_diff
         @se.len_diff    pop2  false  return
         @se.len_same    over  ptr  over  ptr  over2  len  keep3_pop2  _0
         @se.loop        # a_ptr b_ptr len cursor
                         over  over  ==  if ^se.done ^se.cmp_bytes
         @se.cmp_bytes   over3  over   +  load_byte_as_word
                         over3  over2  +  load_byte_as_word
                         ==  if ^se.bytes_same ^se.bytes_diff
         @se.bytes_same  +1  jump ^se.loop
         @se.bytes_diff  pop4  false  return
         @se.done        pop4  true   return
: starts_with  # (str str -> bool)
               # We backup the length of the first str on the stack, temporarily
               # give it the length of the second str, and then do a str==.
               call ^sw ;
               @sw                over  len  over  len  <
                                  if ^sw.prefix_longer ^sw.doit
               @sw.prefix_longer  pop2  false  return
               @sw.do_it          over  len  over2  over2  len  len=
                                  over2  over2  # a b a_len a b
                                  str==  byte_to_int  # a b a_len res
                                  over3  over2  len=  keep1_pop3
                                  lower_byte  return
: starts_with_byte  # (str byte -> bool)
                    call ^swb ;
                    @swb            byte_to_int  over  len  0?
                                    if ^swb.empty ^swb.not_empty
                    @swb.empty      pop2  false  return
                    @swb.not_empty  over  ptr  load_byte_as_word  ==
                                    pop_below_top 08 dec_1
: first_char ;
: trim_first  dup  ptr  +1  ptr= ;# (str -> )

## List
#
# An automatically growing buffer of words.
#
# ( list )
#    │
#    v
# ( ptr | len | cap )
#    │
#    v
# ( bytes )

: make_list  _16  safe_malloc  _2  _0  make_abc ;# ( -> list)
: free_list  dup  ptr  over  cap  safe_free  free_abc ;# (list -> )
: push       # (list word -> )
             call ^push ;
             @push       over  len  over2  cap  ==  if ^push.grow ^push.push
             @push.grow  over  ptr  over2  cap  # list word ptr cap
                         dup  *2            # list word ptr cap new_cap
                         dup  safe_malloc   # list word ptr cap new_cap new_ptr
                         over3  over  over4  memcopy
                         over5  # list word ptr cap new_cap new_ptr list
                         dup  over2  ptr=
                         dup  over3  cap=
                         pop3  safe_free           # list word
             @push.push  over  ptr  over2  len  +  # list word ptr+len
                         over  store_word          # list word
                         pop1  dup  len  +1  len=  return
: get        # (list index -> item)
             _8  *  over  ptr  +  load_word  keep1_pop1 ;

## Out
#
# An automatically growing buffer for bytes.
#
# ( out )
#    │
#    v
# ( ptr | cap | len )
#    │
#    v
# ( bytes )

: make_out  _16  safe_malloc  _16  _0  make_abc ;# (-> out)
: free_out  dup  ptr  over  cap  safe_free  free_abc ;# (out ->)
: emit      # (out byte -> )
            call ^emit ;
            @emit       byte_to_int  over  cap  over2  len  ==
                        if ^emit.grow ^emit.push
            @emit.grow  over  ptr  over2  cap  # out byte ptr cap
                        dup  *2               # out byte ptr cap new_cap
                        dup  safe_malloc      # out byte ptr cap new_cap new_ptr
                        over3  over  over4  memcopy
                        over5  # out byte ptr cap new_cap new_ptr out
                        dup  over2  ptr=
                        dup  over3  cap=
                        pop3  safe_free               # out byte
            @emit.push  over  ptr  over2  len  +      # out byte ptr+len
                        over  lower_byte  store_byte  # out byte
                        pop1  dup  len  +1  len=  return
: append    # (out str -> )
            call ^append ;
            @append           dup  ptr  over  len  keep2_pop1  _0
            @append.loop      # out ptr len cursor
                              over  over  ==  if ^append.done ^append.not_done
            @append.done      pop4 return
            @append.not_done  over3  over3  over2  # out ptr len cursor out ptr cursor
                              +  load_byte  emit   # out ptr len cursor
                              +1  jump ^append.loop
: shrink    # (out -> str)
            dup  ptr  swap  dup  cap  swap  dup  len  swap  # ptr cap len out
            free_abc                     # ptr cap len
            dup  safe_malloc             # ptr cap len new_ptr
            over3  over  over3  memcopy  # ptr cap len new_ptr
            over3  over3  safe_free      # ptr cap len new_ptr
            over  keep2_pop3  make_str  return

## Dictionary
#
# A dictionary from strings to words. Uses a linear search for lookup.
# The capacity and length are stored as the number of entries.
#
# ( dict )
#   │
#   v
# ( list ) where items are key, value, key, value, ...

: make_dict  _16  safe_malloc  _1  _0  make_abc ;# ( -> dict)
: free_dict  dup  ptr  over  cap  _16  *  safe_free  free_abc ;# (dict -> )
: put       # (dict str word -> )
            call ^put ; @put  over2  over2  push  keep1_pop1  push  return
: lookup    #      (dict str -> ...)
            # if found: (... -> value true)
            # if not:   (... -> false)
            call ^lookup ;
            @lookup       _0
            @lookup.loop  # dict str index
                          dup  *2  over3  len  ==  if ^lookup.nope ^lookup.check
            @lookup.check # dict str index
                          over2  over  *2  get  over2  str==
                          if ^lookup.found ^lookup.next
            @lookup.next  # dict str index
                          +1  jump ^lookup.loop
            @lookup.found # dict str index
                          keep1_pop1  *2  +1  get  true  return
            @lookup.nope  # dict str index
                          pop3  false  return

## Tokenization
#
# The first step to compiling Grass is to convert the giant string into a list
# of names. At this point, ":" and ";" as well as labels and references are also
# considered names. At the end of the list, we add an empty name that marks the
# end of the file.

: tok # (str -> tokens)
      call ^tok ;
      @tok                  clone_str  make_list
      @tok.loop             # str defs
                            over  empty?  if ^tok.done ^tok.skip_whitespace
      @tok.skip_whitespace  over  first_char  byte_to_int
                            dup  octothorpe?  if ^tok.comment  ^tok.not_comment
      @tok.comment          over  trim_first  over  first_char  byte_to_int
                            newline?  if ^tok.loop ^tok.comment
      @tok.not_comment      dup  space?  swap  newline?  or
                            if ^tok.whitespace ^tok.not_whitespace
      @tok.whitespace       over  trim_first jump ^tok.loop
      @tok.name             # str defs
                            over  ptr
      @tok.name.loop        # str defs start
                            over2  empty?  if ^tok.name.done ^tok.name.check
      @tok.name.check       over2  first_char  byte_to_int
                            dup  space?  swap  dup  newline?  swap  octothorpe?
                            or  or  if ^tok.name.done ^tok.name.more
      @tok.name.more        # str defs start
                            over2  trim_first  jump ^tok.name.loop
      @tok.name.done        # str defs start
                            over2  ptr  over  subtract  make_str # str defs name
                            over  over  push  pop1  jump ^tok.loop
      @tok.done             # str defs
                            over  free_str  keep1_pop1  return

## Inspecting Tokens

: eoi?    len  0? ;# (str -> bool) checks for end of input
: def?    # (str -> bool)
          call ^def? ;
          @def?        dup  len  _1  ==  if ^def?.len_1 ^def?.nope
          @def?.len_1  ptr  load_byte_as_word  semicolon?  return
          @def?.nope   pop1  false  return
: eod?    # (str -> bool) checks for end of definition
          call ^eod? ;
          @eod?        dup  len  _1  ==  if ^eod?.len_1 ^eod?.nope
          @eod?.len_1  ptr  load_byte_as_word  colon?  return
          @eod?.nope   pop1  false  return
: label?  # (str -> bool)
          call ^is_label ;
          @is_label  ptr  load_byte_as_word  at?  return
: ref?    # (str -> bool)
          call ^is_ref ;
          @is_ref  ptr  load_byte_as_word  tick?  return

## Gathering Definitions
#
# In order to allow forward-definitions, we first collect all definitions into a
# dictionary. The keys of the dictionary are the names, the values the indices
# into the list of tokens.

: defs  # (tokens -> defs)
  call ^defs ;
  @defs            make_dict  _0
  @defs.loop       # tokens dict cursor
                   over2  over  get  eoi?  if ^defs.done ^defs.0
  @defs.0          over2  over  get  eod?  if ^error.top_level_eod ^defs.1
  @defs.1          over2  over  get  def?  if ^defs.def ^defs.no_def
  @defs.no_def     +1  jump ^defs.loop
  @defs.def        +1
                   over2  over  get  eod?  if ^error.def_imm_eod ^defs.2
  @defs.2          over2  over  get  eoi?  if ^error.def_imm_eoi ^defs.3
  @defs.3          over  over3  over2  get  over2  put
  @defs.def.loop   # tokens dict cursor
                   +1  over2  over  get  eoi?
                   if ^error.def_does_not_end ^defs.4
  @defs.4          over2  over  get  eod?  if ^defs.loop ^defs.done
  @defs.def.done   +1  jump ^defs.loop
  @defs.done       pop1  keep1_pop1  return

## Compiling Code

: compile  # (tokens defs out patches cursor -> )
  call ^comp ;
  @comp   TODO

@main  # ptr len
 make_str  dup  tok  dup  defs  # str tokens defs
 make_out  make_list  _0  # str tokens defs out patches cursor
 compile
