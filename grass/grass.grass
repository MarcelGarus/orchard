## The Grass Compiler
#
# This file contains a compiler for Grass, written in Grass. Use it like this:
#
# input stack:   pointer length  (this should point to Grass source code)
# output stack:  pointer length  (this points to compiled Ground code)
#
# The compiler allocates new memory for the output, but it does not free the
# input.

## A Refresher on Grass
#
# Grass stands for Ground assembly (because I use it to write Ground byte code),
# but really it's encoding agnostic. The compiler just goes through the file
# and turns words into bytes. It's somewhat similar to Forth, but also not
# really.
#
# - The words 00 to ff are predefined, each stands for a single byte.
# - You can define new words using:
#   - A colon (:) to start a definition.
#   - The word to be defined.
#   - The words that make up the definition (forward references allowed).
#   - A semicolon (;) to end the definition.
# - You can use @label in the top-level scope (not inside a definition) to
#   define a label. Every reference ^label then gets replaced by the absolute
#   offset of the corresponding label (64-bits, little endian encoded).

jump ^main

: . ; # Allows me to use dots for aligning code, like on a restaurant menu.

## Instructions
#
# I don't want to have to remember the opcodes, so here are aliases/mnemonics.

# mnemonic          opcode    immediates    data stack
: nop . . . . . . . . . 00 ;#             |               ->
: add . . . . . . . . . a0 ;#             |       a:8 b:8 -> (a+b):8
: subtract  . . . . . . a1 ;#             |       a:8 b:8 -> (a-b):8
: multiply  . . . . . . a2 ;#             |       a:8 b:8 -> (a*b):8
: divide  . . . . . . . a3 ;#             |       a:8 b:8 -> (a/b):8
: modulo  . . . . . . . a4 ;#             |       a:8 b:8 -> (a%b):8
: compare_zero  . . . . a5 ;#             |           a:8 -> ordering:1
: and . . . . . . . . . b0 ;#             |       a:8 b:8 -> (a&b):8
: or  . . . . . . . . . b1 ;#             |       a:8 b:8 -> (a|b):8
: xor . . . . . . . . . b2 ;#             |       a:8 b:8 -> (a^b):8
: lower_byte  . . . . . b3 ;#             |           a:8 -> a:1
: byte_to_word  . . . . b4 ;#             |           a:1 -> a:8
: push_padding  . . . . c0 ;#             |           n:1 -> _:n
: push_byte . . . . . . c1 ;# a:1         |               -> a:1
: push_word . . . . . . c2 ;# a:8         |               -> a:8
: push_byte_from_stack  c3 ;# offset:8    |               -> byte:1
: push_word_from_stack  c4 ;# offset:8    |               -> word:8
: pop . . . . . . . . . c5 ;# amount:1    |      _:amount ->
: pop_below_top . . . . c6 ;# a:8 b:1     |    _:b kept:a -> kept:a
: malloc_word_aligned . d0 ;#             |        size:8 -> ptr:8
: free_word_aligned . . d1 ;#             |  ptr:8 size:8 ->
: store_byte  . . . . . d2 ;#             |     ptr:8 b:1 ->
: store_word  . . . . . d3 ;#             |     ptr:8 w:8 ->
: load_byte . . . . . . d4 ;#             |         ptr:8 -> b:1
: load_word . . . . . . d5 ;#             |         ptr:8 -> w:8
: store_bytes . . . . . d6 ;# len:8 b:len |         ptr:8 ->
: malloc_byte_aligned . d7 ;#             |        size:8 -> ptr:8
: free_byte_aligned . . d8 ;#             |  ptr:8 size:8 ->
: crash . . . . . . . . e0 ;#             |   ptr:8 len:8 -> CRASH
: jump  . . . . . . . . f0 ;# target:8    |               ->
: jump_table  . . . . . f1 ;# len:1 targets:8*len |   b:1 ->
: call  . . . . . . . . f2 ;# target:8    |               ->
: push_indirect . . . . f3 ;# target:8    |               -> fun:8
: call_indirect . . . . f4 ;# pop:1       |   _:pop fun:8 ->
: return  . . . . . . . f5 ;#             |               ->

## Decimal Words
#
# Next, Ground requires little-endian word literals in some places. Writing
# those by hand is tedious, so I did it only once here and re-use those below.

: dec_0   00 00 00 00 00 00 00 00 ;
: dec_1   00 00 00 00 00 00 00 01 ;
: dec_2   00 00 00 00 00 00 00 02 ;
: dec_3   00 00 00 00 00 00 00 03 ;
: dec_4   00 00 00 00 00 00 00 04 ;
: dec_8   00 00 00 00 00 00 00 08 ;
: dec_16  00 00 00 00 00 00 00 10 ;
: dec_24  00 00 00 00 00 00 00 18 ;
: dec_32  00 00 00 00 00 00 00 20 ;
: dec_40  00 00 00 00 00 00 00 28 ;
: dec_-1  ff ff ff ff ff ff ff ff ;

## Character and String Constants
#
# Grass is _very_ minimal and doesn't even have string literals. Unlike all
# those developers writing code with their high-level fancy-pants assemblers,
# _real developers_ obviously first define their ASCII literals and string
# constants by hand.

# Todo: Rethink life choices.
: 'm TODO ;
: 'n TODO ;
: 'o TODO ;
: "oom" 'o 'o 'm ;# length 3
: "unreachable" 'u 'n 'r 'e 'a 'c 'h 'a 'b 'l 'e ;# length 11

## Higher Level Instructions
#
# Some stack operations are quite common, such as pushing words from a bit
# further back on the stack. Here, we define some operations that help
# manipulate the stack more easily.

: _0          push_word dec_0 ; # (-> 0)
: _1          push_word dec_1 ; # (-> 1)
: _3          push_word dec_3 ; # (-> 3)
: dup         push_word_from_stack dec_0  ;#           (a -> a a)
: over        push_word_from_stack dec_8  ;#         (a b -> a b a)
: over2       push_word_from_stack dec_16 ;#       (a b c -> a b c a)
: over3       push_word_from_stack dec_24 ;#     (a b c d -> a b c d a)
: over4       push_word_from_stack dec_32 ;#   (a b c d e -> a b c d e a)
: over5       push_word_from_stack dec_40 ;# (a b c d e f -> a b c d e f a)
: keep1_pop1  pop_below_top dec_8 08 ;#              (a b -> b)
: keep1_pop2  pop_below_top dec_8 10 ;#            (a b c -> c)
: keep2_pop1  pop_below_top dec_16 08 ;#           (a b c -> b c)
: keep2_pop2  pop_below_top dec_16 10 ;#         (a b c d -> c d)
: swap        over keep1_pop1 ;#                     (a b -> b a)
: inc         _1  add ;# (c -> c+1)
: compare     sub compare_zero ;# (a b -> ord)
: negate      # (bool -> bool)
              call ^negate ;
              @negate jump_table 02 ^negate.true ^negate.false
              @negate.true   false  return
              @negate.false  true   return
: ord_neq     # (ord -> bool)
              byte_to_int  _3  over  shift_right  _1  and  lower_byte ;
: if_not      # CAREFUL: Needs postfix targets: bool if ^then ^else
              jump_table 02 ;
: if_ord_eq   # CAREFUL: Needs postfix targets: ord if_zero ^then ^else
              ord_neq  if_not ;
: if_zero     # CAREFUL: Needs postfix targets: num if_zero ^then ^else
              compare_zero  if_ord_eq ;
: if_eq       # CAREFUL: Needs postfix targets: a if_eq ^then ^else
              compare  if_ord_eq ;
: if          # CAREFUL: Needs postfix targets: bool if ^then ^else
              negate  jump_table 02 ;
: safe_malloc  # (size -> ptr)
              call ^safe_malloc ;
              @safe_malloc       malloc_word_aligned
                                 dup  if_zero ^safe_malloc.oom ^safe_malloc.yeah
              @safe_malloc.yeah  return
              @safe_malloc.oom   _3  malloc_byte_aligned  # allocate for "oom"
                                 dup  if_zero ^safe_malloc.shit ^safe_malloc.meh
              @safe_malloc.shit  _0  _0  crash  # not even three bytes :(
              @safe_malloc.meh   dup  store_bytes _3 "oom"  _3  crash
: safe_free   free_word_aligned ;# (ptr ->)
              # Just for symmetry with safe_malloc; freeing is always safe.
: unreachable  call ^unreachable ;
              @unreachable
               push_word _11  safe_malloc_byte_aligned  dup  store_bytes _11 "unreachable"
               push_word _11 crash
: memcopy     # (from to amount ->)
              call ^memcopy ;
              @memcopy       push_word _0
              @memcopy.loop  over  over  if_num_eq ^@memcopy.done ^memcopy.copy
              @memcopy.done  pop4  return
              @memcopy.copy  over2  over  add  over4  over2  add
                             load_byte  store_byte  inc  jump ^memcopy.loop

## Tuples
#
# Because the bottleneck for my Grass projects is not execution speed, but
# implementation complexity, I'm not afraid of pointer indirections: Rather than
# keeping data directly on the stack, most data structures have a heap-allocated
# single source of truth and only keep pointers on the stack.
#
# ( tuple )
#   │
#   v
# ( a | b | c )

: make_a      _8   safe_malloc ;#         ( -> tuple)
: make_ab     _16  safe_malloc ;#         ( -> tuple)
: make_abc    _24  safe_malloc ;#         ( -> tuple)
: make_abcd   _32  safe_malloc ;#         ( -> tuple)
: make_abcde  _40  safe_malloc ;#         ( -> tuple)
: free_a      _8   safe_free ;#      (tuple -> )
: free_ab     _16  safe_free ;#      (tuple -> )
: free_abc    _24  safe_free ;#      (tuple -> )
: free_abcd   _32  safe_free ;#      (tuple -> )
: free_abcde  _40  safe_free ;#      (tuple -> )
: a           load_word ;#           (tuple -> field)
: b           _8   add  load_word ;# (tuple -> field)
: c           _16  add  load_word ;# (tuple -> field)
: d           _24  add  load_word ;# (tuple -> field)
: e           _32  add  load_word ;# (tuple -> field)
: a=          store_word ;#                             (tuple field -> )
: b=          over  _8   add  over  store_word  pop2 ;# (tuple field -> )
: c=          over  _16  add  over  store_word  pop2 ;# (tuple field -> )
: d=          over  _24  add  over  store_word  pop2 ;# (tuple field -> )
: e=          over  _32  add  over  store_word  pop2 ;# (tuple field -> )

## Str
#
# ( str )
#    |
#    v
# ( ptr | len )
#    |
#    v
# ( bytes )

: make_str  # (ptr len -> str)
            make_ab  dup  over3  a=  dup  over2  b=  keep1_pop2 ;
: free_str  keep_load_b  free_slots_ab  safe_free ;# (str ->)
: str.ptr   a ;# (str -> ptr)
: str.len   b ;# (str -> len)
: str_eq # (str str -> bool)
            call ^str_eq ;
            @str_eq             over  str.len  over  str.len
                                if_eq ^str_eq.len_same ^str.len_diff
            @str_eq.len_diff    pop2  false return
            @str_eq.len_same    # a b
                                over  str.ptr  over  str.ptr  over2  str.len
                                keep3_pop2  _0
            @str_eq.loop        # a_ptr b_ptr len cursor
                                over  over  if_eq ^str_eq.done ^str_eq.cmp_bytes
            @str_eq.cmp_bytes   over3  over   add  load_byte  byte_to_int
                                over3  over2  add  load_byte  byte_to_int
                                if_eq ^str_eq.bytes_same ^str_eq.bytes_diff
            @str_eq.bytes_same  inc  jump ^str_eq.loop
            @str_eq.bytes_diff  pop4  false  return
            @str_eq.done        pop4  true   return
: if_str_eq # CAREFUL: Needs postfix targets: a b if_str_eq ^then ^else
            str_eq ;

@str.starts_with  # str prefix

 TODO

@str.starts_with_byte  # str byte
 TODO

# Before calling, make sure that len > 0.
@keep_starts_with  # ptr len byte
 byte_to_int       # ptr len byte
 over2             # ptr len byte ptr
 load_byte         # ptr len byte actual_byte
 compare           # ptr len same?
 jump_table 03 ^keep_starts_with.yes ^keep_starts_with.no ^keep_starts_with.no
@keep_starts_with.yes  # ptr len
 push_byte 01          # ptr len 01
 return
@keep_starts_with.no  # ptr len
 push_byte 00         # ptr len 00
 return



## Out
#
# An automatically growing output buffer for bytes.
#
# ( out )
#    │
#    v
# ( ptr | cap | len )
#    │
#    v
# ( bytes )

: make_out  # (-> out)
            _16  safe_malloc  _16  _0
            make_abc  keep_c=  keep_b=  keep_a= ;
: free_out  # (out ->)
            keep_load_a  keep_load_b  free_slots_abc  safe_free ;
: out.ptr   a ;# (out -> ptr)
: out.cap   b ;# (out -> cap)
: out.len   c ;# (out -> len)
: out.ptr=  a= ;# (out ptr -> )
: out.cap=  b= ;# (out cap -> )
: out.len=  c= ;# (out len -> )
: out.len++ dup  out.len  inc  out.len= ;# (out -> )
: emit      # (out byte -> )
            call ^emit ;
            @emit       byte_to_int  over  out.cap  over2  out.len
                        if_eq ^emit.grow ^emit.push
            @emit.grow  over  out.ptr  over2  out.cap  # out byte ptr cap
                        dup  _1  shift_left  # out byte ptr cap new_cap
                        dup  safe_malloc     # out byte ptr cap new_cap new_ptr
                        over3  over  over4  memcopy
                        over5  # out byte ptr cap new_cap new_ptr out
                        dup  over2  out.ptr=
                        dup  over3  out.cap=
                        pop3  safe_free  # out byte  (old buffer freed)
            @emit.push  over  out.ptr  over2  out.len  add  # out byte ptr+len
                        over  lower_byte  store_byte  # out byte
                        pop1  out.len++  return
: append    # (out str -> )
            call ^append ;
            @append           dup  str.ptr  over  str.len  keep2_pop1  _0
            @append.loop      # out ptr len cursor
                              over  over  if_eq ^append.done ^append.not_done
            @append.done      pop4 return
            @append.not_done  over3  over3  over2  # out ptr len cursor out ptr cursor
                              add  load_byte  emit  # out ptr len cursor
                              inc  jump ^append.loop
: shrink    # (out -> str)
            dup  out.ptr  swap dup  out.cap  swap dup  out.len  # ptr cap len out
            swap  free_abc               # ptr cap len
            dup  safe_malloc             # ptr cap len new_ptr
            over3  over  over3  memcopy  # ptr cap len new_ptr
            over3  over3  safe_free      # ptr cap len new_ptr
            over  keep2_pop3  make_str  return

## Dictionary
#
# A dictionary from strings to some values. Uses a linear search for lookup.
# The capacity and length are stored in number of entries.
#
# ( dict )
#   │
#   v
# ( ptr | cap | len )
#   │
#   v
# ( key | val | key | val | ... )

: make_dict  # ( -> dict)
             make_abc
             dup  _16  safe_malloc  dict.ptr=
             dup  _1  dict.cap=
             dup  _0  dict.len=
             _16  safe_malloc  _16  _0
  make_abc  keep_c=  keep_b=  keep_a= ;
: dict.ptr   a ;# (dict -> ptr)
: dict.cap   b ;# (dict -> cap)
: dict.len   c ;# (dict -> len)
: dict.ptr=  a= ;# (dict ptr -> )
: dict.cap=  b= ;# (dict cap -> )
: dict.len=  c= ;# (dict len -> )
: lookup     # (dict key -> value)


@lookup_num  # dict key_ptr key_len -> value_ptr value_len

@lookup_string  # dict key_ptr key_len -> value_ptr value_len

@put_num  # dict key_ptr key_len value ->

@put_string  # dict key_ptr key_len value ->

@free_dict_of_nums

@free_dict_of_strings






@main                  # ptr length
 call ^make_parser     # parser
 push_word _0          # parser parent
 over                  # parser parent parser
 pop_below_top _16 08  # parent parser
 call ^make_output     # parent parser output
 call ^make_dict       # parent parser output words
 TODO: init dict with hex digits
 call ^make_dict       # parent parser output words labels
 jump ^compile

@compile               # parent parser output words labels
 over3                 # parent parser output words labels parser
 call ^next            # parent parser output words labels ptr len
 dup                   # parent parser output words labels ptr len len
 compare_zero          # parent parser output words labels ptr len at_end?
 jump_table 03 ^compile.done ^compile.not_done ^compile.not_done
@compile.not_done  # parent parser output words labels ptr len
 dup               # parent parser output words labels ptr len len
 push_word _1      # parent parser output words labels ptr len len 1
 compare           # parent parser output words labels ptr len is_len_1?
 jump_table 03 ^compile.len_is_1 ^compile.len_not_1 ^unreachable
@compile.len_is_1        # parent parser output words labels ptr len
 push_byte colon         # parent parser output words labels ptr len colon
 call ^keep_starts_with  # parent parser output words labels ptr len colon?
 jump_table 02 ^compile.not_colon ^compile.is_colon
@compile.is_colon  # parent parser output words labels ptr len
 pop 10            # parent parser output words labels
 jump ^word_def
@compile.not_colon       # parent parser output words labels ptr len
 push_byte bang          # parent parser output words labels ptr len bang
 call ^keep_starts_with  # parent parser output words labels ptr len bang?
 jump_table 02 ^word_ref ^compiler.is_bang
@compile.is_bang  # parent parser output words labels ptr len
 pop 10           # parent parser output words labels
 jump ^import
@compile.len_not_1       # parent parser output words labels ptr len
 push_byte at            # parent parser output words labels ptr len at
 call ^keep_starts_with  # parent parser output words labels ptr len at?
 jump_table 02 ^compile.not_label_def ^label_def
@compile.not_label_def   # parent parser output words labels ptr len
 push_byte tick          # parent parser output words labels ptr len tick
 call ^keep_starts_with  # parent parser output words labels ptr len tick?
 jump_table 02 ^word_ref ^label_ref
@compile.done  # parent parser output words labels ptr len
 pop 10        # parent parser output words labels
 over4         # parent parser output words labels parent
 compare_zero  # parent parser output words labels has_parent?
 jump_table 03 ^compile.totally_done ^compile.back_to_parent ^compile.back_to_parent
@compile.back_to_parent  # parent parser output words labels
 pop 20                  # parent
 keep_load_a       # context parent
 keep_load_b       # context parser parent
 keep_load_c       # context parser output parent
 keep_load_d       # context parser output words parent
 load_e            # context parser output words labels
 jump ^compile
@compile.totally_done        # parent parser output words labels
 call ^free_dict_of_nums     # parent parser output words
 call ^free_dict_of_strings  # parent parser output
 over                        # parent parser output parser
 call ^free_parser           # parent parser output
 pop_below_top _8 10         # output
 call ^shrink                # ptr len

# Imports a file. Pack up everything into a context closure that the environment
# will pass on to our continuation.
#
# ┌─────────┐
# │ context │
# └─────────┘
#     │
#     v
# ┌────────┬────────┬────────┬────────┬────────┐
# │ parent | parser | output | words  │ labels |
# └────────┴────────┴────────┴────────┴────────┘
@import                      # parent parser output words labels
 over3                       # parent parser output words labels parser
 call ^next                  # parent parser output words labels ptr len
 over6                       # parent parser output words labels ptr len parent
 over6                       # parent parser output words labels ptr len parent parser
 over6                       # parent parser output words labels ptr len parent parser output
 over6                       # parent parser output words labels ptr len parent parser output words
 over6                       # parent parser output words labels ptr len parent parser output words labels
 pop_below_top _56 28        # ptr len parent parser output words labels
 call ^make_slots_a_b_c_d_e  # ptr len parent parser output words labels context
 keep_store_e          # ptr len parent parser output words context
 keep_store_d          # ptr len parent parser output context
 keep_store_c          # ptr len parent parser context
 keep_store_b          # ptr len parent context
 keep_store_a          # ptr len context
 push_indirect ^import.cont  # ptr len context cont
 push_byte 00                # ptr len context cont 0
 return
@import.cont        # context ptr len
 call ^make_parser  # context parser
 over               # context parser context
 keep_load_c  # context parser output context
 keep_load_d  # context parser output words context
 load_e       # context parser output words labels
 jump ^compile

# Compiles a definition. The colon and name have already been consumed, we only
# need to parse the actual content up to the semicolon. Note that definitions
# can't contain other definitions, imports, label definitions, or label
# references.
@word_def              # parser output words labels
 over                  # parser output words labels words
 over4                 # parser output words labels words parser
 call ^next            # parser output words labels words ptr len
 over6                 # parser output words labels words ptr len parser
 call ^make_output     # parser output words labels words ptr len parser word_output
 over4                 # parser output words labels words ptr len parser word_output words
 call ^compile_def     # parser output words labels words ptr len def_ptr def_len
 call ^make_slots_a_b  # parser output words labels words ptr len def_ptr def_len entry
 keep_store_b    # parser output words labels words ptr len def_ptr entry
 keep_store_a    # parser output words labels words ptr len entry
 call ^put             # parser output words labels
 jump ^compile

@compile_def   # parser output dict
 over2         # parser output dict parser
 call ^next    # parser output dict word_ptr word_len
 dup           # parser output dict word_ptr word_len word_len
 push_word _1  # parser output dict word_ptr word_len word_len 1
 compare       # parser output dict word_ptr word_len is_len_1?
 jump_table 03 ^compile_def.len_is_1 ^compile_def.not_semicolon ^unreachable
@compile_def.len_is_1  # parser output dict word_ptr word_len
 over                  # parser output dict word_ptr word_len word_ptr
 load_byte             # parser output dict word_ptr word_len byte
 byte_to_int           # parser output dict word_ptr word_len byte
 push_word TODO        # parser output dict word_ptr word_len byte ;
 compare               # parser output dict word_ptr word_len is_semicolon?
 jump_table 03 ^compile_def.is_semicolon ^compile_def.not_semicolon ^compile_def.not_semicolon
@compile_def.not_semicolon  # parser output dict word_ptr word_len
 over3                      # parser output dict word_ptr word_len output
 over3                      # parser output dict word_ptr word_len output dict
 over3                      # parser output dict word_ptr word_len output dict word_ptr
 over3                      # parser output dict word_ptr word_len output dict word_ptr word_len
 call ^lookup_string        # parser output dict word_ptr word_len output def_ptr def_len
 call ^append               # parser output dict word_ptr word_len
 pop 10                     # parser output dict
 jump ^compile_def
@compile_def.is_semicolon  # parser output dict word_ptr word_len
 pop 18                    # parser output
 pop_below_top _8 08       # output
 call ^shrink              # ptr len
 return

@word_ref      # parser output words labels ptr len
 over4         # parser output words labels ptr len output
 over4         # parser output words labels ptr len output words
 over3         # parser output words labels ptr len output words ptr
 over3         # parser output words labels ptr len output words ptr len
 call ^lookup  #


@label_def # parser output words labels ptr len
 TODO

@label_ref # parser output words labels ptr len
 TODO







@hex_to_num   # char


@unreachable
todo


# Parser
# The parser offers a way to step through bytes (the textual input). It
# maintains a cursor that starts at the beginning. You can ^peek the current
# character, ^advance the cursor by one character, and do higher-level
# operations such as consuming all leading whitespace or consuming a word.
#
# ┌────────┐
# │ parser │
# └────────┘
#     │
#     v
# ┌────────┬────────┬────────┐
# │ ptr    | length | cursor │
# └────────┴────────┴────────┘
#     │
#     v
# ┌───────────────────────────────────────────┐
# │ bytes                                     │
# └───────────────────────────────────────────┘

@make_parser              # ptr length
 push_word _0             # ptr length 0
 call ^alloc_slots_a_b_c  # ptr length 0 parser
 keep_store_c       # ptr length parser
 keep_store_b       # ptr parser
 keep_store_a       # parser
 return

@free_parser             # parser
 dup                     # parser parser
 keep_load_a       # parser ptr parser
 load_b            # parser ptr length
 free_byte_aligned       # parser
 free_slots_a_b_c  #
 return

# Turns a parser into its current character or zero if it's at the end.
@peek                     # parser
 dup                      # parser parser
 keep_load_b        # parser length parser
 load_c             # parser length cursor
 compare                  # parser at_end?
 jump_table 03 ^peek.return_0 ^peek.char ^unreachable
@peek.return_0   # parser
 pop 08          #
 push_byte 00    # 0
 return
@peek.char      # parser
 keep_load_a  # ptr parser
 load_c       # ptr cursor
 add                # ptr+cursor
 load_byte          # char
 return

# Advances the parser's cursor by one character.
@advance        # parser
 dup            # parser parser
 load_c   # parser cursor
 push_word _1   # parser cursor 1
 add            # parser cursor+1
 over           # parser cursor+1 parser
 store_c  # parser
 pop 08         #
 return
